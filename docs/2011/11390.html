<!DOCTYPE html>
<html lang=en>
           <head>
            <meta charset=UTF-8>
            <title>Ironclad Library?</title>
            <meta name=viewport
                  content="width=device-width, initial-scale=1.0">
            <link rel=stylesheet
                  href=https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css
                  integrity=sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2
                  crossorigin=anonymous>
            <style>
section.tree {
    padding-left: 2em;
}
section.tree:first-child {
    padding-left: 0;
}
.article-link {
  margin-bottom: 1em;
}
</style>
<!-- Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-9X3G9MMWZP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-9X3G9MMWZP');
</script>

           </head>
           <body>
            <header class="d-flex justify-content-center">
             <nav
                  class="navbar navbar-light bg-light w-100 mx-5 mb-3">
              <a class=navbar-brand href="/">Lisp HUG Maillist Archive</a>
             </nav>
            </header>
            <div class="d-flex justify-content-center">
             <div class="w-100 mx-5 px-3">
              <section class=tree>
               <article class=email>
                <h1>Ironclad Library?</h1><html><head></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; ">Hi,<br><br>I just ran into a perplexing situation here. I have been using Ironclad for SHA256 and AES256 functions. Up to now I have been totally happy -- read: it seems internally consistent. But now, when using against encrypted products from a C implementation of these same functions, I can't get my Ironclad digests to agree with the C library versions.<br><br>On further investigation, the C library functions for SHA256 produce output consistent with published test vectors, while Ironclad SHA256 does not. Strangely, however, they do agree on the SHA256 sum of disk files. But on anything else -- byte vectors representing strings in memory, they depart wildly, with the C implementation producing apparently correct results. The C implementation is from PolarSSL.<br><br>Is anyone else using Ironclad? Is it being maintained? Has anyone else seen this deviant behavior?<div><br><div>
<span class="Apple-style-span" style="border-collapse: separate; color: rgb(0, 0, 0); font-family: Helvetica; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-align: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-border-horizontal-spacing: 0px; -webkit-border-vertical-spacing: 0px; -webkit-text-decorations-in-effect: none; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; "><div>Dr. David McClain</div><div><a href="mailto:dbm@refined-audiometrics.com">dbm@refined-audiometrics.com</a></div><div><br></div></span><br class="Apple-interchange-newline">
</div>

<br></div></body></html>

               </article>
               <section class=tree>
                <article class=email>
                 <h1>Re: Ironclad Library?</h1>
                 <pre>
David McClain &lt;dbm@refined-audiometrics.com&gt writes:

&gt Hi,
&gt
&gt I just ran into a perplexing situation here. I have been using Ironclad for
&gt SHA256 and AES256 functions. Up to now I have been totally happy -- read: it
&gt seems internally consistent. But now, when using against encrypted products
&gt from a C implementation of these same functions, I can't get my Ironclad
&gt digests to agree with the C library versions.
&gt
&gt On further investigation, the C library functions for SHA256 produce output
&gt consistent with published test vectors, while Ironclad SHA256 does not.
&gt Strangely, however, they do agree on the SHA256 sum of disk files. But on
&gt anything else -- byte vectors representing strings in memory, they depart
&gt wildly, with the C implementation producing apparently correct results. The C
&gt implementation is from PolarSSL.
&gt
&gt Is anyone else using Ironclad? Is it being maintained? Has anyone else seen
&gt this deviant behavior?

I use ironclad, though not on LispWorks, and have not had any trouble
with SHA1 and MD5 digests of sequences, but I haven't tried SHA256 on
sequences.

Is there some example input &amp; output I could check on my implementation
to see if I get the same problem?

Zach


</pre>
                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: Ironclad Library?</h1>
                 <pre>
Hi David,

Am 27.11.2011 um 01:16 schrieb David McClain &lt;dbm@refined-audiometrics.com&gt:

&gt Hi,
&gt 
&gt I just ran into a perplexing situation here. I have been using Ironclad for SHA256 and AES256 functions. Up to now I have been totally happy -- read: it seems internally consistent. But now, when using against encrypted products from a C implementation of these same functions, I can't get my Ironclad digests to agree with the C library versions.
&gt 
&gt On further investigation, the C library functions for SHA256 produce output consistent with published test vectors, while Ironclad SHA256 does not. Strangely, however, they do agree on the SHA256 sum of disk files. But on anything else -- byte vectors representing strings in memory, they depart wildly, with the C implementation producing apparently correct results. The C implementation is from PolarSSL.
&gt 
&gt Is anyone else using Ironclad? Is it being maintained? Has anyone else seen this deviant behavior?

You have to be really really careful what type of vector you feed in. If you feed the wrong one there will be no error but wrong digest results!

Cheers,
Jochen


</pre>
                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: Ironclad Library?</h1>There is also the following paper on predicate dispatching :<div><br></div><div>&quot;Predicate Dispatching in the Common Lisp Object System&quot;, Aaron Mark Ucko, AI Technical Report 2001-006.</div><div><br></div><div>Regards,</div>
<div><br></div><div>Tom<br clear="all">----------------------------------------------------------------<br>Thomas M. Hermann<br>Odonata Research LLC<br><a href="http://www.odonata-research.com/">http://www.odonata-research.com/</a><br>
<a href="http://www.linkedin.com/in/thomasmhermann">http://www.linkedin.com/in/thomasmhermann</a><br>
<br><br><div class="gmail_quote">On Wed, Nov 30, 2011 at 12:38 PM, Jochen Schmidt <span dir="ltr">&lt;<a href="mailto:js@crispylogics.com">js@crispylogics.com</a>&gt;</span> wrote:<br><blockquote class="gmail_quote" style="margin:0 0 0 .8ex;border-left:1px #ccc solid;padding-left:1ex;">
<br>
One possibility would be something like predicate dispatch. AFAIR Pascal Costanza did some work in that direction with his &quot;Filtered Dispatch&quot;.<br>
<br>
Am 30.11.2011 um 16:23 schrieb Martin Simmons &lt;<a href="mailto:martin@lispworks.com">martin@lispworks.com</a>&gt;:<br>
<div class="HOEnZb"><div class="h5"><br>
&gt;<br>
&gt; Class names are always symbols in Common Lisp, so it isn&#39;t possible to<br>
&gt; specialize on compound types.<br>
&gt;<br>
&gt; --<br>
&gt; Martin Simmons<br>
&gt; LispWorks Ltd<br>
&gt; <a href="http://www.lispworks.com/" target="_blank">http://www.lispworks.com/</a><br>
&gt;<br>
&gt;<br>
&gt;&gt;&gt;&gt;&gt;&gt; On Mon, 28 Nov 2011 02:36:20 -0700, David McClain said:<br>
&gt;&gt;<br>
&gt;&gt; Yep! That was the whole problem.. the giveaway was that it successfully performed a SHA2 sum on files, but not on my test vectors done in the listener.<br>
&gt;&gt;<br>
&gt;&gt; I wonder if there is a way to make CLOS more sensitive to compound types? Vector (of what?). It manages okay between strings, vectors, and lists. But no way to indicate sub-species of vectors in the outer type discrimination. [ I also fear that I&#39;m aiming down the road to FPL, and that isn&#39;t what I want either.. .I like Lisp&#39;s flexibility. Guess I just need to be more careful.]<br>

&gt;&gt;<br>
&gt;&gt; - DM<br>
&gt;&gt;<br>
&gt;&gt; On Nov 26, 2011, at 17:32 PM, Jochen Schmidt wrote:<br>
&gt;&gt;<br>
&gt;&gt;&gt;<br>
&gt;&gt;&gt; Hi David,<br>
&gt;&gt;&gt;<br>
&gt;&gt;&gt; Am 27.11.2011 um 01:16 schrieb David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com">dbm@refined-audiometrics.com</a>&gt;:<br>
&gt;&gt;&gt;<br>
&gt;&gt;&gt;&gt; Hi,<br>
&gt;&gt;&gt;&gt;<br>
&gt;&gt;&gt;&gt; I just ran into a perplexing situation here. I have been using Ironclad for SHA256 and AES256 functions. Up to now I have been totally happy -- read: it seems internally consistent. But now, when using against encrypted products from a C implementation of these same functions, I can&#39;t get my Ironclad digests to agree with the C library versions.<br>

&gt;&gt;&gt;&gt;<br>
&gt;&gt;&gt;&gt; On further investigation, the C library functions for SHA256 produce output consistent with published test vectors, while Ironclad SHA256 does not. Strangely, however, they do agree on the SHA256 sum of disk files. But on anything else -- byte vectors representing strings in memory, they depart wildly, with the C implementation producing apparently correct results. The C implementation is from PolarSSL.<br>

&gt;&gt;&gt;&gt;<br>
&gt;&gt;&gt;&gt; Is anyone else using Ironclad? Is it being maintained? Has anyone else seen this deviant behavior?<br>
&gt;&gt;&gt;<br>
&gt;&gt;&gt; You have to be really really careful what type of vector you feed in. If you feed the wrong one there will be no error but wrong digest results!<br>
&gt;&gt;&gt;<br>
&gt;&gt;&gt; Cheers,<br>
&gt;&gt;&gt; Jochen<br>
&gt;&gt;&gt;<br>
&gt;&gt;&gt;<br>
&gt;&gt;<br>
&gt;&gt; Dr. David McClain<br>
&gt;&gt; <a href="mailto:dbm@refined-audiometrics.com">dbm@refined-audiometrics.com</a><br>
&gt;<br>
<br>
</div></div></blockquote></div><br></div>


                </article>
               </section>
              </section>
             </div>
            </div>
            <footer class="d-flex justify-content-center">
             <div>
              Updated at: 2020-12-10 08:37 UTC
             </div>
            </footer>
           </body>
          </html>