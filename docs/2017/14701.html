<!DOCTYPE html>
<html lang=en>
           <head>
            <meta charset=UTF-8>
            <title>Common Lisp Blockchain - Scheme Coin</title>
            <link rel=stylesheet
                  href=https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css
                  integrity=sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2
                  crossorigin=anonymous>
            <style>
section.tree {
    padding-left: 2em;
}
section.tree:first-child {
    padding-left: 0;
}
.article-link {
  margin-bottom: 1em;
}
</style>
<!-- Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-9X3G9MMWZP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-9X3G9MMWZP');
</script>

           </head>
           <body>
            <header class="d-flex justify-content-center">
             <nav
                  class="navbar navbar-light bg-light w-100 mx-5 mb-3">
              <a class=navbar-brand href="/">Lisp HUG Maillist Archive</a>
             </nav>
            </header>
            <div class="d-flex justify-content-center">
             <div class="w-100 mx-5 px-3">
              <section class=tree>
               <article class=email>
                <h1>Common Lisp Blockchain - Scheme Coin</h1><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; line-break: after-white-space;" class="">Here’s a little ditty I decided to share. &nbsp;A Common Lisp Blockchain implementation of a coin that has a useful Proof of Work: Scheme Evaluation. &nbsp;<div class=""><br class=""></div><div class="">Incomplete, but still interesting per the previous week’s discussion.</div><div class=""><br class=""></div><div class=""><div class="">;;</div><div class="">;; scheme coin - a common lisp blockchain</div><div class="">;;</div><div class="">;; Burton Samograd</div><div class="">;; 2017</div><div class=""><br class=""></div><div class="">(load "~/quicklisp/setup.lisp")</div><div class=""><br class=""></div><div class="">(defconstant *coin-name* "Scheme Coin")</div><div class=""><br class=""></div><div class="">(eval-when (compile load)</div><div class="">&nbsp; (ql:quickload "ironclad"))</div><div class=""><br class=""></div><div class="">(defun rest2 (l)</div><div class="">&nbsp; (cddr l))</div><div class=""><br class=""></div><div class="">(defun interp (x &amp;optional env)</div><div class="">&nbsp; "Interpret (evaluate) the expression x in the environment env."</div><div class="">&nbsp; (cond</div><div class="">&nbsp; &nbsp;((symbolp x) (get-var x env))</div><div class="">&nbsp; &nbsp;((atom x) x)</div><div class="">&nbsp; &nbsp;((scheme-macro (first x))</div><div class="">&nbsp; &nbsp; (interp (scheme-macro-expand x) env))</div><div class="">&nbsp; &nbsp;((case (first x)</div><div class="">&nbsp; &nbsp; &nbsp; (QUOTE (second x))</div><div class="">&nbsp; &nbsp; &nbsp; (BEGIN (last1 (mapcar #'(lambda (y) (interp y env))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (rest x))))</div><div class="">&nbsp; &nbsp; &nbsp; (SET! (set-var! (second x) (interp (third x) env) env))</div><div class="">&nbsp; &nbsp; &nbsp; (if (if (interp (second x) env)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (interp (third x) env)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (interp (fourth x) env)))</div><div class="">&nbsp; &nbsp; &nbsp; (LAMBDA (let ((parms (second x))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (code (maybe-add 'begin (rest2 x))))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #'(lambda (&amp;rest args)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (interp code (extend-env parms args env)))))</div><div class="">&nbsp; &nbsp; &nbsp; (t ;; a procedure application</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(apply (interp (first x) env)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (mapcar #'(lambda (v) (interp v env))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (rest x))))))))</div><div class=""><br class=""></div><div class="">(defun scheme-macro (symbol)</div><div class="">&nbsp; (and (symbolp symbol) (get symbol 'scheme-macro)))</div><div class=""><br class=""></div><div class="">(defmacro def-scheme-macro (name parmlist &amp;body body)</div><div class="">&nbsp; `(setf (get ',name 'scheme-macro)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;#'(lambda ,parmlist .,body)))</div><div class=""><br class=""></div><div class="">(defun scheme-macro-expand (x)</div><div class="">&nbsp; (if (and (listp x) (scheme-macro (first x)))</div><div class="">&nbsp; &nbsp; &nbsp; (scheme-macro-expand</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp;(apply (scheme-macro (first x)) (rest x)))</div><div class="">&nbsp; &nbsp; x))</div><div class=""><br class=""></div><div class="">(defun set-var! (var val env)</div><div class="">&nbsp; "Set a variable to a value, in the given or global environment."</div><div class="">&nbsp; (if (assoc var env)</div><div class="">&nbsp; &nbsp; &nbsp; (setf (second (assoc var env)) val)</div><div class="">&nbsp; &nbsp; (set-global-var! var val))</div><div class="">&nbsp; val)</div><div class=""><br class=""></div><div class="">(defun get-var (var env)</div><div class="">&nbsp; (if (assoc var env)</div><div class="">&nbsp; &nbsp; &nbsp; (second (assoc var env))</div><div class="">&nbsp; &nbsp; (get-global-var var)))</div><div class=""><br class=""></div><div class="">(defun set-global-var! (var val)</div><div class="">&nbsp; (setf (get var 'global-val) val))</div><div class=""><br class=""></div><div class="">(defun get-global-var (var)</div><div class="">&nbsp; (let* ((default "unbound")</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(val (get var 'global-val default)))</div><div class="">&nbsp; &nbsp; (if (eq val default)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; (error "Unbound scheme variable: ~A" var)</div><div class="">&nbsp; &nbsp; &nbsp; val)))</div><div class=""><br class=""></div><div class="">(defun extend-env (vars vals env)</div><div class="">&nbsp; "Add some variables and values to and environment."</div><div class="">&nbsp; (nconc (mapcar #'list vars vals) env))</div><div class=""><br class=""></div><div class="">(defparameter *scheme-procs*</div><div class="">&nbsp; '(+ - * / = &lt; &gt; &lt;= &gt;= cons car cdr not append list read member&nbsp;</div><div class="">&nbsp; &nbsp; &nbsp; (null? null) (eq? eq) (equal? equal) (eqv? eql)</div><div class="">&nbsp; &nbsp; &nbsp; (write prin1) (display princ) (newline terpri)))</div><div class=""><br class=""></div><div class="">(defun init-scheme-interp ()</div><div class="">&nbsp; (mapc #'init-scheme-proc *scheme-procs*)</div><div class="">&nbsp; (set-global-var! t t)</div><div class="">&nbsp; (set-global-var! nil nil))</div><div class=""><br class=""></div><div class="">(defun init-scheme-proc (f)</div><div class="">&nbsp; (if (listp f)</div><div class="">&nbsp; &nbsp; &nbsp; (set-global-var! (first f) (symbol-function (second f)))</div><div class="">&nbsp; &nbsp; (set-global-var! f (symbol-function f))))</div><div class=""><br class=""></div><div class="">(defun maybe-add (op exps &amp;optional if-nil)</div><div class="">&nbsp; (cond ((null exps) if-nil)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; ((length=1 exps) (first exps))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; (t (cons op exps))))</div><div class=""><br class=""></div><div class="">(defun length=1 (x)&nbsp;</div><div class="">&nbsp; (and (consp x) (null (cdr x))))</div><div class=""><br class=""></div><div class="">(defun last1 (list)</div><div class="">&nbsp; (first (last list)))</div><div class=""><br class=""></div><div class="">(defun scheme ()</div><div class="">&nbsp; (init-scheme-interp)</div><div class="">&nbsp; (loop (format t "~&amp;==&gt; ")</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; (print (interp (read) nil))))</div><div class=""><br class=""></div><div class="">(def-scheme-macro let (bindings &amp;rest body)</div><div class="">&nbsp; `((lambda ,(mapcar #'first bindings) . ,body)</div><div class="">&nbsp; &nbsp; .,(mapcar #'second bindings)))</div><div class=""><br class=""></div><div class="">(def-scheme-macro let* (bindings &amp;rest body)</div><div class="">&nbsp; (if (null bindings)</div><div class="">&nbsp; &nbsp; &nbsp; `(begin . ,body)</div><div class="">&nbsp; &nbsp; `(let (,(first bindings))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp;(let* ,(rest bindings) . ,body))))</div><div class=""><br class=""></div><div class="">(def-scheme-macro and (&amp;rest args)</div><div class="">&nbsp; (cond ((null args) 'T)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; ((length=1 args) (first args))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; (t `(if ,(first args)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (and . ,(rest args))))))</div><div class=""><br class=""></div><div class="">(def-scheme-macro or (&amp;rest args)</div><div class="">&nbsp; (cond ((null args) 'nil)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; ((length=1 args) (first args))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; (t (let ((var (gensym)))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;`(let ((,var ,(first args)))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (if ,var ,var (or . ,(rest args))))))))</div><div class=""><br class=""></div><div class="">(init-scheme-interp)</div><div class="">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</div><div class="">;;;;;; and there we have a scheme interpreter with macros. ;;;;;;;;;;;;;;;</div><div class="">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</div><div class=""><br class=""></div><div class="">(defstruct block</div><div class="">&nbsp; (index 0) (timestamp 0) data (previous-hash "") hash)</div><div class=""><br class=""></div><div class="">(defstruct transaction&nbsp;</div><div class="">&nbsp; from to (value 0) (accuracy 1)</div><div class="">&nbsp; (duration 0)</div><div class="">&nbsp; data hash previous-hash)</div><div class=""><br class=""></div><div class="">(defun to-byte-array (x)</div><div class="">&nbsp; (let ((retval (make-array 0 :adjustable t&nbsp;</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; :fill-pointer t&nbsp;</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; :element-type '(unsigned-byte 8))))</div><div class="">&nbsp; &nbsp; (map 'nil (lambda (c) (vector-push-extend (char-code c) retval))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(format nil "~A" x)) ;</div><div class="">&nbsp; &nbsp; (coerce retval 'ironclad::simple-octet-vector)))</div><div class=""><br class=""></div><div class="">(defun make-address (x)</div><div class="">&nbsp; (let ((digester (ironclad:make-digest :sha3)))</div><div class="">&nbsp; &nbsp; (ironclad:update-digest digester</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (to-byte-array x))</div><div class="">&nbsp; &nbsp; (ironclad:produce-digest digester)))</div><div class=""><br class=""></div><div class="">(defun hash-block (block)</div><div class="">&nbsp; (let ((digester (ironclad:make-digest :sha3)))</div><div class="">&nbsp; &nbsp; (ironclad:update-digest digester</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (to-byte-array (block-index block)))</div><div class="">&nbsp; &nbsp; (ironclad:update-digest digester</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (to-byte-array (block-timestamp block)))</div><div class="">&nbsp; &nbsp; (ironclad:update-digest digester</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (to-byte-array (block-data block)))</div><div class="">&nbsp; &nbsp; (ironclad:update-digest digester</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (to-byte-array (block-previous-hash block)))</div><div class="">&nbsp; &nbsp; (ironclad:produce-digest digester)))</div><div class=""><br class=""></div><div class="">(defun hash-transaction (block)</div><div class="">&nbsp; (let ((digester (ironclad:make-digest :sha3)))</div><div class="">&nbsp; &nbsp; (ironclad:update-digest digester</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (to-byte-array (transaction-from block)))</div><div class="">&nbsp; &nbsp; (ironclad:update-digest digester</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (to-byte-array (transaction-to block)))</div><div class="">&nbsp; &nbsp; (ironclad:update-digest digester</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (to-byte-array (transaction-value block)))</div><div class="">&nbsp; &nbsp; (ironclad:update-digest digester</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (to-byte-array (transaction-accuracy block)))</div><div class="">&nbsp; &nbsp; (ironclad:update-digest digester</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (to-byte-array (transaction-duration block)))</div><div class="">&nbsp; &nbsp; (ironclad:update-digest digester</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (to-byte-array (transaction-data block)))</div><div class="">&nbsp; &nbsp; (ironclad:produce-digest digester)))</div><div class=""><br class=""></div><div class="">(defun make-genesis-block (data time)</div><div class="">&nbsp; (let* ((block (make-block&nbsp;</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:index 0</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:timestamp time</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:data data</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:hash 0))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(hash (hash-block block)))</div><div class="">&nbsp; &nbsp; (setf (block-hash block) hash)</div><div class="">&nbsp; &nbsp; block))</div><div class=""><br class=""></div><div class="">(defmacro create-genesis-block (data)</div><div class="">&nbsp; `(let ((time (get-universal-time)))</div><div class="">&nbsp; &nbsp; &nbsp;(make-genesis-block ,data time)))</div><div class=""><br class=""></div><div class="">(defun next-block (last-block data)</div><div class="">&nbsp; (let ((block (make-block :index (1+ (block-index last-block))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:timestamp (get-universal-time)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:data data</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:previous-hash (hash-block last-block))))</div><div class="">&nbsp; &nbsp; (setf (block-hash block) (hash-block block))</div><div class="">&nbsp; &nbsp; (push &nbsp;block *blockchain*)</div><div class="">&nbsp; &nbsp; block))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div><div class="">(setf *print-base* 16)</div><div class=""><br class=""></div><div class="">(defconstant *base-code* '(set! x 0))</div><div class=""><br class=""></div><div class="">(defparameter *network-address* (make-address *coin-name*))</div><div class="">(defparameter *quester-address* (make-address "quester"))</div><div class="">(defparameter *miner-address* (make-address "miner"))</div><div class="">(defparameter *contract-address* (make-address "contract"))</div><div class=""><br class=""></div><div class="">(defparameter *block-transactions*</div><div class="">&nbsp; (let ((transaction (make-transaction :from *network-address*</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:to *quester-address*</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:value (* 10000 10000 10000)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:data *base-code*)))</div><div class="">&nbsp; &nbsp; (setf (transaction-hash transaction)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (hash-transaction transaction))</div><div class="">&nbsp; &nbsp; (list transaction)))</div><div class=""><br class=""></div><div class="">(defparameter *blockchain*&nbsp;</div><div class="">&nbsp; (list (create-genesis-block *block-transactions*)))</div><div class=""><br class=""></div><div class="">(defparameter *previous-block* (car *blockchain*))</div><div class=""><br class=""></div><div class="">(defparameter *solved-transactions* (make-hash-table :test #'equalp</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:weak-kind t))</div><div class="">(eval-when (compile load)</div><div class="">&nbsp; (defun new-transaction (&amp;key from to (value 0) accuracy data&nbsp;</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;previous-hash duration)</div><div class="">&nbsp; &nbsp; (let ((transaction (make-transaction :from from :to to :value value</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:accuracy accuracy :data data&nbsp;</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:previous-hash previous-hash</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:duration duration)))</div><div class="">&nbsp; &nbsp; &nbsp; (setf (transaction-hash transaction)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (hash-transaction transaction))</div><div class="">&nbsp; &nbsp; &nbsp; (when previous-hash</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; (setf (gethash</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(transaction-hash transaction)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*solved-transactions*)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t))</div><div class="">&nbsp; &nbsp; &nbsp; transaction)))</div><div class=""><br class=""></div><div class="">(defmacro submit-answer (from transaction data)</div><div class="">&nbsp; `(push (new-transaction :from ,from :to *contract-address*</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; :previous-hash &nbsp;(transaction-hash transaction)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; :data ,data)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*block-transactions*))</div><div class=""><br class=""></div><div class="">(defun has-transaction-not-been-solved (transaction)</div><div class="">&nbsp; (if (gethash (transaction-hash transaction)&nbsp;</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*solved-transactions*)</div><div class="">&nbsp; &nbsp; &nbsp; (not (setf (gethash (transaction-hash transaction)&nbsp;</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *solved-transactions*)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;transaction))</div><div class="">&nbsp; &nbsp; t))</div><div class=""><br class=""></div><div class="">(defun viable-transaction (transaction)</div><div class="">&nbsp; (and (has-transaction-not-been-solved transaction)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp;(&lt;= (block-index (car *blockchain*))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(or (transaction-duration transaction)&nbsp;</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-universal-time))))) ;; can still submit</div><div class=""><br class=""></div><div class="">(defun verify-transaction (transaction)</div><div class="">&nbsp; (handler-case</div><div class="">&nbsp; &nbsp; &nbsp; (interp (transaction-data transaction))</div><div class="">&nbsp; &nbsp; (error (e) e)))</div><div class="">&nbsp;&nbsp;</div><div class="">(defun execute-transactions (miner-address)</div><div class="">&nbsp; (dolist (transaction *block-transactions*)</div><div class="">&nbsp; &nbsp; (when (viable-transaction transaction)</div><div class="">&nbsp; &nbsp; &nbsp; (print :submitting-answer)</div><div class="">&nbsp; &nbsp; &nbsp; (submit-answer miner-address transaction &nbsp; &nbsp;&nbsp;</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(verify-transaction transaction))</div><div class="">&nbsp; &nbsp; &nbsp; )))</div><div class=""><br class=""></div><div class="">(defun mine ()</div><div class="">&nbsp; (when *block-transactions*</div><div class="">&nbsp; &nbsp; (execute-transactions *miner-address*)</div><div class="">&nbsp; &nbsp; (transfer *network-address* *miner-address* 1)</div><div class="">&nbsp; &nbsp; (setf *previous-block*&nbsp;</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (next-block *previous-block* *block-transactions*))</div><div class="">&nbsp; &nbsp; (setf *block-transactions* nil)))</div><div class="">&nbsp;&nbsp;</div><div class="">(defmacro transfer (from to value)</div><div class="">&nbsp; `(push (new-transaction :from ,from :to ,to</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; :value ,value)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*block-transactions*))</div><div class=""><br class=""></div><div class="">(defmacro execute (from value code &amp;key (accuracy value)&nbsp;</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (duration (+ 2 (block-index (car *blockchain*)))))</div><div class="">&nbsp; `(push (new-transaction :from ,from :to *contract-address*</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; :value ,value</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; :accuracy ,accuracy :data ',code&nbsp;</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; :duration ,duration)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*block-transactions*))</div><div class=""><br class=""></div><div class="">(defun process-transfer-request (request stream)</div><div class="">&nbsp; (destructuring-bind (from to value)</div><div class="">&nbsp; &nbsp; &nbsp; request</div><div class="">&nbsp; &nbsp; (transfer from to value)))</div><div class=""><br class=""></div><div class="">(defun process-execute-request (request stream)</div><div class="">&nbsp; &nbsp; (destructuring-bind (from value data &amp;key (accuracy value)&nbsp;</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (duration (+ 2 (block-index (car *blockchain*)))))&nbsp;</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; request</div><div class="">&nbsp; &nbsp; &nbsp; (execute from value data :accuracy accuracy :duration duration)))</div><div class=""><br class=""></div><div class="">(defun process-blocks-request (request stream)</div><div class="">&nbsp; (print *blockchain* stream))</div><div class=""><br class=""></div><div class="">(defun process-coin-server-request (stream)</div><div class="">&nbsp; (let ((request (read stream)))</div><div class="">&nbsp; &nbsp; (case request</div><div class="">&nbsp; &nbsp; &nbsp; (transfer (process-transfer-request (cdr request) stream))</div><div class="">&nbsp; &nbsp; &nbsp; (execute (process-execute-request (cdr request) stream))</div><div class="">&nbsp; &nbsp; &nbsp; (blocks (process-blocks-request (cdr request) stream)))))</div><div class=""><br class=""></div><div class="">(defun coin-server (handle)</div><div class="">&nbsp; (let ((stream (make-instance 'comm:socket-stream</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:socket handle</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:direction :io</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:element-type</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'base-char)))</div><div class="">&nbsp; &nbsp; (process-coin-server-request stream)))</div><div class=""><br class=""></div><div class="">(defvar *server* (comm:start-up-server :function #'coin-server</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:service 9999</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:process-name&nbsp;</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(format nil "~A server" *coin-name*)))</div><div class=""><br class=""></div><div class="">(loop</div><div class="">&nbsp;(mine)</div><div class="">&nbsp;(sleep 1))</div></div><div class=""><br class=""></div><div class="">Enjoy! &nbsp;If you have any questions, feel free to ask.</div><div class=""><br class=""></div><div class="">Made with LispWorks, but it really only uses the function comm:start-up-server I think.</div><div class=""><br class=""></div><div class="">—</div><div class="">Burton Samograd</div><div class="">BusFactor1 Inc.</div><div class=""><a href="http://busfactor1.ca/" class="">http://busfactor1.ca/</a></div><div class=""><br class=""></div><div class="">Check out my software in the macOS App Store.</div></body></html>

               </article>
              </section>
             </div>
            </div>
            <footer class="d-flex justify-content-center">
             <div>
              Updated at: 2020-12-07 08:25 UTC
             </div>
            </footer>
           </body>
          </html>