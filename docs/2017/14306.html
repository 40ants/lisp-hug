<!DOCTYPE html>
<html lang=en>
           <head>
            <meta charset=UTF-8>
            <title>Reactive Programming?</title>
            <meta name=viewport
                  content="width=device-width, initial-scale=1.0">
            <link rel=stylesheet
                  href=https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css
                  integrity=sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2
                  crossorigin=anonymous>
            <style>
section.tree {
    padding-left: 2em;
}
section.tree:first-child {
    padding-left: 0;
}
.article-link {
  margin-bottom: 1em;
}
</style>
<!-- Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-9X3G9MMWZP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-9X3G9MMWZP');
</script>

           </head>
           <body>
            <header class="d-flex justify-content-center">
             <nav
                  class="navbar navbar-light bg-light w-100 mx-5 mb-3">
              <a class=navbar-brand href="/">Lisp HUG Maillist Archive</a>
             </nav>
            </header>
            <div class="d-flex justify-content-center">
             <div class="w-100 mx-5 px-3">
              <section class=tree>
               <article class=email>
                <h1>Reactive Programming?</h1><html><head><meta http-equiv="Content-Type" content="text/html charset=utf-8"></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">I was just sitting down this morning, toying again with the notion of reactive programming. And I suddenly had the realization that, for many (most?) use cases, the complexity of multithreaded implementation, as in my previous versions, was probably unnecessary. In fact the main body could be condensed down to about 40 lines of code, give or take…&nbsp;<div class=""><br class=""></div><div class="">Here it is in one thread, using a priority queue to schedule items of work. The priorities of the queue are unused in the simple use cases shown here. But in something like my GigaDSP platform, where we have multi-rate algorithms wired up, the use of priorities allows for interstitial dispatch - e.g., Runge-Kutta integration which needs 4 sub-steps in each major step. Those sub-steps would be inserted at a higher priority in the queue to place them ahead of the next major processing step.<div class=""><br class=""></div><div class=""><div class=""><div class=""><font face="Menlo" class="">;; -------------------------------------------------------</font></div><div class=""><font face="Menlo" class="">(defpackage #:reactive</font></div><div class=""><font face="Menlo" class="">&nbsp; (:use #:common-lisp)</font></div><div class=""><font face="Menlo" class="">&nbsp; (:export</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp;))</font></div><div class=""><font face="Menlo" class=""><br class=""></font></div><div class=""><font face="Menlo" class="">(in-package #:reactive)</font></div><div class=""><font face="Menlo" class=""><br class=""></font></div><div class=""><font face="Menlo" class="">(defclass reactor-node ()</font></div><div class=""><font face="Menlo" class="">&nbsp; ((subscribers &nbsp;:accessor rn-subs &nbsp;:initform nil)</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp;))</font></div><div class=""><font face="Menlo" class=""><br class=""></font></div><div class=""><font face="Menlo" class="">(defmethod subscribe ((rn reactor-node) fn)</font></div><div class=""><font face="Menlo" class="">&nbsp; (pushnew fn (rn-subs rn)))</font></div><div class=""><font face="Menlo" class=""><br class=""></font></div><div class=""><font face="Menlo" class="">(defmethod unsubscribe ((rn reactor-node) fn)</font></div><div class=""><font face="Menlo" class="">&nbsp; (setf (rn-subs rn) (delete fn (rn-subs rn))))</font></div><div class=""><font face="Menlo" class=""><br class=""></font></div><div class=""><font face="Menlo" class="">(defmethod publish ((rn reactor-node) data &amp;key (level 0))</font></div><div class=""><font face="Menlo" class="">&nbsp; (qappend (mapcar (lambda (fn)</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(lambda ()</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(funcall fn data)))</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(rn-subs rn))</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;level))</font></div><div class=""><font face="Menlo" class=""><br class=""></font></div><div class=""><font face="Menlo" class="">;; -------------------------------------------------------</font></div><div class=""><font face="Menlo" class="">;; The computation engine... single threaded, based on a priority queue</font></div><div class=""><font face="Menlo" class=""><br class=""></font></div><div class=""><font face="Menlo" class="">(defvar *running* nil)</font></div><div class=""><font face="Menlo" class="">(defvar *todo* &nbsp; &nbsp;(maps:empty))</font></div><div class=""><font face="Menlo" class=""><br class=""></font></div><div class=""><font face="Menlo" class="">(defun do-qdo (fn)</font></div><div class=""><font face="Menlo" class="">&nbsp; (funcall fn)</font></div><div class=""><font face="Menlo" class="">&nbsp; (unless *running*</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; (let ((*running* t))</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; (um:nlet-tail iter ()</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; (let ((thunk (qnext)))</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (when thunk</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (ignore-errors (funcall thunk))</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (iter))))</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; )))</font></div><div class=""><font face="Menlo" class=""><br class=""></font></div><div class=""><font face="Menlo" class="">(defmacro qdo (&amp;body body)</font></div><div class=""><font face="Menlo" class="">&nbsp; `(do-qdo (lambda () ,@body)))</font></div><div class=""><font face="Menlo" class=""><br class=""></font></div><div class=""><font face="Menlo" class="">(defun qappend (lst &amp;optional (level 0))</font></div><div class=""><font face="Menlo" class="">&nbsp; (qdo</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp;(let ((q (maps:find level *todo*)))</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp;(setf *todo* (maps:add level (nconc q lst) *todo*)))))</font></div><div class=""><font face="Menlo" class=""><br class=""></font></div><div class=""><font face="Menlo" class="">(defun do-qadd (item &amp;optional (level 0))</font></div><div class=""><font face="Menlo" class="">&nbsp; (qappend (list item) level))</font></div><div class=""><font face="Menlo" class=""><br class=""></font></div><div class=""><font face="Menlo" class="">(defmacro qadd ((&amp;optional (level 0)) &amp;body body)</font></div><div class=""><font face="Menlo" class="">&nbsp; `(do-qadd (lambda () ,@body) ,level))</font></div><div class=""><font face="Menlo" class=""><br class=""></font></div><div class=""><font face="Menlo" class="">(editor:setup-indent "qadd" 1)</font></div><div class=""><font face="Menlo" class=""><br class=""></font></div><div class=""><font face="Menlo" class="">(defun qnext ()</font></div><div class=""><font face="Menlo" class="">&nbsp; (unless (maps:is-empty *todo*)</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; (let* ((ent (sets:max-elt *todo*))</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(key (maps:map-cell-key ent))</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(q &nbsp; (maps:map-cell-val ent))</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(nxt (pop q)))</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; (setf *todo*</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (if q</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (maps:add key q *todo*)</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (sets:remove key *todo*)))</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; nxt)))</font></div><div class=""><font face="Menlo" class=""><br class=""></font></div></div></div><div class=""><font face="Menlo" class="">;; ----------------------------------------------</font></div><div class=""><div class=""><font face="Menlo" class="">;; Simple use cases...</font></div><div class=""><font face="Menlo" class=""><br class=""></font></div><div class=""><font face="Menlo" class="">(defvar *rn* &nbsp;(make-instance 'reactor-node))</font></div><div class=""><font face="Menlo" class=""><br class=""></font></div><div class=""><font face="Menlo" class="">(defun plot-it (data)</font></div><div class=""><font face="Menlo" class="">&nbsp; (typecase data</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; (sequence&nbsp;</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp;(plt:plot 'plt data :clear t))))</font></div><div class=""><font face="Menlo" class=""><br class=""></font></div><div class=""><font face="Menlo" class=""><br class=""></font></div><div class=""><font face="Menlo" class="">(defvar *dbg* (debug-stream:make-debug-stream))</font></div><div class=""><font face="Menlo" class=""><br class=""></font></div><div class=""><font face="Menlo" class="">(defun print-it (data)</font></div><div class=""><font face="Menlo" class="">&nbsp; (debug-stream:pr *dbg* data))</font></div><div class=""><font face="Menlo" class=""><br class=""></font></div><div class=""><font face="Menlo" class=""><br class=""></font></div><div class=""><font face="Menlo" class="">(defun inspect-it (data)</font></div><div class=""><font face="Menlo" class="">&nbsp; (inspect data))</font></div><div class=""><font face="Menlo" class=""><br class=""></font></div><div class=""><font face="Menlo" class=""><br class=""></font></div><div class=""><font face="Menlo" class="">(subscribe *rn* 'plot-it)</font></div><div class=""><font face="Menlo" class="">(subscribe *rn* 'print-it)</font></div><div class=""><font face="Menlo" class="">(subscribe *rn* 'inspect-it)</font></div><div class=""><font face="Menlo" class=""><br class=""></font></div><div class=""><font face="Menlo" class=""><br class=""></font></div><div class=""><font face="Menlo" class="">(publish *rn* (vm:unoise 100 1.0))</font></div><div class=""><font face="Menlo" class="">(publish *rn* (loop for x from 0.0 to 1.57 by 0.05 collect (sin x)))</font></div><div class=""><font face="Menlo" class="">(loop repeat 10 do (publish *rn* (vm:unoise 100 1.0)))</font></div><div class=""><font face="Menlo" class=""><br class=""></font></div><div class=""><font face="Menlo" class=""><br class=""></font></div><div class=""><font face="Menlo" class="">(let ()</font></div><div class=""><font face="Menlo" class="">&nbsp; ;; example of self-extending work items</font></div><div class=""><font face="Menlo" class="">&nbsp; (labels ((doit (lst)</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when lst</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(print (car lst))</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(qadd ()</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(doit (cdr lst))))))</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; (qadd ()</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; (doit '(1 2 3)))</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; ))</font></div></div><div class=""><div class=""><font face="Menlo" class="">;; -------------------------------------------------------</font></div></div><div class=""><br class=""></div><div class="">One of the basic tools I keep coming back to, and used in the above, is an implementation of nearly balanced binary trees for Sets and Maps, and in this case a Map used as a Priority Queue. The code for my balanced binary trees was shamelessly borrowed from the OCaml standard library. The people at INRIA produce some really high quality code.</div><div class=""><br class=""></div><div class="">My initial translation from OCaml to Lisp used bare 4-element Lists as tuples for tree nodes. It was very speedy under optimizations. But the other day, my Cat “Chara” decided to insert a few characters in my code and all hell broke lose on running his implementation.&nbsp;</div><div class=""><br class=""></div><div class="">So I broke down and reimplemented it with CLOS and overt tree-node classes, to disambiguate them from bare Lists. Bare Lists are just too prevalent in Lisp and there are no distinguishing characteristics for them. CLOS allows me to distinguish tree-nodes from Chara’s augmented lists…</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""></div></div></body></html>

               </article>
              </section>
             </div>
            </div>
            <footer class="d-flex justify-content-center">
             <div>
              Updated at: 2020-12-10 08:31 UTC
             </div>
            </footer>
           </body>
          </html>