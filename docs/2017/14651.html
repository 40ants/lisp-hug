<!DOCTYPE html>
<html lang=en>
           <head>
            <meta charset=UTF-8>
            <title>In lisp, what is a module?</title>
            <link rel=stylesheet
                  href=https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css
                  integrity=sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2
                  crossorigin=anonymous>
            <style>
section.tree {
    padding-left: 2em;
}
section.tree:first-child {
    padding-left: 0;
}
.article-link {
  margin-bottom: 1em;
}
</style>
           </head>
           <body>
            <div class="d-flex justify-content-center">
             <nav
                  class="navbar navbar-light bg-light w-100 mx-5 mb-3">
              <a class=navbar-brand href="/">Lisp HUG Maillist Archive</a>
             </nav>
            </div>
            <div class="d-flex justify-content-center">
             <div class="w-100 mx-5 px-3">
              <section class=tree>
               <article class=email>
                <h1>In lisp, what is a module?</h1><html xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:w="urn:schemas-microsoft-com:office:word" xmlns:m="http://schemas.microsoft.com/office/2004/12/omml" xmlns="http://www.w3.org/TR/REC-html40"><head><meta http-equiv=Content-Type content="text/html; charset=us-ascii"><meta name=Generator content="Microsoft Word 15 (filtered medium)"><style><!--
/* Font Definitions */
@font-face
	{font-family:"Cambria Math";
	panose-1:2 4 5 3 5 4 6 3 2 4;}
@font-face
	{font-family:Calibri;
	panose-1:2 15 5 2 2 2 4 3 2 4;}
/* Style Definitions */
p.MsoNormal, li.MsoNormal, div.MsoNormal
	{margin:0in;
	margin-bottom:.0001pt;
	font-size:11.0pt;
	font-family:"Calibri",sans-serif;}
a:link, span.MsoHyperlink
	{mso-style-priority:99;
	color:#0563C1;
	text-decoration:underline;}
a:visited, span.MsoHyperlinkFollowed
	{mso-style-priority:99;
	color:#954F72;
	text-decoration:underline;}
span.EmailStyle17
	{mso-style-type:personal-compose;
	font-family:"Times New Roman",serif;
	color:windowtext;
	font-weight:normal;
	font-style:normal;}
..MsoChpDefault
	{mso-style-type:export-only;}
@page WordSection1
	{size:8.5in 11.0in;
	margin:1.0in 1.0in 1.0in 1.0in;}
div.WordSection1
	{page:WordSection1;}
--></style><!--[if gte mso 9]><xml>
<o:shapedefaults v:ext="edit" spidmax="1026" />
</xml><![endif]--><!--[if gte mso 9]><xml>
<o:shapelayout v:ext="edit">
<o:idmap v:ext="edit" data="1" />
</o:shapelayout></xml><![endif]--></head><body lang=EN-US link="#0563C1" vlink="#954F72"><div class=WordSection1><p class=MsoNormal><span style='font-size:12.0pt;font-family:"Times New Roman",serif'>I read &#8220;Packages, systems, modules, libraries - WTF?&#8221; by Edi Weitz [Prof. Dr. Edmund Weitz] at <a href="http://weitz.de/packages.html">http://weitz.de/packages.html</a> ..<o:p></o:p></span></p><p class=MsoNormal><span style='font-size:12.0pt;font-family:"Times New Roman",serif'><o:p>&nbsp;</o:p></span></p><p class=MsoNormal><span style='font-size:12.0pt;font-family:"Times New Roman",serif'>I will put lisp functions, macros, etc. in {curly braces} because I think some people are communicating in plain text.<o:p></o:p></span></p><p class=MsoNormal><span style='font-size:12.0pt;font-family:"Times New Roman",serif'><o:p>&nbsp;</o:p></span></p><p class=MsoNormal><span style='font-size:12.0pt;font-family:"Times New Roman",serif'>So, that&#8217;s a good article. But now I look at the Lisp function {require}. Seems that {require} is both deprecated and ***<i>recommended***</i> for loading modules. And we have the {*modules*} global variable associated with using {require}.<o:p></o:p></span></p><p class=MsoNormal><span style='font-size:12.0pt;font-family:"Times New Roman",serif'><o:p>&nbsp;</o:p></span></p><p class=MsoNormal><span style='font-size:12.0pt;font-family:"Times New Roman",serif'>I understand that a package can span multiple files. And also the reverse is true that one file can contain multiple packages ({in-package}). So, clearly, packages are not files. A Lisp program pretty much automatically is composed of multiple packages because you generally are going to at least {use-package} {common-lisp}, and {defpackage} your own package or packages. Or, if you don&#8217;t {defpackage} your own package, you are still at least developing in {cl-user} and tacitly {use-package} {common-lisp} so that your lisp code will work. <o:p></o:p></span></p><p class=MsoNormal><span style='font-size:12.0pt;font-family:"Times New Roman",serif'><o:p>&nbsp;</o:p></span></p><p class=MsoNormal><span style='font-size:12.0pt;font-family:"Times New Roman",serif'>You could do something weird like {in-package} to {common-lisp}. Then you are adding your own functions and code to Lisp itself!. Seems like bad practice to me, unless your job is something like developing the next version of LispWorks.<o:p></o:p></span></p><p class=MsoNormal><span style='font-size:12.0pt;font-family:"Times New Roman",serif'><o:p>&nbsp;</o:p></span></p><p class=MsoNormal><span style='font-size:12.0pt;font-family:"Times New Roman",serif'>I understand package as just a namespace of symbol names. Packages allow re-using the same symbol names in different packages. <o:p></o:p></span></p><p class=MsoNormal><span style='font-size:12.0pt;font-family:"Times New Roman",serif'><o:p>&nbsp;</o:p></span></p><p class=MsoNormal><span style='font-size:12.0pt;font-family:"Times New Roman",serif'>I don&#8217;t know. Maybe today&#8217;s Common Lisp mostly doesn&#8217;t talk about or deal with modules and systems with a few glaring exceptions due to historical reasons and tradition? <o:p></o:p></span></p><p class=MsoNormal><span style='font-size:12.0pt;font-family:"Times New Roman",serif'><o:p>&nbsp;</o:p></span></p><p class=MsoNormal><span style='font-size:12.0pt;font-family:"Times New Roman",serif'>I suspect that outside of Lisp, module and system have a different meaning than inside Lisp. In Lisp, is a module always exactly the same as a file? Is a system always exactly the same as a program?<o:p></o:p></span></p><p class=MsoNormal><span style='font-size:12.0pt;font-family:"Times New Roman",serif'><o:p>&nbsp;</o:p></span></p><p class=MsoNormal><span style='font-size:12.0pt;font-family:"Times New Roman",serif'><o:p>&nbsp;</o:p></span></p><p class=MsoNormal><i><span style='font-family:"Times New Roman",serif'>Ron Lewis<o:p></o:p></span></i></p><p class=MsoNormal><span style='font-family:"Times New Roman",serif'>5719 Narcissus Avenue<o:p></o:p></span></p><p class=MsoNormal><span style='font-family:"Times New Roman",serif'>Baltimore, MD 21215-3551<o:p></o:p></span></p><p class=MsoNormal><span style='font-family:"Times New Roman",serif'>Telephone: 443-873-2234<o:p></o:p></span></p><p class=MsoNormal><span style='font-size:12.0pt;font-family:"Times New Roman",serif'><o:p>&nbsp;</o:p></span></p><p class=MsoNormal><span style='font-size:12.0pt;font-family:"Times New Roman",serif'><o:p>&nbsp;</o:p></span></p></div></body></html>

               </article>
               <section class=tree>
                <article class=email>
                 <h1>Re: In lisp, what is a module?</h1><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; line-break: after-white-space;" class=""><br class=""><div><br class=""><blockquote type="cite" class=""><div class="">On 15 Nov 2017, at 02:09, Ron Lewis &lt;<a href="mailto:rlewis-4d@indinfer.com" class="">rlewis-4d@indinfer.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><div class="WordSection1" style="page: WordSection1; font-family: Helvetica; font-size: 14px; font-style: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div style="margin: 0in 0in 0.0001pt; font-size: 11pt; font-family: Calibri, sans-serif;" class=""><span style="font-size: 12pt; font-family: &quot;Times New Roman&quot;, serif;" class="">I read “Packages, systems, modules, libraries - WTF?” by Edi Weitz [Prof. Dr. Edmund Weitz] at<span class="Apple-converted-space">&nbsp;</span><a href="http://weitz.de/packages.html" style="color: rgb(149, 79, 114); text-decoration: underline;" class="">http://weitz.de/packages.html</a><span class="Apple-converted-space">&nbsp;</span>.<o:p class=""></o:p></span></div><div style="margin: 0in 0in 0.0001pt; font-size: 11pt; font-family: Calibri, sans-serif;" class=""><span style="font-size: 12pt; font-family: &quot;Times New Roman&quot;, serif;" class=""><o:p class="">&nbsp;</o:p></span></div><div style="margin: 0in 0in 0.0001pt; font-size: 11pt; font-family: Calibri, sans-serif;" class=""><span style="font-size: 12pt; font-family: &quot;Times New Roman&quot;, serif;" class="">I will put lisp functions, macros, etc. in {curly braces} because I think some people are communicating in plain text.<o:p class=""></o:p></span></div><div style="margin: 0in 0in 0.0001pt; font-size: 11pt; font-family: Calibri, sans-serif;" class=""><span style="font-size: 12pt; font-family: &quot;Times New Roman&quot;, serif;" class=""><o:p class="">&nbsp;</o:p></span></div><div style="margin: 0in 0in 0.0001pt; font-size: 11pt; font-family: Calibri, sans-serif;" class=""><span style="font-size: 12pt; font-family: &quot;Times New Roman&quot;, serif;" class="">So, that’s a good article. But now I look at the Lisp function {require}. Seems that {require} is both deprecated and ***<i class="">recommended***</i><span class="Apple-converted-space">&nbsp;</span>for loading modules. And we have the {*modules*} global variable associated with using {require}.<o:p class=""></o:p></span></div><div style="margin: 0in 0in 0.0001pt; font-size: 11pt; font-family: Calibri, sans-serif;" class=""><span style="font-size: 12pt; font-family: &quot;Times New Roman&quot;, serif;" class=""><o:p class="">&nbsp;</o:p></span></div><div style="margin: 0in 0in 0.0001pt; font-size: 11pt; font-family: Calibri, sans-serif;" class=""><span style="font-size: 12pt; font-family: &quot;Times New Roman&quot;, serif;" class="">I understand that a package can span multiple files. And also the reverse is true that one file can contain multiple packages ({in-package}). So, clearly, packages are not files. A Lisp program pretty much automatically is composed of multiple packages because you generally are going to at least {use-package} {common-lisp}, and {defpackage} your own package or packages. Or, if you don’t {defpackage} your own package, you are still at least developing in {cl-user} and tacitly {use-package} {common-lisp} so that your lisp code will work.<span class="Apple-converted-space">&nbsp;</span><o:p class=""></o:p></span></div><div style="margin: 0in 0in 0.0001pt; font-size: 11pt; font-family: Calibri, sans-serif;" class=""><span style="font-size: 12pt; font-family: &quot;Times New Roman&quot;, serif;" class=""><o:p class="">&nbsp;</o:p></span></div><div style="margin: 0in 0in 0.0001pt; font-size: 11pt; font-family: Calibri, sans-serif;" class=""><span style="font-size: 12pt; font-family: &quot;Times New Roman&quot;, serif;" class="">You could do something weird like {in-package} to {common-lisp}. Then you are adding your own functions and code to Lisp itself!. Seems like bad practice to me, unless your job is something like developing the next version of LispWorks.<o:p class=""></o:p></span></div><div style="margin: 0in 0in 0.0001pt; font-size: 11pt; font-family: Calibri, sans-serif;" class=""><span style="font-size: 12pt; font-family: &quot;Times New Roman&quot;, serif;" class=""><o:p class="">&nbsp;</o:p></span></div><div style="margin: 0in 0in 0.0001pt; font-size: 11pt; font-family: Calibri, sans-serif;" class=""><span style="font-size: 12pt; font-family: &quot;Times New Roman&quot;, serif;" class="">I understand package as just a namespace of symbol names. Packages allow re-using the same symbol names in different packages.<span class="Apple-converted-space">&nbsp;</span><o:p class=""></o:p></span></div><div style="margin: 0in 0in 0.0001pt; font-size: 11pt; font-family: Calibri, sans-serif;" class=""><span style="font-size: 12pt; font-family: &quot;Times New Roman&quot;, serif;" class=""><o:p class="">&nbsp;</o:p></span></div><div style="margin: 0in 0in 0.0001pt; font-size: 11pt; font-family: Calibri, sans-serif;" class=""><span style="font-size: 12pt; font-family: &quot;Times New Roman&quot;, serif;" class="">I don’t know. Maybe today’s Common Lisp mostly doesn’t talk about or deal with modules and systems with a few glaring exceptions due to historical reasons and tradition?<span class="Apple-converted-space">&nbsp;</span><o:p class=""></o:p></span></div><div style="margin: 0in 0in 0.0001pt; font-size: 11pt; font-family: Calibri, sans-serif;" class=""><span style="font-size: 12pt; font-family: &quot;Times New Roman&quot;, serif;" class=""><o:p class="">&nbsp;</o:p></span></div><div style="margin: 0in 0in 0.0001pt; font-size: 11pt; font-family: Calibri, sans-serif;" class=""><span style="font-size: 12pt; font-family: &quot;Times New Roman&quot;, serif;" class="">I suspect that outside of Lisp, module and system have a different meaning than inside Lisp. In Lisp, is a module always exactly the same as a file? Is a system always exactly the same as a program?<o:p class=""></o:p></span></div><div style="margin: 0in 0in 0.0001pt; font-size: 11pt; font-family: Calibri, sans-serif;" class=""><span style="font-size: 12pt; font-family: &quot;Times New Roman&quot;, serif;" class=""><o:p class="">&nbsp;</o:p></span></div></div></div></blockquote><br class=""></div><div>You can assume that system and module are fundamentally the same things; the only difference being that modules are defined in terms of REQUIRE and PROVIDE and listed in the *MODULES* variable.</div><div><br class=""></div><div>On the other hand, systems are implemented using user-level libraries, such as the various versions of defsystem, or nowadays, asdf. &nbsp;quicklisp implements the downloading and installation of asdf systems, so the function ql:quickload may performs the three actions (download, install and load the asdf system).</div><div><br class=""></div><div>Furthermore, some implementations provide hooks into the module system, so that you can map module names to asdf system names, and quickload or asdf load them. &nbsp;I wouldn’t recommend it, but this gives you an integration, letting you use the REQUIRE function to load asdf systems.</div><div><br class=""></div><div>There is a conforming way to use REQUIRE, which is to pass it a second argument which his the pathname of the file to be loaded. &nbsp;It is them equivalent to:</div><div><br class=""></div><div>(defun require (module &amp;optional pathname)</div><div>&nbsp; (if pathname&nbsp;</div><div>&nbsp; &nbsp; &nbsp; (unless (member module *modules*) (load pathname))</div><div>&nbsp; &nbsp; &nbsp; (do-something-implementation-specific module)))</div><div><br class=""></div><div>The loaded module files are responsible to evaluate (provide module) so that the module be added to the *modules* variable.</div><div><br class=""></div><div>The implementation specific module loading thing is not too different, in general the only implementation specific thing is the the locating of the module file.</div><div>But as mentioned above, there may also be hooks. &nbsp;On the other hand, you may also define an asdf system, with a single file containing a REQUIRE form (perhaps conditionalized for various implementations with #+), so that you may load modules using asdf (or quicklisp).</div><div><br class=""></div><div>Now what systems (or modules) are? &nbsp;They may be libraries or programs. &nbsp;There’s not much difference between libraries and programs. &nbsp;In both case, you can call functions from the REPL.</div><div><br class=""></div><div>However, what we would avoid, is to run lengthy processes or start threads at load time. &nbsp;We don’t expect in general that (ql:quickload :some-program) would run the program.</div><div>Instead it is expected to call some function named MAIN or RUN or something else, in some package, after having loaded the system. &nbsp;Or even, to save a lisp image using this function as top-level function to generate an executable.&nbsp;</div><div><br class=""></div><div>We may also make the distinction between libraries and programs on details. &nbsp;But I would rather make that distinction on code distributed thru quicklisp (or other means) vs. code defined by the end-user (or end-developer if you will) that won’t be shared with other developers.</div><div><br class=""></div><div>A library must avoid mutating global common state, such as defining stuff in a package that is not specific to that library (ie. it should avoid short package names that could easily be chosen by other libraries as well), because otherwise other libraries could also mutate the same global common state and it would render them incompatible (eg. if two libraries use a package named “OPTION” to define in it functions, say one package to process command line options, and the other package to process financial options, they could override each other functions and make a very bad mess; my advice is to use package names such as com.informatimago.command-line.option and com.richtrader.tradex.client.option ; perhaps a little longer to type, but no risk of collision: DNS registration already resolved them! &nbsp;(Notice, there are at least 3 systems in quicklisp to process command line options! and at least as many to process JSON! &nbsp;They cannot all be called CL-OPTION or CL-JSON!). &nbsp;This doesn’t concern only package names, there is of course a lot of global state in a lisp image, such as the *READTABLE*, (all the global CL variables with stars around their names). &nbsp;An example is the *features* variable which contains symbols that can be tested with the reader macros #+ and #-. Usually the implementation puts keywords in this list, that you can test easily without writing the colon, since the expression following #+ and #- is read in the KEYWORD package. &nbsp;But if libraries do the same, they may confuse one another. &nbsp;So instead, it is advised in general that system push onto *features* symbols from their very own packages, to avoid any risk of collision. They then have to be tested using the qualified symbol of course.</div><div><br class=""></div><div>As mentioned above, a program would provide a function (or a few functions) to start the program. &nbsp;Eg. a server could provide a start and a stop function. &nbsp;We’re not limited to the “main” function of a C program! ;-)</div><div>Programs, or applications may also easily try to access global resources in an exclusive way (eg. with most GUI, there’s a single application object; a program would naturally create and use this singleton), but this would make it impossible to load and run different programs in the same lisp image! &nbsp;While it is acceptable (it is programs after all), it may be nice if possible to avoid such exclusive use, in programs that are distributed as systems (eg. thru quicklisp). &nbsp;Eg. instead of using the application singleton, design the applications as a “module” that can be integrated with other “modules” in a common application.</div><div><br class=""></div><div>On the other hand, the end-user may write a program using global resources without any difficulty since he won’t be distributing it to other developers. Eg. he may load systems defining packages, and then rename those packages to short names (he will obviously avoid naming conflicts), and then use those short names in his own (end-user) code. &nbsp;He may define an application, using global and exclusive resources such as an application singleton, and integrating into it multiple libraries and programs systems, if they are modular in that way.</div><div><br class=""></div><div>Well, this is my advice, but of course, there are a lot of program or application systems out there that don’t follow this recommendation. You wouldn’t be able to load both hemlock and maxima systems and integrate them easily into a single end-user application. &nbsp;Some heavy patching would be required.</div><div><br class=""></div><div><br class=""></div><div>And a final note to further confuse the terminology, asdf systems are made of components and of modules! &nbsp;But they’re not the same module as CL modules of course, they’re just a way of structuring complex systems. Read the documentation of asdf.</div><div><br class=""></div><div><br class=""></div><div><br class=""></div><div><br class=""></div><br class=""><br class=""><div class="">
<div style="color: rgb(0, 0, 0); letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class=""><div style="color: rgb(0, 0, 0); letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">--&nbsp;<br class="">__Pascal J. Bourguignon__<br class=""><br class=""><br class=""></div></div>

</div>
<br class=""></body></html>

                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: In lisp, what is a module?</h1>
                 <pre>
* Pascal Bourguignon &lt;197C5E20-3244-46F5-ADD5-E4C35392C98B@informatimago.com&gt :
Wrote on Wed, 15 Nov 2017 05:42:40 +0100:

&gt On the other hand, systems are implemented using user-level libraries,
&gt such as the various versions of defsystem, or nowadays, asdf.
&gt quicklisp implements the downloading installation of asdf systems

please remember quicklisp and asdf are not part of common lisp



_______________________________________________
Lisp Hug - the mailing list for LispWorks users
lisp-hug@lispworks.com
http://www.lispworks.com/support/lisp-hug.html

</pre>
                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: In lisp, what is a module?</h1>
                 <pre>On 15 Nov 2017, at 01:09, Ron Lewis &lt;rlewis-4d@indinfer.com&gt wrote:
&gt 
&gt I don’t know. Maybe today’s Common Lisp mostly doesn’t talk about or deal with modules and systems with a few glaring exceptions due to historical reasons and tradition?

That's pretty much right.  Packages are first-class objects in CL which deal with mapping strings to symbols (symbols also being first-class in CL).

CL-as-a-language has only a very limited notion of things which represent units of code which you might want to compile, load or deliver together.  So there is REQUIRE, PROVIDE and *MODULES* but the spec for them is full of 'implementation-dependent': it is possible to use them portably but only in a very limited way.

Historically (well, in the late 1980s through the mid 2000s: I wasn't there before that and wasn't part of the community after that) there was a lot of discussion &amp; argument about various ways of defining such units of code which often had the name DEFSYSTEM, although there were lots of different ones.  I think that this was seen as not-ready-for-standardisation when CL got standardised, and this was right I think (although it would have been nice if there had been some standard way of extending the behaviour of REQUIRE/PROVIDE/*MODULES* perhaps).  Today, as far as I can see that gap has been empirically filled by ASDF for defining systems  and Quicklisp for distributing them.

It's worth mentioning perhaps that there is another, almost completely different, notion of 'module' which exists in parts of the Lisp community, specifically in some (all?) Schemes.  There, a module is a thing (which may or may not be a first-class object) which maps symbols to their meanings.

So in CL you have a situation where

- string -&gt symbol (via package system)
- symbols have function definitions, variable bindings and so on

While in a language with a module system in the Scheme sense you have

- string -&gt symbol (perhaps there is a namespace system to control this)
- symbol -&gt meanings of that symbol (via module system)

So in the context of different modules the *same symbol* means different things.  This is an alien notion to CL, but you may come across it.

--tim

_______________________________________________
Lisp Hug - the mailing list for LispWorks users
lisp-hug@lispworks.com
http://www.lispworks.com/support/lisp-hug.html

</pre>
                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: In lisp, what is a module?</h1>
                 <pre>The ANSI Common Lisp language does not have any concept of "system",
but traditionally this is a synonym for "application". Third-party software
is available for the purpose of organizing your application's files and the
file dependencies. That tool is usually named DEFSYSTEM.
The most popular of these is called ASDF, and many Lisp vendors
include ASDF in their development environments.

With utilities like ASDF, your "system" will have a name.
I like to name mine in a convention like Java packages.
That way I don't worry about name conflicts with any of the many
third-party systems that I am also loading.
Systems don't have any inherent relationship to Packages.
You will define your "system" in terms of files -- which ones to compile
and load in which order.

Files don't mean much to Common Lisp; they don't define systems or
modules or packages or anything. You arbitrarily decide which file(s)
you would like to put your code in, organized however you like.
In particular, files have no inherent bearing on where you define
classes and methods, which are lexically entirely separate from each other.
It is common for a class definition to be in one file, and for some methods
to be in that same file, while many other methods for that class are in 
a different file.

Packages are namespaces for symbols. You can enter any package context
at any time with the IN-PACKAGE operator. Most programmers restrict each
file to contain items from only one package. They put an IN-PACKAGE at the
head of the file where it is easy to see, and they don't have any more 
of thosein the rest of the file. There are usually many files with the 
same IN-PACKAGEat the front of the file.

Package names are arbitrary. There are a few reserved ones like 
COMMON-LISP.
There is CL-USER that you are in by default, a sort of scratch package.
Package names have no meaning or (e.g. hierarchical) structure.
I like to name my packages using Java-like conventions (i.e. domain 
name-based).

Packages can export names, the usual way of defining an API.
Packages can also wholesale import each other, when that makes 
convenient sense.

Modules are a nebulous concept in Lisp. There isn't really any such 
thing as
a module, but at any time the PROVIDE operator may be called to indicate 
that
the named "module" has been loaded. This will be noted in a special global
variable *MODULES*. The corresponding REQUIRE operator requests that if
the named module is not already thus provided, then somehow work will be
done so that it will be. It's implementation dependent. Being non-standard
and too simplistic, the entire *MODULES*/REQUIRE/PROVIDE mechanism
is deprecated. You should just use something else to manage your code.
That is, you should be using some "DEFSYSTEM" utility, probably the ASDF 
one.

Lastly, you should be aware of Quicklisp.
This is a curated repository of Lisp code and a mechanism for automatically
downloading, installing, compiling, and loading it. Super easy to use.
Includes tons of Lisp libraries that you will want.

1. Learn simple things about DEFPACKAGE and IN-PACKAGE.
  (I think you already did.)
2. Learn how to load goodies using Quicklisp.
3. Learn simple things about ASDF/DEFSYSTEM.
4. Put your code into files, declare package(s) in there.
5. Your DEFSYSTEM will contain at first involve just three files.
  (a) A file containing the DEFSYSTEM
  (b) A file containing a DEFPACKAGE
  (c) A file containing your code; the first line of which is IN-PACKAGE
6. Call the ASDF/DEFSYSTEM operator to compile and load your system.

Of course, you'll be messing around incrementally with your code,
maybe even just in the CL-USER package at first, before it is necessary
to bundle it up into a "system" and define your own package.
But I like to have the minimal structure above after I'm about 15
minute into the hacking!

_______________________________________________
Lisp Hug - the mailing list for LispWorks users
lisp-hug@lispworks.com
http://www.lispworks.com/support/lisp-hug.html

</pre>
                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: In lisp, what is a module?</h1>
                 <pre>Dnia 2017-11-14, wto o godzinie 20:09 -0500, Ron Lewis pisze:
&gt Or, if you don’t {defpackage} your own package, you are still at least
&gt developing in {cl-user} and tacitly {use-package} {common-lisp} so
&gt that your lisp code will work. 
&gt 
Be cautious about that.  Developing in cl-user you implicitly 

(use-package cl-user).

The problem, various implementation put different thing there and you
end up with your code being unportable (name conflicts on other
implementations than the original one.  Especially avoid inheriting
from cl-user in your package.

&gt You could do something weird like {in-package} to {common-lisp}. Then
&gt you are adding your own functions and code to Lisp itself!. Seems like
&gt bad practice to me, unless your job is something like developing the
&gt next version of LispWorks.
&gt 
Most implementaions seal the package common-lisp and do not let you to
modify definitions there without explicitly opening the gate.

&gt I don’t know. Maybe today’s Common Lisp mostly doesn’t talk about or
&gt deal with modules and systems with a few glaring exceptions due to
&gt historical reasons and tradition? 
&gt 
People who use them take them for granted, so they have nothing to talk
about (unless someone asks of course).
&gt 
Some people have their own tools tools for them, because it is not very
hard to write such a tool in Common Lisp or to adapt existing one left
from extinct implementations.

Have fun programming in CL

Best regards

Zbyszek Jurkiewicz
University of Warsaw



_______________________________________________
Lisp Hug - the mailing list for LispWorks users
lisp-hug@lispworks.com
http://www.lispworks.com/support/lisp-hug.html

</pre>
                </article>
               </section>
              </section>
             </div>
            </div>
           </body>
          </html>