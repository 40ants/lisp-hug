<!DOCTYPE html>
<html lang=en>
           <head>
            <meta charset=UTF-8>
            <title>Speed of various implementation schemes...</title>
            <link rel=stylesheet
                  href=https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css
                  integrity=sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2
                  crossorigin=anonymous>
            <style>
section.tree {
    padding-left: 2em;
}
section.tree:first-child {
    padding-left: 0;
}
.article-link {
  margin-bottom: 1em;
}
</style>
<!-- Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-9X3G9MMWZP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-9X3G9MMWZP');
</script>

           </head>
           <body>
            <header class="d-flex justify-content-center">
             <nav
                  class="navbar navbar-light bg-light w-100 mx-5 mb-3">
              <a class=navbar-brand href="/">Lisp HUG Maillist Archive</a>
             </nav>
            </header>
            <div class="d-flex justify-content-center">
             <div class="w-100 mx-5 px-3">
              <section class=tree>
               <article class=email>
                <h1>Speed of various implementation schemes...</h1><html><head><meta http-equiv="Content-Type" content="text/html charset=utf-8"></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class=""><div class="">Summary: Using basic STRUCT and direct function calls provides the fastest performing encapsulation of state and behavior. Significantly faster than CLOS, hugely faster than DLAMBDA, and even faster than using vectored function dispatch through a jump vector (!!).</div><div class=""><br class=""></div><div class="">Normalized Timings (2 sig figs, median of 3 meas):</div><div class=""><br class=""></div><div class="">STRUCT<span class="Apple-tab-span" style="white-space:pre">		</span>1.0</div><div class="">Jump Vector<span class="Apple-tab-span" style="white-space:pre">	</span>1.4</div><div class="">JV Dispatch<span class="Apple-tab-span" style="white-space:pre">	</span>2.5</div><div class="">CLOS<span class="Apple-tab-span" style="white-space:pre">		</span>5.0</div><div class="">DLAMBDA<span class="Apple-tab-span" style="white-space:pre">	</span>33</div><div class="">———————</div><div class=""><br class=""></div>From time to time, I make use of Doug Hoyte’s DLAMBDA to make little embedded-intelligence objects that don’t seem to deserve the greater complexity of CLOS. DLAMBDA has the nice trait that it keeps message code adjacent to object state, rather than spreading it all out the way CLOS does. But I’m also a big fan of CLOS - don’t get me wrong.<div class=""><br class=""></div><div class="">But just for curiosity, I wanted to see what the performance overhead on DLAMBDA is. And once I saw that, compared to CLOS, I began looking for what is the fastest possible implementation (apart from coding in Assembly language…). Let’s keep this all in Lisp.</div><div class=""><br class=""></div><div class="">As a simple test, I needed a fast list constructor that could keep items in LIFO order, and provide a fast O(1) append of each additional item as they become available. I initially set this up using internal LABEL functions, and it worked very well. And it also turned out to be useful in several other places. So I decided to package it up for myself and keep the implementation in one place, instead of replicating it all over the place — the usual reason for packaging up state and behavior into objects.</div><div class=""><br class=""></div><div class="">So here is an example of the original code:</div><div class=""><br class=""></div><div class=""><div class=""><div class=""><font face="Monaco" class="">(defun collect-&gt; (pred start until-fn succ-fn</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;key</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(key &nbsp; &nbsp;#'identity)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(map-fn #'identity))</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (do ((x &nbsp; start &nbsp; (funcall succ-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((funcall until-fn x) (get-list))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (when (funcall pred (funcall key x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (append-item (funcall map-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</font></div></div></div><div class=""><br class=""></div><div class="">#F is a reader macro meaning (DECLARE (OPTIMIZE (SPEED 3) (SAFETY 0) (FLOAT 0)).</div><div class=""><br class=""></div><div class="">This code offers an O(1) FIFO list construction, for items from some collection START which satisfy some predicate PRED (using key function KEY), and which collects some mapped representation (MAP-FN) of the qualified items. Pretty simple.</div><div class=""><br class=""></div><div class="">It is that collection of 3 functions inside the LABELS clause that I want to package up. No clients need to know about the internal workings and state of the list constructor object. They just need to be able to instantiate such a constructor, call APPEND-ITEM on each value they want collected, and GET-LIST at the end to get their collected results.&nbsp;</div><div class=""><br class=""></div><div class="">They don’t need to know anything about the CELL, nor the SET-CDR mechanism, which together manages a list by tracking the tail cell of a circular list. The head of the accumulating list is always pointed to by the (CDR CELL). At the end, when they want the result, we need to furnish the head of the accumulated list, and null out the cdr of the last cons cell. Perfect conditions for an encapsulated object implementation.</div><div class=""><br class=""></div><div class="">So here is the first version of encapsulation done with DLAMBDA:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun make-list-builder ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; always in (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (dlambda</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (:append (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (:get ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil)))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</span></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">and here is the corresponding rewrite of COLLECT-&gt;:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun collect-&gt; (pred start until-fn succ-fn</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;key</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(key &nbsp; &nbsp;#'identity)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(map-fn #'identity))</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let ((lb (make-list-builder)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (do ((x &nbsp;start &nbsp;(funcall succ-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ((funcall until-fn x) (funcall lb :get))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (when (funcall pred (funcall key x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (funcall lb :append (funcall map-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div></div><div class=""><br class=""></div><div class="">DLAMBDA is sensitive to the ordering of the message responders, so I placed :APPEND first.</div><div class=""><br class=""></div><div class="">Okay, so now let’s do some timings. I want to measure realistic applications of the list builder, not making lists of hundreds of millions of items, but perhaps a thousand items, done over and over again. To get some realistic durations, we need to execute a few million times. So here is the template of our timing tests:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-dlambda (ngrp) ;; 1 grp = 1000 times of 1000-element lists</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-list-builder)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (funcall lb :append ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (funcall lb :get)))))</font></div><div class=""><br class=""></div></div><div class="">When I execute this bake-off code for 10 groups (10,000,000 conses) I got a median of 3 measurement of 60.38 sec. under LWM 7/64 on a Mac Mini (Late 2014) running OS X Sierra 10.12.3, and nothing much else happening in the machine.</div><div class="">———————————————</div><div class=""><br class=""></div><div class="">So let’s look at a CLOS implementation. Sadly, to me, this takes all that encapsulation and scatters it to the wind.</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defclass list-builder ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ((cell &nbsp;:accessor lb-cell &nbsp;:initform nil)))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defmethod lb-set-cdr ((lb list-builder) x)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lb-cell)) lb</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (setf cell (setf (cdr xcell) x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defmethod lb-append ((lb list-builder) x)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lb-cell)) lb</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (lb-set-cdr lb (cons x (cdr cell)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defmethod lb-get ((lb list-builder))</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lb-cell)) lb</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (lb-set-cdr lb nil))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">Its bake-off code looks like this:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-clos (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-instance 'list-builder)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lb-append lb ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lb-get lb)))))</font></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">And its median of 3 for 100 groups of 1M conses showed a timing of 8.952 sec. Note that this was for 10x as many conses as we used when timing the DLAMBDA implementation. In other words, CLOS is nearly 6x faster than DLAMBA. (That’s close enough for Astronomical accuracy to call it 10x faster).&nbsp;</div><div class=""><br class=""></div><div class="">This is very surprising!! At least to me… and it shows that LW has spent some effort to make CLOS efficient. A tip of the hat to them!</div><div class=""><br class=""></div><div class="">————————</div><div class="">Okay… what’s faster than all this so far? What about a jump vector dispatching to internal LABEL functions?</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun make-list-builder-v ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; always in (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp; (let ((jv (vector #'append-item #'get)))</span></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (lambda (ix &amp;rest args)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (apply (aref jv ix) args))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</font></div><div class=""><br class=""></div></div><div class=""><br class=""></div><div class="">And here is the bake-off code:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defmacro jv (jv ix &amp;rest args)</font></div><div class=""><font face="Monaco" class="">&nbsp; `(funcall ,jv ,ix ,@args))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun bake-off-jv (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-list-builder-v)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv lb 0 ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv lb 1)))))</font></div><div class=""><br class=""></div></div><div class="">Yech!… we need to know that function 0 is the APPEND-ITEM, and function 1 is the GET-LIST. But is it faster?</div><div class=""><br class=""></div><div class="">The median of 3 timings on 100M conses was 4.537s. So yes, it is about 2x faster than CLOS. Unless you have a strong need for speed, stick with CLOS.</div><div class=""><br class=""></div><div class="">—————————————————</div><div class="">Can we do any better than JV? What about skipping the internal dispatch lambda shown above, and just vectoring ourselves through the jump-vector?</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun make-list-builder-v2 ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; always in (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp;(vector #'append-item #'get)</span></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp;)))</font></div></div><div class=""><br class=""></div><div class="">and the bake-off code:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defmacro jv2 (jv ix &amp;rest args)</font></div><div class=""><font face="Monaco" class="">&nbsp; `(funcall (aref ,jv ,ix) ,@args))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun bake-off-jv2 (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-list-builder-v2)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv2 lb 0 ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv2 lb 1)))))</font></div><div class=""><br class=""></div></div><div class=""><br class=""></div><div class="">It’s timing showed a median of 3 of 2.527s. So yes, skipping the lambda dispatch is a speedup. Still…. hmmm….</div><div class="">———————————</div><div class="">Well, just for the heck of it, let’s see where a basic STRUCT implementation falls with CLOS and DLAMBDA…</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defstruct lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; cell)</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun lbs-set-cdr (lbs x)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lbs-cell)) lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><span style="font-family: Monaco;" class="">(defun lbs-append (lbs x)</span></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lbs-cell)) lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (lbs-set-cdr lbs (cons x (cdr cell)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun lbs-get (lbs)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lbs-cell)) lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (lbs-set-cdr lbs nil))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><br class=""></div></div><div class="">and its bake-off code:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-lbs (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lbs (make-lbs)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lbs-append lbs ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lbs-get lbs)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))</font></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">OMG!! It’s timing for 100M conses shows a median of 3 of 1.807s. Not only is this faster than both DLAMBDA and CLOS, but it is even faster than using jump-vectors !!!! What a surprise!</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div></body></html>

               </article>
               <section class=tree>
                <article class=email>
                 <h1>Re: Speed of various implementation schemes...</h1><html><head><meta http-equiv="Content-Type" content="text/html charset=utf-8"></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">ummm… yes, my DLAMBDA timings incorrectly stated that 10 groups took 60+ seconds. It took 6+ seconds for 10 groups, and scaling to 100 groups would have been the stated 60+ seconds. Sorry… End results remain the same, just mis-stated the case.<div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><br class=""></div><div><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 09:09, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class=""><div class="">Summary: Using basic STRUCT and direct function calls provides the fastest performing encapsulation of state and behavior. Significantly faster than CLOS, hugely faster than DLAMBDA, and even faster than using vectored function dispatch through a jump vector (!!).</div><div class=""><br class=""></div><div class="">Normalized Timings (2 sig figs, median of 3 meas):</div><div class=""><br class=""></div><div class="">STRUCT<span class="Apple-tab-span" style="white-space:pre">		</span>1.0</div><div class="">Jump Vector<span class="Apple-tab-span" style="white-space:pre">	</span>1.4</div><div class="">JV Dispatch<span class="Apple-tab-span" style="white-space:pre">	</span>2.5</div><div class="">CLOS<span class="Apple-tab-span" style="white-space:pre">		</span>5.0</div><div class="">DLAMBDA<span class="Apple-tab-span" style="white-space:pre">	</span>33</div><div class="">———————</div><div class=""><br class=""></div>From time to time, I make use of Doug Hoyte’s DLAMBDA to make little embedded-intelligence objects that don’t seem to deserve the greater complexity of CLOS. DLAMBDA has the nice trait that it keeps message code adjacent to object state, rather than spreading it all out the way CLOS does. But I’m also a big fan of CLOS - don’t get me wrong.<div class=""><br class=""></div><div class="">But just for curiosity, I wanted to see what the performance overhead on DLAMBDA is. And once I saw that, compared to CLOS, I began looking for what is the fastest possible implementation (apart from coding in Assembly language…). Let’s keep this all in Lisp.</div><div class=""><br class=""></div><div class="">As a simple test, I needed a fast list constructor that could keep items in LIFO order, and provide a fast O(1) append of each additional item as they become available. I initially set this up using internal LABEL functions, and it worked very well. And it also turned out to be useful in several other places. So I decided to package it up for myself and keep the implementation in one place, instead of replicating it all over the place — the usual reason for packaging up state and behavior into objects.</div><div class=""><br class=""></div><div class="">So here is an example of the original code:</div><div class=""><br class=""></div><div class=""><div class=""><div class=""><font face="Monaco" class="">(defun collect-&gt; (pred start until-fn succ-fn</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;key</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(key &nbsp; &nbsp;#'identity)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(map-fn #'identity))</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (do ((x &nbsp; start &nbsp; (funcall succ-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((funcall until-fn x) (get-list))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (when (funcall pred (funcall key x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (append-item (funcall map-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</font></div></div></div><div class=""><br class=""></div><div class="">#F is a reader macro meaning (DECLARE (OPTIMIZE (SPEED 3) (SAFETY 0) (FLOAT 0)).</div><div class=""><br class=""></div><div class="">This code offers an O(1) FIFO list construction, for items from some collection START which satisfy some predicate PRED (using key function KEY), and which collects some mapped representation (MAP-FN) of the qualified items. Pretty simple.</div><div class=""><br class=""></div><div class="">It is that collection of 3 functions inside the LABELS clause that I want to package up. No clients need to know about the internal workings and state of the list constructor object. They just need to be able to instantiate such a constructor, call APPEND-ITEM on each value they want collected, and GET-LIST at the end to get their collected results.&nbsp;</div><div class=""><br class=""></div><div class="">They don’t need to know anything about the CELL, nor the SET-CDR mechanism, which together manages a list by tracking the tail cell of a circular list. The head of the accumulating list is always pointed to by the (CDR CELL). At the end, when they want the result, we need to furnish the head of the accumulated list, and null out the cdr of the last cons cell. Perfect conditions for an encapsulated object implementation.</div><div class=""><br class=""></div><div class="">So here is the first version of encapsulation done with DLAMBDA:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun make-list-builder ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; always in (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (dlambda</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (:append (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (:get ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil)))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</span></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">and here is the corresponding rewrite of COLLECT-&gt;:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun collect-&gt; (pred start until-fn succ-fn</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;key</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(key &nbsp; &nbsp;#'identity)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(map-fn #'identity))</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let ((lb (make-list-builder)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (do ((x &nbsp;start &nbsp;(funcall succ-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ((funcall until-fn x) (funcall lb :get))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (when (funcall pred (funcall key x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (funcall lb :append (funcall map-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div></div><div class=""><br class=""></div><div class="">DLAMBDA is sensitive to the ordering of the message responders, so I placed :APPEND first.</div><div class=""><br class=""></div><div class="">Okay, so now let’s do some timings. I want to measure realistic applications of the list builder, not making lists of hundreds of millions of items, but perhaps a thousand items, done over and over again. To get some realistic durations, we need to execute a few million times. So here is the template of our timing tests:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-dlambda (ngrp) ;; 1 grp = 1000 times of 1000-element lists</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-list-builder)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (funcall lb :append ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (funcall lb :get)))))</font></div><div class=""><br class=""></div></div><div class="">When I execute this bake-off code for 10 groups (10,000,000 conses) I got a median of 3 measurement of 60.38 sec. under LWM 7/64 on a Mac Mini (Late 2014) running OS X Sierra 10.12.3, and nothing much else happening in the machine.</div><div class="">———————————————</div><div class=""><br class=""></div><div class="">So let’s look at a CLOS implementation. Sadly, to me, this takes all that encapsulation and scatters it to the wind.</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defclass list-builder ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ((cell &nbsp;:accessor lb-cell &nbsp;:initform nil)))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defmethod lb-set-cdr ((lb list-builder) x)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lb-cell)) lb</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (setf cell (setf (cdr xcell) x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defmethod lb-append ((lb list-builder) x)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lb-cell)) lb</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (lb-set-cdr lb (cons x (cdr cell)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defmethod lb-get ((lb list-builder))</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lb-cell)) lb</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (lb-set-cdr lb nil))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">Its bake-off code looks like this:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-clos (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-instance 'list-builder)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lb-append lb ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lb-get lb)))))</font></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">And its median of 3 for 100 groups of 1M conses showed a timing of 8.952 sec. Note that this was for 10x as many conses as we used when timing the DLAMBDA implementation. In other words, CLOS is nearly 6x faster than DLAMBA. (That’s close enough for Astronomical accuracy to call it 10x faster).&nbsp;</div><div class=""><br class=""></div><div class="">This is very surprising!! At least to me… and it shows that LW has spent some effort to make CLOS efficient. A tip of the hat to them!</div><div class=""><br class=""></div><div class="">————————</div><div class="">Okay… what’s faster than all this so far? What about a jump vector dispatching to internal LABEL functions?</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun make-list-builder-v ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; always in (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp; (let ((jv (vector #'append-item #'get)))</span></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (lambda (ix &amp;rest args)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (apply (aref jv ix) args))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</font></div><div class=""><br class=""></div></div><div class=""><br class=""></div><div class="">And here is the bake-off code:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defmacro jv (jv ix &amp;rest args)</font></div><div class=""><font face="Monaco" class="">&nbsp; `(funcall ,jv ,ix ,@args))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun bake-off-jv (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-list-builder-v)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv lb 0 ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv lb 1)))))</font></div><div class=""><br class=""></div></div><div class="">Yech!… we need to know that function 0 is the APPEND-ITEM, and function 1 is the GET-LIST. But is it faster?</div><div class=""><br class=""></div><div class="">The median of 3 timings on 100M conses was 4.537s. So yes, it is about 2x faster than CLOS. Unless you have a strong need for speed, stick with CLOS.</div><div class=""><br class=""></div><div class="">—————————————————</div><div class="">Can we do any better than JV? What about skipping the internal dispatch lambda shown above, and just vectoring ourselves through the jump-vector?</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun make-list-builder-v2 ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; always in (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp;(vector #'append-item #'get)</span></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp;)))</font></div></div><div class=""><br class=""></div><div class="">and the bake-off code:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defmacro jv2 (jv ix &amp;rest args)</font></div><div class=""><font face="Monaco" class="">&nbsp; `(funcall (aref ,jv ,ix) ,@args))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun bake-off-jv2 (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-list-builder-v2)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv2 lb 0 ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv2 lb 1)))))</font></div><div class=""><br class=""></div></div><div class=""><br class=""></div><div class="">It’s timing showed a median of 3 of 2.527s. So yes, skipping the lambda dispatch is a speedup. Still…. hmmm….</div><div class="">———————————</div><div class="">Well, just for the heck of it, let’s see where a basic STRUCT implementation falls with CLOS and DLAMBDA…</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defstruct lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; cell)</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun lbs-set-cdr (lbs x)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lbs-cell)) lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><span style="font-family: Monaco;" class="">(defun lbs-append (lbs x)</span></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lbs-cell)) lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (lbs-set-cdr lbs (cons x (cdr cell)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun lbs-get (lbs)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lbs-cell)) lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (lbs-set-cdr lbs nil))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><br class=""></div></div><div class="">and its bake-off code:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-lbs (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lbs (make-lbs)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lbs-append lbs ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lbs-get lbs)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))</font></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">OMG!! It’s timing for 100M conses shows a median of 3 of 1.807s. Not only is this faster than both DLAMBDA and CLOS, but it is even faster than using jump-vectors !!!! What a surprise!</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div></div></div></blockquote></div><br class=""></body></html>

                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: Speed of various implementation schemes...</h1><html><head><meta http-equiv="Content-Type" content="text/html charset=utf-8"></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">.. and to my shock, and horror!, it actually happens that using the embedded LABELS functions is even worse than using CLOS.<div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-raw (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (time (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (append-item ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (get-list)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">Median of 3 timings for (BAKE-OFF-RAW 100) &nbsp;[ 100M conses ] is 16.432 sec.&nbsp;</div><div class=""><br class=""></div><div class="">I couldn’t believe my eyes. There must be a mistake. I tried the BAKE-OFF-LBS (struct version) again to be sure. It still shows 1.8 sec. Then I tried BAKE-OFF-RAW yet again. Still 16 sec.&nbsp;</div><div class=""><br class=""></div><div class="">What’s going on here?</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 09:29, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">ummm… yes, my DLAMBDA timings incorrectly stated that 10 groups took 60+ seconds. It took 6+ seconds for 10 groups, and scaling to 100 groups would have been the stated 60+ seconds. Sorry… End results remain the same, just mis-stated the case.<div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 09:09, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class=""><div class="">Summary: Using basic STRUCT and direct function calls provides the fastest performing encapsulation of state and behavior. Significantly faster than CLOS, hugely faster than DLAMBDA, and even faster than using vectored function dispatch through a jump vector (!!).</div><div class=""><br class=""></div><div class="">Normalized Timings (2 sig figs, median of 3 meas):</div><div class=""><br class=""></div><div class="">STRUCT<span class="Apple-tab-span" style="white-space:pre">		</span>1.0</div><div class="">Jump Vector<span class="Apple-tab-span" style="white-space:pre">	</span>1.4</div><div class="">JV Dispatch<span class="Apple-tab-span" style="white-space:pre">	</span>2.5</div><div class="">CLOS<span class="Apple-tab-span" style="white-space:pre">		</span>5.0</div><div class="">DLAMBDA<span class="Apple-tab-span" style="white-space:pre">	</span>33</div><div class="">———————</div><div class=""><br class=""></div>From time to time, I make use of Doug Hoyte’s DLAMBDA to make little embedded-intelligence objects that don’t seem to deserve the greater complexity of CLOS. DLAMBDA has the nice trait that it keeps message code adjacent to object state, rather than spreading it all out the way CLOS does. But I’m also a big fan of CLOS - don’t get me wrong.<div class=""><br class=""></div><div class="">But just for curiosity, I wanted to see what the performance overhead on DLAMBDA is. And once I saw that, compared to CLOS, I began looking for what is the fastest possible implementation (apart from coding in Assembly language…). Let’s keep this all in Lisp.</div><div class=""><br class=""></div><div class="">As a simple test, I needed a fast list constructor that could keep items in LIFO order, and provide a fast O(1) append of each additional item as they become available. I initially set this up using internal LABEL functions, and it worked very well. And it also turned out to be useful in several other places. So I decided to package it up for myself and keep the implementation in one place, instead of replicating it all over the place — the usual reason for packaging up state and behavior into objects.</div><div class=""><br class=""></div><div class="">So here is an example of the original code:</div><div class=""><br class=""></div><div class=""><div class=""><div class=""><font face="Monaco" class="">(defun collect-&gt; (pred start until-fn succ-fn</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;key</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(key &nbsp; &nbsp;#'identity)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(map-fn #'identity))</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (do ((x &nbsp; start &nbsp; (funcall succ-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((funcall until-fn x) (get-list))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (when (funcall pred (funcall key x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (append-item (funcall map-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</font></div></div></div><div class=""><br class=""></div><div class="">#F is a reader macro meaning (DECLARE (OPTIMIZE (SPEED 3) (SAFETY 0) (FLOAT 0)).</div><div class=""><br class=""></div><div class="">This code offers an O(1) FIFO list construction, for items from some collection START which satisfy some predicate PRED (using key function KEY), and which collects some mapped representation (MAP-FN) of the qualified items. Pretty simple.</div><div class=""><br class=""></div><div class="">It is that collection of 3 functions inside the LABELS clause that I want to package up. No clients need to know about the internal workings and state of the list constructor object. They just need to be able to instantiate such a constructor, call APPEND-ITEM on each value they want collected, and GET-LIST at the end to get their collected results.&nbsp;</div><div class=""><br class=""></div><div class="">They don’t need to know anything about the CELL, nor the SET-CDR mechanism, which together manages a list by tracking the tail cell of a circular list. The head of the accumulating list is always pointed to by the (CDR CELL). At the end, when they want the result, we need to furnish the head of the accumulated list, and null out the cdr of the last cons cell. Perfect conditions for an encapsulated object implementation.</div><div class=""><br class=""></div><div class="">So here is the first version of encapsulation done with DLAMBDA:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun make-list-builder ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; always in (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (dlambda</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (:append (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (:get ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil)))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</span></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">and here is the corresponding rewrite of COLLECT-&gt;:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun collect-&gt; (pred start until-fn succ-fn</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;key</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(key &nbsp; &nbsp;#'identity)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(map-fn #'identity))</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let ((lb (make-list-builder)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (do ((x &nbsp;start &nbsp;(funcall succ-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ((funcall until-fn x) (funcall lb :get))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (when (funcall pred (funcall key x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (funcall lb :append (funcall map-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div></div><div class=""><br class=""></div><div class="">DLAMBDA is sensitive to the ordering of the message responders, so I placed :APPEND first.</div><div class=""><br class=""></div><div class="">Okay, so now let’s do some timings. I want to measure realistic applications of the list builder, not making lists of hundreds of millions of items, but perhaps a thousand items, done over and over again. To get some realistic durations, we need to execute a few million times. So here is the template of our timing tests:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-dlambda (ngrp) ;; 1 grp = 1000 times of 1000-element lists</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-list-builder)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (funcall lb :append ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (funcall lb :get)))))</font></div><div class=""><br class=""></div></div><div class="">When I execute this bake-off code for 10 groups (10,000,000 conses) I got a median of 3 measurement of 60.38 sec. under LWM 7/64 on a Mac Mini (Late 2014) running OS X Sierra 10.12.3, and nothing much else happening in the machine.</div><div class="">———————————————</div><div class=""><br class=""></div><div class="">So let’s look at a CLOS implementation. Sadly, to me, this takes all that encapsulation and scatters it to the wind.</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defclass list-builder ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ((cell &nbsp;:accessor lb-cell &nbsp;:initform nil)))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defmethod lb-set-cdr ((lb list-builder) x)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lb-cell)) lb</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (setf cell (setf (cdr xcell) x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defmethod lb-append ((lb list-builder) x)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lb-cell)) lb</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (lb-set-cdr lb (cons x (cdr cell)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defmethod lb-get ((lb list-builder))</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lb-cell)) lb</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (lb-set-cdr lb nil))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">Its bake-off code looks like this:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-clos (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-instance 'list-builder)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lb-append lb ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lb-get lb)))))</font></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">And its median of 3 for 100 groups of 1M conses showed a timing of 8.952 sec. Note that this was for 10x as many conses as we used when timing the DLAMBDA implementation. In other words, CLOS is nearly 6x faster than DLAMBA. (That’s close enough for Astronomical accuracy to call it 10x faster).&nbsp;</div><div class=""><br class=""></div><div class="">This is very surprising!! At least to me… and it shows that LW has spent some effort to make CLOS efficient. A tip of the hat to them!</div><div class=""><br class=""></div><div class="">————————</div><div class="">Okay… what’s faster than all this so far? What about a jump vector dispatching to internal LABEL functions?</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun make-list-builder-v ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; always in (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp; (let ((jv (vector #'append-item #'get)))</span></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (lambda (ix &amp;rest args)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (apply (aref jv ix) args))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</font></div><div class=""><br class=""></div></div><div class=""><br class=""></div><div class="">And here is the bake-off code:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defmacro jv (jv ix &amp;rest args)</font></div><div class=""><font face="Monaco" class="">&nbsp; `(funcall ,jv ,ix ,@args))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun bake-off-jv (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-list-builder-v)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv lb 0 ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv lb 1)))))</font></div><div class=""><br class=""></div></div><div class="">Yech!… we need to know that function 0 is the APPEND-ITEM, and function 1 is the GET-LIST. But is it faster?</div><div class=""><br class=""></div><div class="">The median of 3 timings on 100M conses was 4.537s. So yes, it is about 2x faster than CLOS. Unless you have a strong need for speed, stick with CLOS.</div><div class=""><br class=""></div><div class="">—————————————————</div><div class="">Can we do any better than JV? What about skipping the internal dispatch lambda shown above, and just vectoring ourselves through the jump-vector?</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun make-list-builder-v2 ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; always in (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp;(vector #'append-item #'get)</span></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp;)))</font></div></div><div class=""><br class=""></div><div class="">and the bake-off code:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defmacro jv2 (jv ix &amp;rest args)</font></div><div class=""><font face="Monaco" class="">&nbsp; `(funcall (aref ,jv ,ix) ,@args))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun bake-off-jv2 (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-list-builder-v2)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv2 lb 0 ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv2 lb 1)))))</font></div><div class=""><br class=""></div></div><div class=""><br class=""></div><div class="">It’s timing showed a median of 3 of 2.527s. So yes, skipping the lambda dispatch is a speedup. Still…. hmmm….</div><div class="">———————————</div><div class="">Well, just for the heck of it, let’s see where a basic STRUCT implementation falls with CLOS and DLAMBDA…</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defstruct lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; cell)</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun lbs-set-cdr (lbs x)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lbs-cell)) lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><span style="font-family: Monaco;" class="">(defun lbs-append (lbs x)</span></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lbs-cell)) lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (lbs-set-cdr lbs (cons x (cdr cell)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun lbs-get (lbs)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lbs-cell)) lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (lbs-set-cdr lbs nil))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><br class=""></div></div><div class="">and its bake-off code:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-lbs (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lbs (make-lbs)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lbs-append lbs ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lbs-get lbs)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))</font></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">OMG!! It’s timing for 100M conses shows a median of 3 of 1.807s. Not only is this faster than both DLAMBDA and CLOS, but it is even faster than using jump-vectors !!!! What a surprise!</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div></div></div></blockquote></div><br class=""></div></div></blockquote></div><br class=""></div></body></html>

                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: Speed of various implementation schemes...</h1><html><head><meta http-equiv="Content-Type" content="text/html charset=utf-8"></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">Hi David,<div class=""><br class=""></div><div class="">A few minor things:</div><div class=""><br class=""></div><div class="">- The STRUCT implementation is faster because, among other reasons, it doesn’t perform any dispatch anymore. Unlike in CLOS, where lb-get and lb-append could now be implemented for other classes as well, you can’t do the same for your STRUCT implementation. This may not be relevant for your purposes, but still matters in terms of comparing apples to oranges.</div><div class=""><br class=""></div><div class="">For the jump vector versions, you should consider declaring types. simple-vector / svref is potentially faster than aref on an undeclared variable. But more importantly, it can make a difference to tell the compiler that funcall and apply are seeing function objects. In the general case, funcall and apply also work on symbols, so this means that there is usually an implicit test for symbol vs function object. By declaring the type (through (funcall (the function foo) …) or (array function …) and aref lookup) you should be able to squeeze out some additional speed.</div><div class=""><br class=""></div><div class="">Pascal</div><div class=""><br class=""><div><blockquote type="cite" class=""><div class="">On 11 Feb 2017, at 17:09, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class=""><div class="">Summary: Using basic STRUCT and direct function calls provides the fastest performing encapsulation of state and behavior. Significantly faster than CLOS, hugely faster than DLAMBDA, and even faster than using vectored function dispatch through a jump vector (!!).</div><div class=""><br class=""></div><div class="">Normalized Timings (2 sig figs, median of 3 meas):</div><div class=""><br class=""></div><div class="">STRUCT<span class="Apple-tab-span" style="white-space:pre">		</span>1.0</div><div class="">Jump Vector<span class="Apple-tab-span" style="white-space:pre">	</span>1.4</div><div class="">JV Dispatch<span class="Apple-tab-span" style="white-space:pre">	</span>2.5</div><div class="">CLOS<span class="Apple-tab-span" style="white-space:pre">		</span>5.0</div><div class="">DLAMBDA<span class="Apple-tab-span" style="white-space:pre">	</span>33</div><div class="">———————</div><div class=""><br class=""></div>From time to time, I make use of Doug Hoyte’s DLAMBDA to make little embedded-intelligence objects that don’t seem to deserve the greater complexity of CLOS. DLAMBDA has the nice trait that it keeps message code adjacent to object state, rather than spreading it all out the way CLOS does. But I’m also a big fan of CLOS - don’t get me wrong.<div class=""><br class=""></div><div class="">But just for curiosity, I wanted to see what the performance overhead on DLAMBDA is. And once I saw that, compared to CLOS, I began looking for what is the fastest possible implementation (apart from coding in Assembly language…). Let’s keep this all in Lisp.</div><div class=""><br class=""></div><div class="">As a simple test, I needed a fast list constructor that could keep items in LIFO order, and provide a fast O(1) append of each additional item as they become available. I initially set this up using internal LABEL functions, and it worked very well. And it also turned out to be useful in several other places. So I decided to package it up for myself and keep the implementation in one place, instead of replicating it all over the place — the usual reason for packaging up state and behavior into objects.</div><div class=""><br class=""></div><div class="">So here is an example of the original code:</div><div class=""><br class=""></div><div class=""><div class=""><div class=""><font face="Monaco" class="">(defun collect-&gt; (pred start until-fn succ-fn</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;key</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(key &nbsp; &nbsp;#'identity)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(map-fn #'identity))</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (do ((x &nbsp; start &nbsp; (funcall succ-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((funcall until-fn x) (get-list))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (when (funcall pred (funcall key x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (append-item (funcall map-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</font></div></div></div><div class=""><br class=""></div><div class="">#F is a reader macro meaning (DECLARE (OPTIMIZE (SPEED 3) (SAFETY 0) (FLOAT 0)).</div><div class=""><br class=""></div><div class="">This code offers an O(1) FIFO list construction, for items from some collection START which satisfy some predicate PRED (using key function KEY), and which collects some mapped representation (MAP-FN) of the qualified items. Pretty simple.</div><div class=""><br class=""></div><div class="">It is that collection of 3 functions inside the LABELS clause that I want to package up. No clients need to know about the internal workings and state of the list constructor object. They just need to be able to instantiate such a constructor, call APPEND-ITEM on each value they want collected, and GET-LIST at the end to get their collected results.&nbsp;</div><div class=""><br class=""></div><div class="">They don’t need to know anything about the CELL, nor the SET-CDR mechanism, which together manages a list by tracking the tail cell of a circular list. The head of the accumulating list is always pointed to by the (CDR CELL). At the end, when they want the result, we need to furnish the head of the accumulated list, and null out the cdr of the last cons cell. Perfect conditions for an encapsulated object implementation.</div><div class=""><br class=""></div><div class="">So here is the first version of encapsulation done with DLAMBDA:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun make-list-builder ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; always in (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (dlambda</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (:append (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (:get ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil)))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</span></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">and here is the corresponding rewrite of COLLECT-&gt;:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun collect-&gt; (pred start until-fn succ-fn</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;key</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(key &nbsp; &nbsp;#'identity)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(map-fn #'identity))</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let ((lb (make-list-builder)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (do ((x &nbsp;start &nbsp;(funcall succ-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ((funcall until-fn x) (funcall lb :get))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (when (funcall pred (funcall key x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (funcall lb :append (funcall map-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div></div><div class=""><br class=""></div><div class="">DLAMBDA is sensitive to the ordering of the message responders, so I placed :APPEND first.</div><div class=""><br class=""></div><div class="">Okay, so now let’s do some timings. I want to measure realistic applications of the list builder, not making lists of hundreds of millions of items, but perhaps a thousand items, done over and over again. To get some realistic durations, we need to execute a few million times. So here is the template of our timing tests:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-dlambda (ngrp) ;; 1 grp = 1000 times of 1000-element lists</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-list-builder)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (funcall lb :append ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (funcall lb :get)))))</font></div><div class=""><br class=""></div></div><div class="">When I execute this bake-off code for 10 groups (10,000,000 conses) I got a median of 3 measurement of 60.38 sec. under LWM 7/64 on a Mac Mini (Late 2014) running OS X Sierra 10.12.3, and nothing much else happening in the machine.</div><div class="">———————————————</div><div class=""><br class=""></div><div class="">So let’s look at a CLOS implementation. Sadly, to me, this takes all that encapsulation and scatters it to the wind.</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defclass list-builder ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ((cell &nbsp;:accessor lb-cell &nbsp;:initform nil)))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defmethod lb-set-cdr ((lb list-builder) x)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lb-cell)) lb</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (setf cell (setf (cdr xcell) x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defmethod lb-append ((lb list-builder) x)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lb-cell)) lb</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (lb-set-cdr lb (cons x (cdr cell)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defmethod lb-get ((lb list-builder))</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lb-cell)) lb</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (lb-set-cdr lb nil))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">Its bake-off code looks like this:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-clos (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-instance 'list-builder)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lb-append lb ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lb-get lb)))))</font></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">And its median of 3 for 100 groups of 1M conses showed a timing of 8.952 sec. Note that this was for 10x as many conses as we used when timing the DLAMBDA implementation. In other words, CLOS is nearly 6x faster than DLAMBA. (That’s close enough for Astronomical accuracy to call it 10x faster).&nbsp;</div><div class=""><br class=""></div><div class="">This is very surprising!! At least to me… and it shows that LW has spent some effort to make CLOS efficient. A tip of the hat to them!</div><div class=""><br class=""></div><div class="">————————</div><div class="">Okay… what’s faster than all this so far? What about a jump vector dispatching to internal LABEL functions?</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun make-list-builder-v ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; always in (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp; (let ((jv (vector #'append-item #'get)))</span></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (lambda (ix &amp;rest args)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (apply (aref jv ix) args))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</font></div><div class=""><br class=""></div></div><div class=""><br class=""></div><div class="">And here is the bake-off code:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defmacro jv (jv ix &amp;rest args)</font></div><div class=""><font face="Monaco" class="">&nbsp; `(funcall ,jv ,ix ,@args))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun bake-off-jv (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-list-builder-v)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv lb 0 ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv lb 1)))))</font></div><div class=""><br class=""></div></div><div class="">Yech!… we need to know that function 0 is the APPEND-ITEM, and function 1 is the GET-LIST. But is it faster?</div><div class=""><br class=""></div><div class="">The median of 3 timings on 100M conses was 4.537s. So yes, it is about 2x faster than CLOS. Unless you have a strong need for speed, stick with CLOS.</div><div class=""><br class=""></div><div class="">—————————————————</div><div class="">Can we do any better than JV? What about skipping the internal dispatch lambda shown above, and just vectoring ourselves through the jump-vector?</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun make-list-builder-v2 ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; always in (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp;(vector #'append-item #'get)</span></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp;)))</font></div></div><div class=""><br class=""></div><div class="">and the bake-off code:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defmacro jv2 (jv ix &amp;rest args)</font></div><div class=""><font face="Monaco" class="">&nbsp; `(funcall (aref ,jv ,ix) ,@args))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun bake-off-jv2 (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-list-builder-v2)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv2 lb 0 ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv2 lb 1)))))</font></div><div class=""><br class=""></div></div><div class=""><br class=""></div><div class="">It’s timing showed a median of 3 of 2.527s. So yes, skipping the lambda dispatch is a speedup. Still…. hmmm….</div><div class="">———————————</div><div class="">Well, just for the heck of it, let’s see where a basic STRUCT implementation falls with CLOS and DLAMBDA…</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defstruct lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; cell)</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun lbs-set-cdr (lbs x)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lbs-cell)) lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><span style="font-family: Monaco;" class="">(defun lbs-append (lbs x)</span></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lbs-cell)) lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (lbs-set-cdr lbs (cons x (cdr cell)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun lbs-get (lbs)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lbs-cell)) lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (lbs-set-cdr lbs nil))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><br class=""></div></div><div class="">and its bake-off code:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-lbs (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lbs (make-lbs)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lbs-append lbs ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lbs-get lbs)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))</font></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">OMG!! It’s timing for 100M conses shows a median of 3 of 1.807s. Not only is this faster than both DLAMBDA and CLOS, but it is even faster than using jump-vectors !!!! What a surprise!</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div></div></div></blockquote></div><br class=""><div class="">
<div class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class="">--</span><br style="font-family: Menlo-Regular; font-size: 11px;" class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class="">Pascal Costanza</span><br style="font-family: Menlo-Regular; font-size: 11px;" class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class="">The views expressed in this email are my own, and not those of my employer.</span></div><div class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class=""><br class=""></span></div><br class="Apple-interchange-newline">

</div>



<br class=""></div></body></html>

                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: Speed of various implementation schemes...</h1><html><head><meta http-equiv="Content-Type" content="text/html charset=utf-8"></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">Did you try to declare the functions inline?<div class=""><br class=""></div><div class="">Pascal</div><div class=""><br class=""><div><blockquote type="cite" class=""><div class="">On 11 Feb 2017, at 17:42, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">.. and to my shock, and horror!, it actually happens that using the embedded LABELS functions is even worse than using CLOS.<div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-raw (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (time (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (append-item ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (get-list)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">Median of 3 timings for (BAKE-OFF-RAW 100) &nbsp;[ 100M conses ] is 16.432 sec.&nbsp;</div><div class=""><br class=""></div><div class="">I couldn’t believe my eyes. There must be a mistake. I tried the BAKE-OFF-LBS (struct version) again to be sure. It still shows 1.8 sec. Then I tried BAKE-OFF-RAW yet again. Still 16 sec.&nbsp;</div><div class=""><br class=""></div><div class="">What’s going on here?</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 09:29, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">ummm… yes, my DLAMBDA timings incorrectly stated that 10 groups took 60+ seconds. It took 6+ seconds for 10 groups, and scaling to 100 groups would have been the stated 60+ seconds. Sorry… End results remain the same, just mis-stated the case.<div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 09:09, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class=""><div class="">Summary: Using basic STRUCT and direct function calls provides the fastest performing encapsulation of state and behavior. Significantly faster than CLOS, hugely faster than DLAMBDA, and even faster than using vectored function dispatch through a jump vector (!!).</div><div class=""><br class=""></div><div class="">Normalized Timings (2 sig figs, median of 3 meas):</div><div class=""><br class=""></div><div class="">STRUCT<span class="Apple-tab-span" style="white-space:pre">		</span>1.0</div><div class="">Jump Vector<span class="Apple-tab-span" style="white-space:pre">	</span>1.4</div><div class="">JV Dispatch<span class="Apple-tab-span" style="white-space:pre">	</span>2.5</div><div class="">CLOS<span class="Apple-tab-span" style="white-space:pre">		</span>5.0</div><div class="">DLAMBDA<span class="Apple-tab-span" style="white-space:pre">	</span>33</div><div class="">———————</div><div class=""><br class=""></div>From time to time, I make use of Doug Hoyte’s DLAMBDA to make little embedded-intelligence objects that don’t seem to deserve the greater complexity of CLOS. DLAMBDA has the nice trait that it keeps message code adjacent to object state, rather than spreading it all out the way CLOS does. But I’m also a big fan of CLOS - don’t get me wrong.<div class=""><br class=""></div><div class="">But just for curiosity, I wanted to see what the performance overhead on DLAMBDA is. And once I saw that, compared to CLOS, I began looking for what is the fastest possible implementation (apart from coding in Assembly language…). Let’s keep this all in Lisp.</div><div class=""><br class=""></div><div class="">As a simple test, I needed a fast list constructor that could keep items in LIFO order, and provide a fast O(1) append of each additional item as they become available. I initially set this up using internal LABEL functions, and it worked very well. And it also turned out to be useful in several other places. So I decided to package it up for myself and keep the implementation in one place, instead of replicating it all over the place — the usual reason for packaging up state and behavior into objects.</div><div class=""><br class=""></div><div class="">So here is an example of the original code:</div><div class=""><br class=""></div><div class=""><div class=""><div class=""><font face="Monaco" class="">(defun collect-&gt; (pred start until-fn succ-fn</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;key</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(key &nbsp; &nbsp;#'identity)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(map-fn #'identity))</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (do ((x &nbsp; start &nbsp; (funcall succ-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((funcall until-fn x) (get-list))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (when (funcall pred (funcall key x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (append-item (funcall map-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</font></div></div></div><div class=""><br class=""></div><div class="">#F is a reader macro meaning (DECLARE (OPTIMIZE (SPEED 3) (SAFETY 0) (FLOAT 0)).</div><div class=""><br class=""></div><div class="">This code offers an O(1) FIFO list construction, for items from some collection START which satisfy some predicate PRED (using key function KEY), and which collects some mapped representation (MAP-FN) of the qualified items. Pretty simple.</div><div class=""><br class=""></div><div class="">It is that collection of 3 functions inside the LABELS clause that I want to package up. No clients need to know about the internal workings and state of the list constructor object. They just need to be able to instantiate such a constructor, call APPEND-ITEM on each value they want collected, and GET-LIST at the end to get their collected results.&nbsp;</div><div class=""><br class=""></div><div class="">They don’t need to know anything about the CELL, nor the SET-CDR mechanism, which together manages a list by tracking the tail cell of a circular list. The head of the accumulating list is always pointed to by the (CDR CELL). At the end, when they want the result, we need to furnish the head of the accumulated list, and null out the cdr of the last cons cell. Perfect conditions for an encapsulated object implementation.</div><div class=""><br class=""></div><div class="">So here is the first version of encapsulation done with DLAMBDA:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun make-list-builder ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; always in (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (dlambda</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (:append (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (:get ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil)))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</span></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">and here is the corresponding rewrite of COLLECT-&gt;:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun collect-&gt; (pred start until-fn succ-fn</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;key</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(key &nbsp; &nbsp;#'identity)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(map-fn #'identity))</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let ((lb (make-list-builder)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (do ((x &nbsp;start &nbsp;(funcall succ-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ((funcall until-fn x) (funcall lb :get))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (when (funcall pred (funcall key x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (funcall lb :append (funcall map-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div></div><div class=""><br class=""></div><div class="">DLAMBDA is sensitive to the ordering of the message responders, so I placed :APPEND first.</div><div class=""><br class=""></div><div class="">Okay, so now let’s do some timings. I want to measure realistic applications of the list builder, not making lists of hundreds of millions of items, but perhaps a thousand items, done over and over again. To get some realistic durations, we need to execute a few million times. So here is the template of our timing tests:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-dlambda (ngrp) ;; 1 grp = 1000 times of 1000-element lists</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-list-builder)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (funcall lb :append ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (funcall lb :get)))))</font></div><div class=""><br class=""></div></div><div class="">When I execute this bake-off code for 10 groups (10,000,000 conses) I got a median of 3 measurement of 60.38 sec. under LWM 7/64 on a Mac Mini (Late 2014) running OS X Sierra 10.12.3, and nothing much else happening in the machine.</div><div class="">———————————————</div><div class=""><br class=""></div><div class="">So let’s look at a CLOS implementation. Sadly, to me, this takes all that encapsulation and scatters it to the wind.</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defclass list-builder ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ((cell &nbsp;:accessor lb-cell &nbsp;:initform nil)))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defmethod lb-set-cdr ((lb list-builder) x)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lb-cell)) lb</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (setf cell (setf (cdr xcell) x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defmethod lb-append ((lb list-builder) x)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lb-cell)) lb</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (lb-set-cdr lb (cons x (cdr cell)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defmethod lb-get ((lb list-builder))</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lb-cell)) lb</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (lb-set-cdr lb nil))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">Its bake-off code looks like this:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-clos (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-instance 'list-builder)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lb-append lb ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lb-get lb)))))</font></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">And its median of 3 for 100 groups of 1M conses showed a timing of 8.952 sec. Note that this was for 10x as many conses as we used when timing the DLAMBDA implementation. In other words, CLOS is nearly 6x faster than DLAMBA. (That’s close enough for Astronomical accuracy to call it 10x faster).&nbsp;</div><div class=""><br class=""></div><div class="">This is very surprising!! At least to me… and it shows that LW has spent some effort to make CLOS efficient. A tip of the hat to them!</div><div class=""><br class=""></div><div class="">————————</div><div class="">Okay… what’s faster than all this so far? What about a jump vector dispatching to internal LABEL functions?</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun make-list-builder-v ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; always in (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp; (let ((jv (vector #'append-item #'get)))</span></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (lambda (ix &amp;rest args)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (apply (aref jv ix) args))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</font></div><div class=""><br class=""></div></div><div class=""><br class=""></div><div class="">And here is the bake-off code:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defmacro jv (jv ix &amp;rest args)</font></div><div class=""><font face="Monaco" class="">&nbsp; `(funcall ,jv ,ix ,@args))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun bake-off-jv (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-list-builder-v)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv lb 0 ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv lb 1)))))</font></div><div class=""><br class=""></div></div><div class="">Yech!… we need to know that function 0 is the APPEND-ITEM, and function 1 is the GET-LIST. But is it faster?</div><div class=""><br class=""></div><div class="">The median of 3 timings on 100M conses was 4.537s. So yes, it is about 2x faster than CLOS. Unless you have a strong need for speed, stick with CLOS.</div><div class=""><br class=""></div><div class="">—————————————————</div><div class="">Can we do any better than JV? What about skipping the internal dispatch lambda shown above, and just vectoring ourselves through the jump-vector?</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun make-list-builder-v2 ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; always in (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp;(vector #'append-item #'get)</span></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp;)))</font></div></div><div class=""><br class=""></div><div class="">and the bake-off code:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defmacro jv2 (jv ix &amp;rest args)</font></div><div class=""><font face="Monaco" class="">&nbsp; `(funcall (aref ,jv ,ix) ,@args))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun bake-off-jv2 (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-list-builder-v2)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv2 lb 0 ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv2 lb 1)))))</font></div><div class=""><br class=""></div></div><div class=""><br class=""></div><div class="">It’s timing showed a median of 3 of 2.527s. So yes, skipping the lambda dispatch is a speedup. Still…. hmmm….</div><div class="">———————————</div><div class="">Well, just for the heck of it, let’s see where a basic STRUCT implementation falls with CLOS and DLAMBDA…</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defstruct lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; cell)</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun lbs-set-cdr (lbs x)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lbs-cell)) lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><span style="font-family: Monaco;" class="">(defun lbs-append (lbs x)</span></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lbs-cell)) lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (lbs-set-cdr lbs (cons x (cdr cell)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun lbs-get (lbs)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lbs-cell)) lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (lbs-set-cdr lbs nil))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><br class=""></div></div><div class="">and its bake-off code:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-lbs (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lbs (make-lbs)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lbs-append lbs ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lbs-get lbs)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))</font></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">OMG!! It’s timing for 100M conses shows a median of 3 of 1.807s. Not only is this faster than both DLAMBDA and CLOS, but it is even faster than using jump-vectors !!!! What a surprise!</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div></div></div></blockquote></div><br class=""></div></div></blockquote></div><br class=""></div></div></div></blockquote></div><br class=""><div class="">
<div class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class="">--</span><br style="font-family: Menlo-Regular; font-size: 11px;" class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class="">Pascal Costanza</span><br style="font-family: Menlo-Regular; font-size: 11px;" class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class="">The views expressed in this email are my own, and not those of my employer.</span></div><div class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class=""><br class=""></span></div><br class="Apple-interchange-newline">

</div>


<br class=""></div></body></html>

                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: Speed of various implementation schemes...</h1><html><head><meta http-equiv="Content-Type" content="text/html charset=utf-8"></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">Hi Pascal,<div class=""><br class=""></div><div class="">Excellent points, all! Yes, we forego the possibility to generalize when we use the STRUCT implementation. And no, I had not tried declaring anything INLINE yet.&nbsp;</div><div class=""><br class=""></div><div class="">As for using Jump Vectors… I consider that an Assembly language technique, and move in direct contradiction to the abstractions offered by symbolic programming in Lisp. That takes me backward by more than 40 years, and I really have no desire to go there again. I just offered it up as a possible fast implementation. But I wouldn’t be caught dead ever doing that in the raw. I’d have to wrap everything about JV’s with some macrology, at the very least.</div><div class=""><br class=""></div><div class="">Thanks for your insightful comments!</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><br class=""><div><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 09:46, Pascal Costanza &lt;<a href="mailto:pc@p-cos.net" class="">pc@p-cos.net</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">Hi David,<div class=""><br class=""></div><div class="">A few minor things:</div><div class=""><br class=""></div><div class="">- The STRUCT implementation is faster because, among other reasons, it doesn’t perform any dispatch anymore. Unlike in CLOS, where lb-get and lb-append could now be implemented for other classes as well, you can’t do the same for your STRUCT implementation. This may not be relevant for your purposes, but still matters in terms of comparing apples to oranges.</div><div class=""><br class=""></div><div class="">For the jump vector versions, you should consider declaring types. simple-vector / svref is potentially faster than aref on an undeclared variable. But more importantly, it can make a difference to tell the compiler that funcall and apply are seeing function objects. In the general case, funcall and apply also work on symbols, so this means that there is usually an implicit test for symbol vs function object. By declaring the type (through (funcall (the function foo) …) or (array function …) and aref lookup) you should be able to squeeze out some additional speed.</div><div class=""><br class=""></div><div class="">Pascal</div><div class=""><br class=""><div class=""><blockquote type="cite" class=""><div class="">On 11 Feb 2017, at 17:09, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class=""><div class="">Summary: Using basic STRUCT and direct function calls provides the fastest performing encapsulation of state and behavior. Significantly faster than CLOS, hugely faster than DLAMBDA, and even faster than using vectored function dispatch through a jump vector (!!).</div><div class=""><br class=""></div><div class="">Normalized Timings (2 sig figs, median of 3 meas):</div><div class=""><br class=""></div><div class="">STRUCT<span class="Apple-tab-span" style="white-space:pre">		</span>1.0</div><div class="">Jump Vector<span class="Apple-tab-span" style="white-space:pre">	</span>1.4</div><div class="">JV Dispatch<span class="Apple-tab-span" style="white-space:pre">	</span>2.5</div><div class="">CLOS<span class="Apple-tab-span" style="white-space:pre">		</span>5.0</div><div class="">DLAMBDA<span class="Apple-tab-span" style="white-space:pre">	</span>33</div><div class="">———————</div><div class=""><br class=""></div>From time to time, I make use of Doug Hoyte’s DLAMBDA to make little embedded-intelligence objects that don’t seem to deserve the greater complexity of CLOS. DLAMBDA has the nice trait that it keeps message code adjacent to object state, rather than spreading it all out the way CLOS does. But I’m also a big fan of CLOS - don’t get me wrong.<div class=""><br class=""></div><div class="">But just for curiosity, I wanted to see what the performance overhead on DLAMBDA is. And once I saw that, compared to CLOS, I began looking for what is the fastest possible implementation (apart from coding in Assembly language…). Let’s keep this all in Lisp.</div><div class=""><br class=""></div><div class="">As a simple test, I needed a fast list constructor that could keep items in LIFO order, and provide a fast O(1) append of each additional item as they become available. I initially set this up using internal LABEL functions, and it worked very well. And it also turned out to be useful in several other places. So I decided to package it up for myself and keep the implementation in one place, instead of replicating it all over the place — the usual reason for packaging up state and behavior into objects.</div><div class=""><br class=""></div><div class="">So here is an example of the original code:</div><div class=""><br class=""></div><div class=""><div class=""><div class=""><font face="Monaco" class="">(defun collect-&gt; (pred start until-fn succ-fn</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;key</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(key &nbsp; &nbsp;#'identity)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(map-fn #'identity))</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (do ((x &nbsp; start &nbsp; (funcall succ-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((funcall until-fn x) (get-list))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (when (funcall pred (funcall key x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (append-item (funcall map-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</font></div></div></div><div class=""><br class=""></div><div class="">#F is a reader macro meaning (DECLARE (OPTIMIZE (SPEED 3) (SAFETY 0) (FLOAT 0)).</div><div class=""><br class=""></div><div class="">This code offers an O(1) FIFO list construction, for items from some collection START which satisfy some predicate PRED (using key function KEY), and which collects some mapped representation (MAP-FN) of the qualified items. Pretty simple.</div><div class=""><br class=""></div><div class="">It is that collection of 3 functions inside the LABELS clause that I want to package up. No clients need to know about the internal workings and state of the list constructor object. They just need to be able to instantiate such a constructor, call APPEND-ITEM on each value they want collected, and GET-LIST at the end to get their collected results.&nbsp;</div><div class=""><br class=""></div><div class="">They don’t need to know anything about the CELL, nor the SET-CDR mechanism, which together manages a list by tracking the tail cell of a circular list. The head of the accumulating list is always pointed to by the (CDR CELL). At the end, when they want the result, we need to furnish the head of the accumulated list, and null out the cdr of the last cons cell. Perfect conditions for an encapsulated object implementation.</div><div class=""><br class=""></div><div class="">So here is the first version of encapsulation done with DLAMBDA:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun make-list-builder ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; always in (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (dlambda</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (:append (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (:get ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil)))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</span></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">and here is the corresponding rewrite of COLLECT-&gt;:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun collect-&gt; (pred start until-fn succ-fn</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;key</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(key &nbsp; &nbsp;#'identity)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(map-fn #'identity))</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let ((lb (make-list-builder)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (do ((x &nbsp;start &nbsp;(funcall succ-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ((funcall until-fn x) (funcall lb :get))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (when (funcall pred (funcall key x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (funcall lb :append (funcall map-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div></div><div class=""><br class=""></div><div class="">DLAMBDA is sensitive to the ordering of the message responders, so I placed :APPEND first.</div><div class=""><br class=""></div><div class="">Okay, so now let’s do some timings. I want to measure realistic applications of the list builder, not making lists of hundreds of millions of items, but perhaps a thousand items, done over and over again. To get some realistic durations, we need to execute a few million times. So here is the template of our timing tests:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-dlambda (ngrp) ;; 1 grp = 1000 times of 1000-element lists</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-list-builder)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (funcall lb :append ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (funcall lb :get)))))</font></div><div class=""><br class=""></div></div><div class="">When I execute this bake-off code for 10 groups (10,000,000 conses) I got a median of 3 measurement of 60.38 sec. under LWM 7/64 on a Mac Mini (Late 2014) running OS X Sierra 10.12.3, and nothing much else happening in the machine.</div><div class="">———————————————</div><div class=""><br class=""></div><div class="">So let’s look at a CLOS implementation. Sadly, to me, this takes all that encapsulation and scatters it to the wind.</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defclass list-builder ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ((cell &nbsp;:accessor lb-cell &nbsp;:initform nil)))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defmethod lb-set-cdr ((lb list-builder) x)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lb-cell)) lb</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (setf cell (setf (cdr xcell) x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defmethod lb-append ((lb list-builder) x)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lb-cell)) lb</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (lb-set-cdr lb (cons x (cdr cell)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defmethod lb-get ((lb list-builder))</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lb-cell)) lb</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (lb-set-cdr lb nil))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">Its bake-off code looks like this:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-clos (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-instance 'list-builder)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lb-append lb ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lb-get lb)))))</font></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">And its median of 3 for 100 groups of 1M conses showed a timing of 8.952 sec. Note that this was for 10x as many conses as we used when timing the DLAMBDA implementation. In other words, CLOS is nearly 6x faster than DLAMBA. (That’s close enough for Astronomical accuracy to call it 10x faster).&nbsp;</div><div class=""><br class=""></div><div class="">This is very surprising!! At least to me… and it shows that LW has spent some effort to make CLOS efficient. A tip of the hat to them!</div><div class=""><br class=""></div><div class="">————————</div><div class="">Okay… what’s faster than all this so far? What about a jump vector dispatching to internal LABEL functions?</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun make-list-builder-v ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; always in (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp; (let ((jv (vector #'append-item #'get)))</span></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (lambda (ix &amp;rest args)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (apply (aref jv ix) args))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</font></div><div class=""><br class=""></div></div><div class=""><br class=""></div><div class="">And here is the bake-off code:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defmacro jv (jv ix &amp;rest args)</font></div><div class=""><font face="Monaco" class="">&nbsp; `(funcall ,jv ,ix ,@args))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun bake-off-jv (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-list-builder-v)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv lb 0 ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv lb 1)))))</font></div><div class=""><br class=""></div></div><div class="">Yech!… we need to know that function 0 is the APPEND-ITEM, and function 1 is the GET-LIST. But is it faster?</div><div class=""><br class=""></div><div class="">The median of 3 timings on 100M conses was 4.537s. So yes, it is about 2x faster than CLOS. Unless you have a strong need for speed, stick with CLOS.</div><div class=""><br class=""></div><div class="">—————————————————</div><div class="">Can we do any better than JV? What about skipping the internal dispatch lambda shown above, and just vectoring ourselves through the jump-vector?</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun make-list-builder-v2 ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; always in (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp;(vector #'append-item #'get)</span></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp;)))</font></div></div><div class=""><br class=""></div><div class="">and the bake-off code:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defmacro jv2 (jv ix &amp;rest args)</font></div><div class=""><font face="Monaco" class="">&nbsp; `(funcall (aref ,jv ,ix) ,@args))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun bake-off-jv2 (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-list-builder-v2)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv2 lb 0 ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv2 lb 1)))))</font></div><div class=""><br class=""></div></div><div class=""><br class=""></div><div class="">It’s timing showed a median of 3 of 2.527s. So yes, skipping the lambda dispatch is a speedup. Still…. hmmm….</div><div class="">———————————</div><div class="">Well, just for the heck of it, let’s see where a basic STRUCT implementation falls with CLOS and DLAMBDA…</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defstruct lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; cell)</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun lbs-set-cdr (lbs x)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lbs-cell)) lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><span style="font-family: Monaco;" class="">(defun lbs-append (lbs x)</span></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lbs-cell)) lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (lbs-set-cdr lbs (cons x (cdr cell)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun lbs-get (lbs)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lbs-cell)) lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (lbs-set-cdr lbs nil))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><br class=""></div></div><div class="">and its bake-off code:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-lbs (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lbs (make-lbs)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lbs-append lbs ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lbs-get lbs)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))</font></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">OMG!! It’s timing for 100M conses shows a median of 3 of 1.807s. Not only is this faster than both DLAMBDA and CLOS, but it is even faster than using jump-vectors !!!! What a surprise!</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div></div></div></blockquote></div><br class=""><div class="">
<div class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class="">--</span><br style="font-family: Menlo-Regular; font-size: 11px;" class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class="">Pascal Costanza</span><br style="font-family: Menlo-Regular; font-size: 11px;" class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class="">The views expressed in this email are my own, and not those of my employer.</span></div><div class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class=""><br class=""></span></div><br class="Apple-interchange-newline">

</div>



<br class=""></div></div></div></blockquote></div><br class=""></div></body></html>

                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: Speed of various implementation schemes...</h1>
                 <pre>This little exercise did not attempt much in the way of optimizing patterns. Beyond my convenient little #F reader macro for “fast”, it shows what could be expected from a quick ad-hoc implementation using various different techniques that spring to mind.

I don’t do much in the way of production code any more. If I did, then it would be expected that some time be devoted to optimization. But for most of my coding, it is ad-hoc, on the fly as I think it up. And this test case offers some simple guidance in how to structure Q&amp;D code for better performance out of the gate.

Probably the few problems really deserving of some speedup here in my lab are those that attempt design optimizations using various forms of gradient search, simplex search, and genetic programming search. Those problems have very little in the way of internal data structures, and are mostly dominated by gradients, or lack thereof… In this case, e.g., blind deconvolution, antenna analysis, filter design, I probably need better mathematics, not better Lisp code.

- DM


_______________________________________________
Lisp Hug - the mailing list for LispWorks users
lisp-hug@lispworks.com
http://www.lispworks.com/support/lisp-hug.html

</pre>
                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: Speed of various implementation schemes...</h1><html><head><meta http-equiv="Content-Type" content="text/html charset=utf-8"></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">I suspected that the reason for the slowdown with the internal LABELS functions might be the fact that new closures are needed, at least once on major entry, because they all reference a free variable CELL.<div class=""><br class=""></div><div class="">So here is a version without needing closure creation:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-raw2 (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (declare (fixnum ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (cell x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (cell x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr cell (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr cell nil))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (time (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (declare (fixnum g))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (declare (fixnum ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (append-item cell ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (get-list cell)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div><div class=""><br class=""></div><div class="">And indeed, it is fastest of all, at 1.4 sec. That’s more like what I would have expected.</div><div class=""><br class=""></div><div class="">So it seems that we are constructing closures more than once, possibly in each iteration of the loop at the call site of APPEND-ITEM and GET-LIST.</div><div class=""><br class=""></div><div class="">Why would the compiler need to do that?</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 09:42, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">.. and to my shock, and horror!, it actually happens that using the embedded LABELS functions is even worse than using CLOS.<div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-raw (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (time (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (append-item ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (get-list)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">Median of 3 timings for (BAKE-OFF-RAW 100) &nbsp;[ 100M conses ] is 16.432 sec.&nbsp;</div><div class=""><br class=""></div><div class="">I couldn’t believe my eyes. There must be a mistake. I tried the BAKE-OFF-LBS (struct version) again to be sure. It still shows 1.8 sec. Then I tried BAKE-OFF-RAW yet again. Still 16 sec.&nbsp;</div><div class=""><br class=""></div><div class="">What’s going on here?</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 09:29, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">ummm… yes, my DLAMBDA timings incorrectly stated that 10 groups took 60+ seconds. It took 6+ seconds for 10 groups, and scaling to 100 groups would have been the stated 60+ seconds. Sorry… End results remain the same, just mis-stated the case.<div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 09:09, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class=""><div class="">Summary: Using basic STRUCT and direct function calls provides the fastest performing encapsulation of state and behavior. Significantly faster than CLOS, hugely faster than DLAMBDA, and even faster than using vectored function dispatch through a jump vector (!!).</div><div class=""><br class=""></div><div class="">Normalized Timings (2 sig figs, median of 3 meas):</div><div class=""><br class=""></div><div class="">STRUCT<span class="Apple-tab-span" style="white-space:pre">		</span>1.0</div><div class="">Jump Vector<span class="Apple-tab-span" style="white-space:pre">	</span>1.4</div><div class="">JV Dispatch<span class="Apple-tab-span" style="white-space:pre">	</span>2.5</div><div class="">CLOS<span class="Apple-tab-span" style="white-space:pre">		</span>5.0</div><div class="">DLAMBDA<span class="Apple-tab-span" style="white-space:pre">	</span>33</div><div class="">———————</div><div class=""><br class=""></div>From time to time, I make use of Doug Hoyte’s DLAMBDA to make little embedded-intelligence objects that don’t seem to deserve the greater complexity of CLOS. DLAMBDA has the nice trait that it keeps message code adjacent to object state, rather than spreading it all out the way CLOS does. But I’m also a big fan of CLOS - don’t get me wrong.<div class=""><br class=""></div><div class="">But just for curiosity, I wanted to see what the performance overhead on DLAMBDA is. And once I saw that, compared to CLOS, I began looking for what is the fastest possible implementation (apart from coding in Assembly language…). Let’s keep this all in Lisp.</div><div class=""><br class=""></div><div class="">As a simple test, I needed a fast list constructor that could keep items in LIFO order, and provide a fast O(1) append of each additional item as they become available. I initially set this up using internal LABEL functions, and it worked very well. And it also turned out to be useful in several other places. So I decided to package it up for myself and keep the implementation in one place, instead of replicating it all over the place — the usual reason for packaging up state and behavior into objects.</div><div class=""><br class=""></div><div class="">So here is an example of the original code:</div><div class=""><br class=""></div><div class=""><div class=""><div class=""><font face="Monaco" class="">(defun collect-&gt; (pred start until-fn succ-fn</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;key</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(key &nbsp; &nbsp;#'identity)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(map-fn #'identity))</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (do ((x &nbsp; start &nbsp; (funcall succ-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((funcall until-fn x) (get-list))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (when (funcall pred (funcall key x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (append-item (funcall map-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</font></div></div></div><div class=""><br class=""></div><div class="">#F is a reader macro meaning (DECLARE (OPTIMIZE (SPEED 3) (SAFETY 0) (FLOAT 0)).</div><div class=""><br class=""></div><div class="">This code offers an O(1) FIFO list construction, for items from some collection START which satisfy some predicate PRED (using key function KEY), and which collects some mapped representation (MAP-FN) of the qualified items. Pretty simple.</div><div class=""><br class=""></div><div class="">It is that collection of 3 functions inside the LABELS clause that I want to package up. No clients need to know about the internal workings and state of the list constructor object. They just need to be able to instantiate such a constructor, call APPEND-ITEM on each value they want collected, and GET-LIST at the end to get their collected results.&nbsp;</div><div class=""><br class=""></div><div class="">They don’t need to know anything about the CELL, nor the SET-CDR mechanism, which together manages a list by tracking the tail cell of a circular list. The head of the accumulating list is always pointed to by the (CDR CELL). At the end, when they want the result, we need to furnish the head of the accumulated list, and null out the cdr of the last cons cell. Perfect conditions for an encapsulated object implementation.</div><div class=""><br class=""></div><div class="">So here is the first version of encapsulation done with DLAMBDA:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun make-list-builder ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; always in (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (dlambda</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (:append (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (:get ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil)))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</span></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">and here is the corresponding rewrite of COLLECT-&gt;:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun collect-&gt; (pred start until-fn succ-fn</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;key</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(key &nbsp; &nbsp;#'identity)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(map-fn #'identity))</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let ((lb (make-list-builder)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (do ((x &nbsp;start &nbsp;(funcall succ-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ((funcall until-fn x) (funcall lb :get))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (when (funcall pred (funcall key x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (funcall lb :append (funcall map-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div></div><div class=""><br class=""></div><div class="">DLAMBDA is sensitive to the ordering of the message responders, so I placed :APPEND first.</div><div class=""><br class=""></div><div class="">Okay, so now let’s do some timings. I want to measure realistic applications of the list builder, not making lists of hundreds of millions of items, but perhaps a thousand items, done over and over again. To get some realistic durations, we need to execute a few million times. So here is the template of our timing tests:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-dlambda (ngrp) ;; 1 grp = 1000 times of 1000-element lists</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-list-builder)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (funcall lb :append ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (funcall lb :get)))))</font></div><div class=""><br class=""></div></div><div class="">When I execute this bake-off code for 10 groups (10,000,000 conses) I got a median of 3 measurement of 60.38 sec. under LWM 7/64 on a Mac Mini (Late 2014) running OS X Sierra 10.12.3, and nothing much else happening in the machine.</div><div class="">———————————————</div><div class=""><br class=""></div><div class="">So let’s look at a CLOS implementation. Sadly, to me, this takes all that encapsulation and scatters it to the wind.</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defclass list-builder ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ((cell &nbsp;:accessor lb-cell &nbsp;:initform nil)))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defmethod lb-set-cdr ((lb list-builder) x)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lb-cell)) lb</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (setf cell (setf (cdr xcell) x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defmethod lb-append ((lb list-builder) x)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lb-cell)) lb</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (lb-set-cdr lb (cons x (cdr cell)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defmethod lb-get ((lb list-builder))</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lb-cell)) lb</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (lb-set-cdr lb nil))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">Its bake-off code looks like this:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-clos (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-instance 'list-builder)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lb-append lb ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lb-get lb)))))</font></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">And its median of 3 for 100 groups of 1M conses showed a timing of 8.952 sec. Note that this was for 10x as many conses as we used when timing the DLAMBDA implementation. In other words, CLOS is nearly 6x faster than DLAMBA. (That’s close enough for Astronomical accuracy to call it 10x faster).&nbsp;</div><div class=""><br class=""></div><div class="">This is very surprising!! At least to me… and it shows that LW has spent some effort to make CLOS efficient. A tip of the hat to them!</div><div class=""><br class=""></div><div class="">————————</div><div class="">Okay… what’s faster than all this so far? What about a jump vector dispatching to internal LABEL functions?</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun make-list-builder-v ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; always in (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp; (let ((jv (vector #'append-item #'get)))</span></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (lambda (ix &amp;rest args)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (apply (aref jv ix) args))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</font></div><div class=""><br class=""></div></div><div class=""><br class=""></div><div class="">And here is the bake-off code:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defmacro jv (jv ix &amp;rest args)</font></div><div class=""><font face="Monaco" class="">&nbsp; `(funcall ,jv ,ix ,@args))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun bake-off-jv (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-list-builder-v)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv lb 0 ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv lb 1)))))</font></div><div class=""><br class=""></div></div><div class="">Yech!… we need to know that function 0 is the APPEND-ITEM, and function 1 is the GET-LIST. But is it faster?</div><div class=""><br class=""></div><div class="">The median of 3 timings on 100M conses was 4.537s. So yes, it is about 2x faster than CLOS. Unless you have a strong need for speed, stick with CLOS.</div><div class=""><br class=""></div><div class="">—————————————————</div><div class="">Can we do any better than JV? What about skipping the internal dispatch lambda shown above, and just vectoring ourselves through the jump-vector?</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun make-list-builder-v2 ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; always in (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp;(vector #'append-item #'get)</span></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp;)))</font></div></div><div class=""><br class=""></div><div class="">and the bake-off code:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defmacro jv2 (jv ix &amp;rest args)</font></div><div class=""><font face="Monaco" class="">&nbsp; `(funcall (aref ,jv ,ix) ,@args))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun bake-off-jv2 (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-list-builder-v2)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv2 lb 0 ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv2 lb 1)))))</font></div><div class=""><br class=""></div></div><div class=""><br class=""></div><div class="">It’s timing showed a median of 3 of 2.527s. So yes, skipping the lambda dispatch is a speedup. Still…. hmmm….</div><div class="">———————————</div><div class="">Well, just for the heck of it, let’s see where a basic STRUCT implementation falls with CLOS and DLAMBDA…</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defstruct lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; cell)</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun lbs-set-cdr (lbs x)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lbs-cell)) lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><span style="font-family: Monaco;" class="">(defun lbs-append (lbs x)</span></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lbs-cell)) lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (lbs-set-cdr lbs (cons x (cdr cell)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun lbs-get (lbs)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lbs-cell)) lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (lbs-set-cdr lbs nil))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><br class=""></div></div><div class="">and its bake-off code:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-lbs (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lbs (make-lbs)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lbs-append lbs ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lbs-get lbs)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))</font></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">OMG!! It’s timing for 100M conses shows a median of 3 of 1.807s. Not only is this faster than both DLAMBDA and CLOS, but it is even faster than using jump-vectors !!!! What a surprise!</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div></div></div></blockquote></div><br class=""></div></div></blockquote></div><br class=""></div></div></div></blockquote></div><br class=""></div></body></html>

                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: Speed of various implementation schemes...</h1><html><head><meta http-equiv="Content-Type" content="text/html charset=utf-8"></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">Looking at the disassembly, I see that the labels functions are being closed over on the stack, only on major entry. Not repeatedly.&nbsp;<div class=""><br class=""></div><div class="">However, APPEND-ITEM and GET-LIST, once closed over, also need to call the newly constructed closure for SET-CDR. And that is sitting on the stack as a freshly made closure. So the compiled code for APPEND-ITEM and GET-LIST need to call something that must be determined dynamically each time.</div><div class=""><br class=""></div><div class="">If I make SET-CDR depend on no free variables, then it can be succinctly encapsulated and never needs closing over on the stack. So this version also runs extremely quickly:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-raw3 (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; (let (cell)</span></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (cell x) <font color="#b92d5d" class="">;; &lt;— no free vars</font></font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr cell (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr cell nil))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (time (dotimes (g (* 1000 ngrp))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</span></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (append-item ix))</span></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (get-list)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div><div class=""><br class=""></div><div class="">The slowdown happens when there is mutual interaction among LABELS functions, and the called functions have free vars.</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 10:28, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">I suspected that the reason for the slowdown with the internal LABELS functions might be the fact that new closures are needed, at least once on major entry, because they all reference a free variable CELL.<div class=""><br class=""></div><div class="">So here is a version without needing closure creation:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-raw2 (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (declare (fixnum ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (cell x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (cell x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr cell (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr cell nil))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (time (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (declare (fixnum g))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (declare (fixnum ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (append-item cell ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (get-list cell)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div><div class=""><br class=""></div><div class="">And indeed, it is fastest of all, at 1.4 sec. That’s more like what I would have expected.</div><div class=""><br class=""></div><div class="">So it seems that we are constructing closures more than once, possibly in each iteration of the loop at the call site of APPEND-ITEM and GET-LIST.</div><div class=""><br class=""></div><div class="">Why would the compiler need to do that?</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 09:42, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">.. and to my shock, and horror!, it actually happens that using the embedded LABELS functions is even worse than using CLOS.<div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-raw (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (time (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (append-item ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (get-list)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">Median of 3 timings for (BAKE-OFF-RAW 100) &nbsp;[ 100M conses ] is 16.432 sec.&nbsp;</div><div class=""><br class=""></div><div class="">I couldn’t believe my eyes. There must be a mistake. I tried the BAKE-OFF-LBS (struct version) again to be sure. It still shows 1.8 sec. Then I tried BAKE-OFF-RAW yet again. Still 16 sec.&nbsp;</div><div class=""><br class=""></div><div class="">What’s going on here?</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 09:29, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">ummm… yes, my DLAMBDA timings incorrectly stated that 10 groups took 60+ seconds. It took 6+ seconds for 10 groups, and scaling to 100 groups would have been the stated 60+ seconds. Sorry… End results remain the same, just mis-stated the case.<div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 09:09, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class=""><div class="">Summary: Using basic STRUCT and direct function calls provides the fastest performing encapsulation of state and behavior. Significantly faster than CLOS, hugely faster than DLAMBDA, and even faster than using vectored function dispatch through a jump vector (!!).</div><div class=""><br class=""></div><div class="">Normalized Timings (2 sig figs, median of 3 meas):</div><div class=""><br class=""></div><div class="">STRUCT<span class="Apple-tab-span" style="white-space:pre">		</span>1.0</div><div class="">Jump Vector<span class="Apple-tab-span" style="white-space:pre">	</span>1.4</div><div class="">JV Dispatch<span class="Apple-tab-span" style="white-space:pre">	</span>2.5</div><div class="">CLOS<span class="Apple-tab-span" style="white-space:pre">		</span>5.0</div><div class="">DLAMBDA<span class="Apple-tab-span" style="white-space:pre">	</span>33</div><div class="">———————</div><div class=""><br class=""></div>From time to time, I make use of Doug Hoyte’s DLAMBDA to make little embedded-intelligence objects that don’t seem to deserve the greater complexity of CLOS. DLAMBDA has the nice trait that it keeps message code adjacent to object state, rather than spreading it all out the way CLOS does. But I’m also a big fan of CLOS - don’t get me wrong.<div class=""><br class=""></div><div class="">But just for curiosity, I wanted to see what the performance overhead on DLAMBDA is. And once I saw that, compared to CLOS, I began looking for what is the fastest possible implementation (apart from coding in Assembly language…). Let’s keep this all in Lisp.</div><div class=""><br class=""></div><div class="">As a simple test, I needed a fast list constructor that could keep items in LIFO order, and provide a fast O(1) append of each additional item as they become available. I initially set this up using internal LABEL functions, and it worked very well. And it also turned out to be useful in several other places. So I decided to package it up for myself and keep the implementation in one place, instead of replicating it all over the place — the usual reason for packaging up state and behavior into objects.</div><div class=""><br class=""></div><div class="">So here is an example of the original code:</div><div class=""><br class=""></div><div class=""><div class=""><div class=""><font face="Monaco" class="">(defun collect-&gt; (pred start until-fn succ-fn</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;key</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(key &nbsp; &nbsp;#'identity)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(map-fn #'identity))</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (do ((x &nbsp; start &nbsp; (funcall succ-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((funcall until-fn x) (get-list))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (when (funcall pred (funcall key x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (append-item (funcall map-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</font></div></div></div><div class=""><br class=""></div><div class="">#F is a reader macro meaning (DECLARE (OPTIMIZE (SPEED 3) (SAFETY 0) (FLOAT 0)).</div><div class=""><br class=""></div><div class="">This code offers an O(1) FIFO list construction, for items from some collection START which satisfy some predicate PRED (using key function KEY), and which collects some mapped representation (MAP-FN) of the qualified items. Pretty simple.</div><div class=""><br class=""></div><div class="">It is that collection of 3 functions inside the LABELS clause that I want to package up. No clients need to know about the internal workings and state of the list constructor object. They just need to be able to instantiate such a constructor, call APPEND-ITEM on each value they want collected, and GET-LIST at the end to get their collected results.&nbsp;</div><div class=""><br class=""></div><div class="">They don’t need to know anything about the CELL, nor the SET-CDR mechanism, which together manages a list by tracking the tail cell of a circular list. The head of the accumulating list is always pointed to by the (CDR CELL). At the end, when they want the result, we need to furnish the head of the accumulated list, and null out the cdr of the last cons cell. Perfect conditions for an encapsulated object implementation.</div><div class=""><br class=""></div><div class="">So here is the first version of encapsulation done with DLAMBDA:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun make-list-builder ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; always in (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (dlambda</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (:append (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (:get ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil)))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</span></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">and here is the corresponding rewrite of COLLECT-&gt;:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun collect-&gt; (pred start until-fn succ-fn</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;key</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(key &nbsp; &nbsp;#'identity)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(map-fn #'identity))</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let ((lb (make-list-builder)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (do ((x &nbsp;start &nbsp;(funcall succ-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ((funcall until-fn x) (funcall lb :get))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (when (funcall pred (funcall key x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (funcall lb :append (funcall map-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div></div><div class=""><br class=""></div><div class="">DLAMBDA is sensitive to the ordering of the message responders, so I placed :APPEND first.</div><div class=""><br class=""></div><div class="">Okay, so now let’s do some timings. I want to measure realistic applications of the list builder, not making lists of hundreds of millions of items, but perhaps a thousand items, done over and over again. To get some realistic durations, we need to execute a few million times. So here is the template of our timing tests:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-dlambda (ngrp) ;; 1 grp = 1000 times of 1000-element lists</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-list-builder)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (funcall lb :append ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (funcall lb :get)))))</font></div><div class=""><br class=""></div></div><div class="">When I execute this bake-off code for 10 groups (10,000,000 conses) I got a median of 3 measurement of 60.38 sec. under LWM 7/64 on a Mac Mini (Late 2014) running OS X Sierra 10.12.3, and nothing much else happening in the machine.</div><div class="">———————————————</div><div class=""><br class=""></div><div class="">So let’s look at a CLOS implementation. Sadly, to me, this takes all that encapsulation and scatters it to the wind.</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defclass list-builder ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ((cell &nbsp;:accessor lb-cell &nbsp;:initform nil)))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defmethod lb-set-cdr ((lb list-builder) x)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lb-cell)) lb</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (setf cell (setf (cdr xcell) x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defmethod lb-append ((lb list-builder) x)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lb-cell)) lb</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (lb-set-cdr lb (cons x (cdr cell)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defmethod lb-get ((lb list-builder))</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lb-cell)) lb</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (lb-set-cdr lb nil))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">Its bake-off code looks like this:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-clos (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-instance 'list-builder)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lb-append lb ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lb-get lb)))))</font></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">And its median of 3 for 100 groups of 1M conses showed a timing of 8.952 sec. Note that this was for 10x as many conses as we used when timing the DLAMBDA implementation. In other words, CLOS is nearly 6x faster than DLAMBA. (That’s close enough for Astronomical accuracy to call it 10x faster).&nbsp;</div><div class=""><br class=""></div><div class="">This is very surprising!! At least to me… and it shows that LW has spent some effort to make CLOS efficient. A tip of the hat to them!</div><div class=""><br class=""></div><div class="">————————</div><div class="">Okay… what’s faster than all this so far? What about a jump vector dispatching to internal LABEL functions?</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun make-list-builder-v ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; always in (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp; (let ((jv (vector #'append-item #'get)))</span></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (lambda (ix &amp;rest args)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (apply (aref jv ix) args))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</font></div><div class=""><br class=""></div></div><div class=""><br class=""></div><div class="">And here is the bake-off code:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defmacro jv (jv ix &amp;rest args)</font></div><div class=""><font face="Monaco" class="">&nbsp; `(funcall ,jv ,ix ,@args))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun bake-off-jv (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-list-builder-v)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv lb 0 ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv lb 1)))))</font></div><div class=""><br class=""></div></div><div class="">Yech!… we need to know that function 0 is the APPEND-ITEM, and function 1 is the GET-LIST. But is it faster?</div><div class=""><br class=""></div><div class="">The median of 3 timings on 100M conses was 4.537s. So yes, it is about 2x faster than CLOS. Unless you have a strong need for speed, stick with CLOS.</div><div class=""><br class=""></div><div class="">—————————————————</div><div class="">Can we do any better than JV? What about skipping the internal dispatch lambda shown above, and just vectoring ourselves through the jump-vector?</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun make-list-builder-v2 ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; always in (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp;(vector #'append-item #'get)</span></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp;)))</font></div></div><div class=""><br class=""></div><div class="">and the bake-off code:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defmacro jv2 (jv ix &amp;rest args)</font></div><div class=""><font face="Monaco" class="">&nbsp; `(funcall (aref ,jv ,ix) ,@args))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun bake-off-jv2 (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-list-builder-v2)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv2 lb 0 ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv2 lb 1)))))</font></div><div class=""><br class=""></div></div><div class=""><br class=""></div><div class="">It’s timing showed a median of 3 of 2.527s. So yes, skipping the lambda dispatch is a speedup. Still…. hmmm….</div><div class="">———————————</div><div class="">Well, just for the heck of it, let’s see where a basic STRUCT implementation falls with CLOS and DLAMBDA…</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defstruct lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; cell)</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun lbs-set-cdr (lbs x)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lbs-cell)) lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><span style="font-family: Monaco;" class="">(defun lbs-append (lbs x)</span></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lbs-cell)) lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (lbs-set-cdr lbs (cons x (cdr cell)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun lbs-get (lbs)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lbs-cell)) lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (lbs-set-cdr lbs nil))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><br class=""></div></div><div class="">and its bake-off code:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-lbs (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lbs (make-lbs)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lbs-append lbs ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lbs-get lbs)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))</font></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">OMG!! It’s timing for 100M conses shows a median of 3 of 1.807s. Not only is this faster than both DLAMBDA and CLOS, but it is even faster than using jump-vectors !!!! What a surprise!</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div></div></div></blockquote></div><br class=""></div></div></blockquote></div><br class=""></div></div></div></blockquote></div><br class=""></div></div></div></blockquote></div><br class=""></div></body></html>

                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: Speed of various implementation schemes...</h1><html><head><meta http-equiv="Content-Type" content="text/html charset=utf-8"></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">When you declare the local functions inline, the first version actually is the fastest.<div class=""><br class=""></div><div class=""><div class="">(defun bake-off-raw (ngrp)</div><div class="">&nbsp; (declare (optimize (speed 3) (safety 0) (debug 0) (space 0) (compilation-speed 0)))</div><div class="">&nbsp; (let (cell)</div><div class="">&nbsp; &nbsp; (labels ((set-cdr (x)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list ()</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</div><div class="">&nbsp; &nbsp; &nbsp; (declare (inline set-cdr append-time get-list))</div><div class="">&nbsp; &nbsp; &nbsp; (time (dotimes (g (* 1000 ngrp))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (append-item ix))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (get-list)))</div><div class="">&nbsp; &nbsp; &nbsp; )))</div></div><div class=""><br class=""></div><div class="">Pascal</div><div class=""><br class=""><div><blockquote type="cite" class=""><div class="">On 11 Feb 2017, at 18:58, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">Looking at the disassembly, I see that the labels functions are being closed over on the stack, only on major entry. Not repeatedly.&nbsp;<div class=""><br class=""></div><div class="">However, APPEND-ITEM and GET-LIST, once closed over, also need to call the newly constructed closure for SET-CDR. And that is sitting on the stack as a freshly made closure. So the compiled code for APPEND-ITEM and GET-LIST need to call something that must be determined dynamically each time.</div><div class=""><br class=""></div><div class="">If I make SET-CDR depend on no free variables, then it can be succinctly encapsulated and never needs closing over on the stack. So this version also runs extremely quickly:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-raw3 (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; (let (cell)</span></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (cell x) <font color="#b92d5d" class="">;; &lt;— no free vars</font></font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr cell (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr cell nil))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (time (dotimes (g (* 1000 ngrp))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</span></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (append-item ix))</span></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (get-list)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div><div class=""><br class=""></div><div class="">The slowdown happens when there is mutual interaction among LABELS functions, and the called functions have free vars.</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 10:28, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">I suspected that the reason for the slowdown with the internal LABELS functions might be the fact that new closures are needed, at least once on major entry, because they all reference a free variable CELL.<div class=""><br class=""></div><div class="">So here is a version without needing closure creation:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-raw2 (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (declare (fixnum ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (cell x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (cell x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr cell (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr cell nil))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (time (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (declare (fixnum g))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (declare (fixnum ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (append-item cell ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (get-list cell)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div><div class=""><br class=""></div><div class="">And indeed, it is fastest of all, at 1.4 sec. That’s more like what I would have expected.</div><div class=""><br class=""></div><div class="">So it seems that we are constructing closures more than once, possibly in each iteration of the loop at the call site of APPEND-ITEM and GET-LIST.</div><div class=""><br class=""></div><div class="">Why would the compiler need to do that?</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 09:42, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">.. and to my shock, and horror!, it actually happens that using the embedded LABELS functions is even worse than using CLOS.<div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-raw (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (time (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (append-item ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (get-list)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">Median of 3 timings for (BAKE-OFF-RAW 100) &nbsp;[ 100M conses ] is 16.432 sec.&nbsp;</div><div class=""><br class=""></div><div class="">I couldn’t believe my eyes. There must be a mistake. I tried the BAKE-OFF-LBS (struct version) again to be sure. It still shows 1.8 sec. Then I tried BAKE-OFF-RAW yet again. Still 16 sec.&nbsp;</div><div class=""><br class=""></div><div class="">What’s going on here?</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 09:29, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">ummm… yes, my DLAMBDA timings incorrectly stated that 10 groups took 60+ seconds. It took 6+ seconds for 10 groups, and scaling to 100 groups would have been the stated 60+ seconds. Sorry… End results remain the same, just mis-stated the case.<div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 09:09, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class=""><div class="">Summary: Using basic STRUCT and direct function calls provides the fastest performing encapsulation of state and behavior. Significantly faster than CLOS, hugely faster than DLAMBDA, and even faster than using vectored function dispatch through a jump vector (!!).</div><div class=""><br class=""></div><div class="">Normalized Timings (2 sig figs, median of 3 meas):</div><div class=""><br class=""></div><div class="">STRUCT<span class="Apple-tab-span" style="white-space:pre">		</span>1.0</div><div class="">Jump Vector<span class="Apple-tab-span" style="white-space:pre">	</span>1.4</div><div class="">JV Dispatch<span class="Apple-tab-span" style="white-space:pre">	</span>2.5</div><div class="">CLOS<span class="Apple-tab-span" style="white-space:pre">		</span>5.0</div><div class="">DLAMBDA<span class="Apple-tab-span" style="white-space:pre">	</span>33</div><div class="">———————</div><div class=""><br class=""></div>From time to time, I make use of Doug Hoyte’s DLAMBDA to make little embedded-intelligence objects that don’t seem to deserve the greater complexity of CLOS. DLAMBDA has the nice trait that it keeps message code adjacent to object state, rather than spreading it all out the way CLOS does. But I’m also a big fan of CLOS - don’t get me wrong.<div class=""><br class=""></div><div class="">But just for curiosity, I wanted to see what the performance overhead on DLAMBDA is. And once I saw that, compared to CLOS, I began looking for what is the fastest possible implementation (apart from coding in Assembly language…). Let’s keep this all in Lisp.</div><div class=""><br class=""></div><div class="">As a simple test, I needed a fast list constructor that could keep items in LIFO order, and provide a fast O(1) append of each additional item as they become available. I initially set this up using internal LABEL functions, and it worked very well. And it also turned out to be useful in several other places. So I decided to package it up for myself and keep the implementation in one place, instead of replicating it all over the place — the usual reason for packaging up state and behavior into objects.</div><div class=""><br class=""></div><div class="">So here is an example of the original code:</div><div class=""><br class=""></div><div class=""><div class=""><div class=""><font face="Monaco" class="">(defun collect-&gt; (pred start until-fn succ-fn</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;key</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(key &nbsp; &nbsp;#'identity)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(map-fn #'identity))</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (do ((x &nbsp; start &nbsp; (funcall succ-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((funcall until-fn x) (get-list))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (when (funcall pred (funcall key x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (append-item (funcall map-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</font></div></div></div><div class=""><br class=""></div><div class="">#F is a reader macro meaning (DECLARE (OPTIMIZE (SPEED 3) (SAFETY 0) (FLOAT 0)).</div><div class=""><br class=""></div><div class="">This code offers an O(1) FIFO list construction, for items from some collection START which satisfy some predicate PRED (using key function KEY), and which collects some mapped representation (MAP-FN) of the qualified items. Pretty simple.</div><div class=""><br class=""></div><div class="">It is that collection of 3 functions inside the LABELS clause that I want to package up. No clients need to know about the internal workings and state of the list constructor object. They just need to be able to instantiate such a constructor, call APPEND-ITEM on each value they want collected, and GET-LIST at the end to get their collected results.&nbsp;</div><div class=""><br class=""></div><div class="">They don’t need to know anything about the CELL, nor the SET-CDR mechanism, which together manages a list by tracking the tail cell of a circular list. The head of the accumulating list is always pointed to by the (CDR CELL). At the end, when they want the result, we need to furnish the head of the accumulated list, and null out the cdr of the last cons cell. Perfect conditions for an encapsulated object implementation.</div><div class=""><br class=""></div><div class="">So here is the first version of encapsulation done with DLAMBDA:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun make-list-builder ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; always in (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (dlambda</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (:append (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (:get ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil)))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</span></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">and here is the corresponding rewrite of COLLECT-&gt;:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun collect-&gt; (pred start until-fn succ-fn</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;key</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(key &nbsp; &nbsp;#'identity)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(map-fn #'identity))</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let ((lb (make-list-builder)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (do ((x &nbsp;start &nbsp;(funcall succ-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ((funcall until-fn x) (funcall lb :get))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (when (funcall pred (funcall key x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (funcall lb :append (funcall map-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div></div><div class=""><br class=""></div><div class="">DLAMBDA is sensitive to the ordering of the message responders, so I placed :APPEND first.</div><div class=""><br class=""></div><div class="">Okay, so now let’s do some timings. I want to measure realistic applications of the list builder, not making lists of hundreds of millions of items, but perhaps a thousand items, done over and over again. To get some realistic durations, we need to execute a few million times. So here is the template of our timing tests:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-dlambda (ngrp) ;; 1 grp = 1000 times of 1000-element lists</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-list-builder)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (funcall lb :append ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (funcall lb :get)))))</font></div><div class=""><br class=""></div></div><div class="">When I execute this bake-off code for 10 groups (10,000,000 conses) I got a median of 3 measurement of 60.38 sec. under LWM 7/64 on a Mac Mini (Late 2014) running OS X Sierra 10.12.3, and nothing much else happening in the machine.</div><div class="">———————————————</div><div class=""><br class=""></div><div class="">So let’s look at a CLOS implementation. Sadly, to me, this takes all that encapsulation and scatters it to the wind.</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defclass list-builder ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ((cell &nbsp;:accessor lb-cell &nbsp;:initform nil)))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defmethod lb-set-cdr ((lb list-builder) x)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lb-cell)) lb</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (setf cell (setf (cdr xcell) x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defmethod lb-append ((lb list-builder) x)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lb-cell)) lb</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (lb-set-cdr lb (cons x (cdr cell)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defmethod lb-get ((lb list-builder))</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lb-cell)) lb</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (lb-set-cdr lb nil))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">Its bake-off code looks like this:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-clos (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-instance 'list-builder)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lb-append lb ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lb-get lb)))))</font></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">And its median of 3 for 100 groups of 1M conses showed a timing of 8.952 sec. Note that this was for 10x as many conses as we used when timing the DLAMBDA implementation. In other words, CLOS is nearly 6x faster than DLAMBA. (That’s close enough for Astronomical accuracy to call it 10x faster).&nbsp;</div><div class=""><br class=""></div><div class="">This is very surprising!! At least to me… and it shows that LW has spent some effort to make CLOS efficient. A tip of the hat to them!</div><div class=""><br class=""></div><div class="">————————</div><div class="">Okay… what’s faster than all this so far? What about a jump vector dispatching to internal LABEL functions?</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun make-list-builder-v ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; always in (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp; (let ((jv (vector #'append-item #'get)))</span></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (lambda (ix &amp;rest args)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (apply (aref jv ix) args))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</font></div><div class=""><br class=""></div></div><div class=""><br class=""></div><div class="">And here is the bake-off code:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defmacro jv (jv ix &amp;rest args)</font></div><div class=""><font face="Monaco" class="">&nbsp; `(funcall ,jv ,ix ,@args))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun bake-off-jv (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-list-builder-v)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv lb 0 ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv lb 1)))))</font></div><div class=""><br class=""></div></div><div class="">Yech!… we need to know that function 0 is the APPEND-ITEM, and function 1 is the GET-LIST. But is it faster?</div><div class=""><br class=""></div><div class="">The median of 3 timings on 100M conses was 4.537s. So yes, it is about 2x faster than CLOS. Unless you have a strong need for speed, stick with CLOS.</div><div class=""><br class=""></div><div class="">—————————————————</div><div class="">Can we do any better than JV? What about skipping the internal dispatch lambda shown above, and just vectoring ourselves through the jump-vector?</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun make-list-builder-v2 ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; always in (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp;(vector #'append-item #'get)</span></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp;)))</font></div></div><div class=""><br class=""></div><div class="">and the bake-off code:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defmacro jv2 (jv ix &amp;rest args)</font></div><div class=""><font face="Monaco" class="">&nbsp; `(funcall (aref ,jv ,ix) ,@args))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun bake-off-jv2 (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-list-builder-v2)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv2 lb 0 ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv2 lb 1)))))</font></div><div class=""><br class=""></div></div><div class=""><br class=""></div><div class="">It’s timing showed a median of 3 of 2.527s. So yes, skipping the lambda dispatch is a speedup. Still…. hmmm….</div><div class="">———————————</div><div class="">Well, just for the heck of it, let’s see where a basic STRUCT implementation falls with CLOS and DLAMBDA…</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defstruct lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; cell)</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun lbs-set-cdr (lbs x)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lbs-cell)) lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><span style="font-family: Monaco;" class="">(defun lbs-append (lbs x)</span></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lbs-cell)) lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (lbs-set-cdr lbs (cons x (cdr cell)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun lbs-get (lbs)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lbs-cell)) lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (lbs-set-cdr lbs nil))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><br class=""></div></div><div class="">and its bake-off code:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-lbs (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lbs (make-lbs)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lbs-append lbs ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lbs-get lbs)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))</font></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">OMG!! It’s timing for 100M conses shows a median of 3 of 1.807s. Not only is this faster than both DLAMBDA and CLOS, but it is even faster than using jump-vectors !!!! What a surprise!</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div></div></div></blockquote></div><br class=""></div></div></blockquote></div><br class=""></div></div></div></blockquote></div><br class=""></div></div></div></blockquote></div><br class=""></div></div></div></blockquote></div><br class=""><div class="">
<div class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class="">--</span><br style="font-family: Menlo-Regular; font-size: 11px;" class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class="">Pascal Costanza</span><br style="font-family: Menlo-Regular; font-size: 11px;" class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class="">The views expressed in this email are my own, and not those of my employer.</span></div><div class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class=""><br class=""></span></div><br class="Apple-interchange-newline">

</div>


<br class=""></div></body></html>

                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: Speed of various implementation schemes...</h1><html><head><meta http-equiv="Content-Type" content="text/html charset=utf-8"></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">Oooh! That’s very interesting!! Thanks so much.<div class=""><br class=""></div><div class="">I clearly need to learn to appreciate DECLARE much more than I currently do.</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><br class=""></div><div><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 11:25, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">Oooh! That’s very interesting!! Thanks so much.<div class=""><br class=""></div><div class="">I clearly need to learn to appreciate DECLARE much more than I currently do.</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""><div class=""><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 11:07, Pascal Costanza &lt;<a href="mailto:pc@p-cos.net" class="">pc@p-cos.net</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">When you declare the local functions inline, the first version actually is the fastest.<div class=""><br class=""></div><div class=""><div class="">(defun bake-off-raw (ngrp)</div><div class="">&nbsp; (declare (optimize (speed 3) (safety 0) (debug 0) (space 0) (compilation-speed 0)))</div><div class="">&nbsp; (let (cell)</div><div class="">&nbsp; &nbsp; (labels ((set-cdr (x)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list ()</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</div><div class="">&nbsp; &nbsp; &nbsp; (declare (inline set-cdr append-time get-list))</div><div class="">&nbsp; &nbsp; &nbsp; (time (dotimes (g (* 1000 ngrp))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (append-item ix))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (get-list)))</div><div class="">&nbsp; &nbsp; &nbsp; )))</div></div><div class=""><br class=""></div><div class="">Pascal</div><div class=""><br class=""><div class=""><blockquote type="cite" class=""><div class="">On 11 Feb 2017, at 18:58, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">Looking at the disassembly, I see that the labels functions are being closed over on the stack, only on major entry. Not repeatedly.&nbsp;<div class=""><br class=""></div><div class="">However, APPEND-ITEM and GET-LIST, once closed over, also need to call the newly constructed closure for SET-CDR. And that is sitting on the stack as a freshly made closure. So the compiled code for APPEND-ITEM and GET-LIST need to call something that must be determined dynamically each time.</div><div class=""><br class=""></div><div class="">If I make SET-CDR depend on no free variables, then it can be succinctly encapsulated and never needs closing over on the stack. So this version also runs extremely quickly:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-raw3 (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; (let (cell)</span></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (cell x) <font color="#b92d5d" class="">;; &lt;— no free vars</font></font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr cell (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr cell nil))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (time (dotimes (g (* 1000 ngrp))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</span></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (append-item ix))</span></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (get-list)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div><div class=""><br class=""></div><div class="">The slowdown happens when there is mutual interaction among LABELS functions, and the called functions have free vars.</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 10:28, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">I suspected that the reason for the slowdown with the internal LABELS functions might be the fact that new closures are needed, at least once on major entry, because they all reference a free variable CELL.<div class=""><br class=""></div><div class="">So here is a version without needing closure creation:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-raw2 (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (declare (fixnum ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (cell x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (cell x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr cell (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr cell nil))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (time (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (declare (fixnum g))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (declare (fixnum ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (append-item cell ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (get-list cell)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div><div class=""><br class=""></div><div class="">And indeed, it is fastest of all, at 1.4 sec. That’s more like what I would have expected.</div><div class=""><br class=""></div><div class="">So it seems that we are constructing closures more than once, possibly in each iteration of the loop at the call site of APPEND-ITEM and GET-LIST.</div><div class=""><br class=""></div><div class="">Why would the compiler need to do that?</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 09:42, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">.. and to my shock, and horror!, it actually happens that using the embedded LABELS functions is even worse than using CLOS.<div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-raw (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (time (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (append-item ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (get-list)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">Median of 3 timings for (BAKE-OFF-RAW 100) &nbsp;[ 100M conses ] is 16.432 sec.&nbsp;</div><div class=""><br class=""></div><div class="">I couldn’t believe my eyes. There must be a mistake. I tried the BAKE-OFF-LBS (struct version) again to be sure. It still shows 1.8 sec. Then I tried BAKE-OFF-RAW yet again. Still 16 sec.&nbsp;</div><div class=""><br class=""></div><div class="">What’s going on here?</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 09:29, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">ummm… yes, my DLAMBDA timings incorrectly stated that 10 groups took 60+ seconds. It took 6+ seconds for 10 groups, and scaling to 100 groups would have been the stated 60+ seconds. Sorry… End results remain the same, just mis-stated the case.<div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 09:09, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class=""><div class="">Summary: Using basic STRUCT and direct function calls provides the fastest performing encapsulation of state and behavior. Significantly faster than CLOS, hugely faster than DLAMBDA, and even faster than using vectored function dispatch through a jump vector (!!).</div><div class=""><br class=""></div><div class="">Normalized Timings (2 sig figs, median of 3 meas):</div><div class=""><br class=""></div><div class="">STRUCT<span class="Apple-tab-span" style="white-space:pre">		</span>1.0</div><div class="">Jump Vector<span class="Apple-tab-span" style="white-space:pre">	</span>1.4</div><div class="">JV Dispatch<span class="Apple-tab-span" style="white-space:pre">	</span>2.5</div><div class="">CLOS<span class="Apple-tab-span" style="white-space:pre">		</span>5.0</div><div class="">DLAMBDA<span class="Apple-tab-span" style="white-space:pre">	</span>33</div><div class="">———————</div><div class=""><br class=""></div>From time to time, I make use of Doug Hoyte’s DLAMBDA to make little embedded-intelligence objects that don’t seem to deserve the greater complexity of CLOS. DLAMBDA has the nice trait that it keeps message code adjacent to object state, rather than spreading it all out the way CLOS does. But I’m also a big fan of CLOS - don’t get me wrong.<div class=""><br class=""></div><div class="">But just for curiosity, I wanted to see what the performance overhead on DLAMBDA is. And once I saw that, compared to CLOS, I began looking for what is the fastest possible implementation (apart from coding in Assembly language…). Let’s keep this all in Lisp.</div><div class=""><br class=""></div><div class="">As a simple test, I needed a fast list constructor that could keep items in LIFO order, and provide a fast O(1) append of each additional item as they become available. I initially set this up using internal LABEL functions, and it worked very well. And it also turned out to be useful in several other places. So I decided to package it up for myself and keep the implementation in one place, instead of replicating it all over the place — the usual reason for packaging up state and behavior into objects.</div><div class=""><br class=""></div><div class="">So here is an example of the original code:</div><div class=""><br class=""></div><div class=""><div class=""><div class=""><font face="Monaco" class="">(defun collect-&gt; (pred start until-fn succ-fn</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;key</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(key &nbsp; &nbsp;#'identity)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(map-fn #'identity))</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (do ((x &nbsp; start &nbsp; (funcall succ-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((funcall until-fn x) (get-list))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (when (funcall pred (funcall key x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (append-item (funcall map-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</font></div></div></div><div class=""><br class=""></div><div class="">#F is a reader macro meaning (DECLARE (OPTIMIZE (SPEED 3) (SAFETY 0) (FLOAT 0)).</div><div class=""><br class=""></div><div class="">This code offers an O(1) FIFO list construction, for items from some collection START which satisfy some predicate PRED (using key function KEY), and which collects some mapped representation (MAP-FN) of the qualified items. Pretty simple.</div><div class=""><br class=""></div><div class="">It is that collection of 3 functions inside the LABELS clause that I want to package up. No clients need to know about the internal workings and state of the list constructor object. They just need to be able to instantiate such a constructor, call APPEND-ITEM on each value they want collected, and GET-LIST at the end to get their collected results.&nbsp;</div><div class=""><br class=""></div><div class="">They don’t need to know anything about the CELL, nor the SET-CDR mechanism, which together manages a list by tracking the tail cell of a circular list. The head of the accumulating list is always pointed to by the (CDR CELL). At the end, when they want the result, we need to furnish the head of the accumulated list, and null out the cdr of the last cons cell. Perfect conditions for an encapsulated object implementation.</div><div class=""><br class=""></div><div class="">So here is the first version of encapsulation done with DLAMBDA:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun make-list-builder ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; always in (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (dlambda</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (:append (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (:get ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil)))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</span></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">and here is the corresponding rewrite of COLLECT-&gt;:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun collect-&gt; (pred start until-fn succ-fn</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;key</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(key &nbsp; &nbsp;#'identity)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(map-fn #'identity))</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let ((lb (make-list-builder)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (do ((x &nbsp;start &nbsp;(funcall succ-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ((funcall until-fn x) (funcall lb :get))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (when (funcall pred (funcall key x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (funcall lb :append (funcall map-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div></div><div class=""><br class=""></div><div class="">DLAMBDA is sensitive to the ordering of the message responders, so I placed :APPEND first.</div><div class=""><br class=""></div><div class="">Okay, so now let’s do some timings. I want to measure realistic applications of the list builder, not making lists of hundreds of millions of items, but perhaps a thousand items, done over and over again. To get some realistic durations, we need to execute a few million times. So here is the template of our timing tests:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-dlambda (ngrp) ;; 1 grp = 1000 times of 1000-element lists</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-list-builder)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (funcall lb :append ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (funcall lb :get)))))</font></div><div class=""><br class=""></div></div><div class="">When I execute this bake-off code for 10 groups (10,000,000 conses) I got a median of 3 measurement of 60.38 sec. under LWM 7/64 on a Mac Mini (Late 2014) running OS X Sierra 10.12.3, and nothing much else happening in the machine.</div><div class="">———————————————</div><div class=""><br class=""></div><div class="">So let’s look at a CLOS implementation. Sadly, to me, this takes all that encapsulation and scatters it to the wind.</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defclass list-builder ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ((cell &nbsp;:accessor lb-cell &nbsp;:initform nil)))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defmethod lb-set-cdr ((lb list-builder) x)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lb-cell)) lb</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (setf cell (setf (cdr xcell) x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defmethod lb-append ((lb list-builder) x)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lb-cell)) lb</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (lb-set-cdr lb (cons x (cdr cell)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defmethod lb-get ((lb list-builder))</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lb-cell)) lb</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (lb-set-cdr lb nil))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">Its bake-off code looks like this:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-clos (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-instance 'list-builder)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lb-append lb ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lb-get lb)))))</font></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">And its median of 3 for 100 groups of 1M conses showed a timing of 8.952 sec. Note that this was for 10x as many conses as we used when timing the DLAMBDA implementation. In other words, CLOS is nearly 6x faster than DLAMBA. (That’s close enough for Astronomical accuracy to call it 10x faster).&nbsp;</div><div class=""><br class=""></div><div class="">This is very surprising!! At least to me… and it shows that LW has spent some effort to make CLOS efficient. A tip of the hat to them!</div><div class=""><br class=""></div><div class="">————————</div><div class="">Okay… what’s faster than all this so far? What about a jump vector dispatching to internal LABEL functions?</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun make-list-builder-v ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; always in (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp; (let ((jv (vector #'append-item #'get)))</span></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (lambda (ix &amp;rest args)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (apply (aref jv ix) args))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</font></div><div class=""><br class=""></div></div><div class=""><br class=""></div><div class="">And here is the bake-off code:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defmacro jv (jv ix &amp;rest args)</font></div><div class=""><font face="Monaco" class="">&nbsp; `(funcall ,jv ,ix ,@args))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun bake-off-jv (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-list-builder-v)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv lb 0 ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv lb 1)))))</font></div><div class=""><br class=""></div></div><div class="">Yech!… we need to know that function 0 is the APPEND-ITEM, and function 1 is the GET-LIST. But is it faster?</div><div class=""><br class=""></div><div class="">The median of 3 timings on 100M conses was 4.537s. So yes, it is about 2x faster than CLOS. Unless you have a strong need for speed, stick with CLOS.</div><div class=""><br class=""></div><div class="">—————————————————</div><div class="">Can we do any better than JV? What about skipping the internal dispatch lambda shown above, and just vectoring ourselves through the jump-vector?</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun make-list-builder-v2 ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; always in (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp;(vector #'append-item #'get)</span></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp;)))</font></div></div><div class=""><br class=""></div><div class="">and the bake-off code:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defmacro jv2 (jv ix &amp;rest args)</font></div><div class=""><font face="Monaco" class="">&nbsp; `(funcall (aref ,jv ,ix) ,@args))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun bake-off-jv2 (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-list-builder-v2)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv2 lb 0 ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv2 lb 1)))))</font></div><div class=""><br class=""></div></div><div class=""><br class=""></div><div class="">It’s timing showed a median of 3 of 2.527s. So yes, skipping the lambda dispatch is a speedup. Still…. hmmm….</div><div class="">———————————</div><div class="">Well, just for the heck of it, let’s see where a basic STRUCT implementation falls with CLOS and DLAMBDA…</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defstruct lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; cell)</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun lbs-set-cdr (lbs x)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lbs-cell)) lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><span style="font-family: Monaco;" class="">(defun lbs-append (lbs x)</span></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lbs-cell)) lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (lbs-set-cdr lbs (cons x (cdr cell)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun lbs-get (lbs)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lbs-cell)) lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (lbs-set-cdr lbs nil))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><br class=""></div></div><div class="">and its bake-off code:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-lbs (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lbs (make-lbs)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lbs-append lbs ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lbs-get lbs)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))</font></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">OMG!! It’s timing for 100M conses shows a median of 3 of 1.807s. Not only is this faster than both DLAMBDA and CLOS, but it is even faster than using jump-vectors !!!! What a surprise!</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div></div></div></blockquote></div><br class=""></div></div></blockquote></div><br class=""></div></div></div></blockquote></div><br class=""></div></div></div></blockquote></div><br class=""></div></div></div></blockquote></div><br class=""><div class="">
<div class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class="">--</span><br style="font-family: Menlo-Regular; font-size: 11px;" class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class="">Pascal Costanza</span><br style="font-family: Menlo-Regular; font-size: 11px;" class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class="">The views expressed in this email are my own, and not those of my employer.</span></div><div class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class=""><br class=""></span></div><br class="Apple-interchange-newline">

</div>


<br class=""></div></div></div></blockquote></div><br class=""></div></div></div></blockquote></div><br class=""></body></html>

                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: Speed of various implementation schemes...</h1><html><head><meta http-equiv="Content-Type" content="text/html charset=utf-8"></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">So now, I’m going back over DLAMBDA to see if some slight changes might make it much more acceptable. I certainly do appreciate its style in little cases like this.<div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><br class=""><div><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 11:26, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">Oooh! That’s very interesting!! Thanks so much.<div class=""><br class=""></div><div class="">I clearly need to learn to appreciate DECLARE much more than I currently do.</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 11:25, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">Oooh! That’s very interesting!! Thanks so much.<div class=""><br class=""></div><div class="">I clearly need to learn to appreciate DECLARE much more than I currently do.</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""><div class=""><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 11:07, Pascal Costanza &lt;<a href="mailto:pc@p-cos.net" class="">pc@p-cos.net</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">When you declare the local functions inline, the first version actually is the fastest.<div class=""><br class=""></div><div class=""><div class="">(defun bake-off-raw (ngrp)</div><div class="">&nbsp; (declare (optimize (speed 3) (safety 0) (debug 0) (space 0) (compilation-speed 0)))</div><div class="">&nbsp; (let (cell)</div><div class="">&nbsp; &nbsp; (labels ((set-cdr (x)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list ()</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</div><div class="">&nbsp; &nbsp; &nbsp; (declare (inline set-cdr append-time get-list))</div><div class="">&nbsp; &nbsp; &nbsp; (time (dotimes (g (* 1000 ngrp))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (append-item ix))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (get-list)))</div><div class="">&nbsp; &nbsp; &nbsp; )))</div></div><div class=""><br class=""></div><div class="">Pascal</div><div class=""><br class=""><div class=""><blockquote type="cite" class=""><div class="">On 11 Feb 2017, at 18:58, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">Looking at the disassembly, I see that the labels functions are being closed over on the stack, only on major entry. Not repeatedly.&nbsp;<div class=""><br class=""></div><div class="">However, APPEND-ITEM and GET-LIST, once closed over, also need to call the newly constructed closure for SET-CDR. And that is sitting on the stack as a freshly made closure. So the compiled code for APPEND-ITEM and GET-LIST need to call something that must be determined dynamically each time.</div><div class=""><br class=""></div><div class="">If I make SET-CDR depend on no free variables, then it can be succinctly encapsulated and never needs closing over on the stack. So this version also runs extremely quickly:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-raw3 (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; (let (cell)</span></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (cell x) <font color="#b92d5d" class="">;; &lt;— no free vars</font></font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr cell (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr cell nil))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (time (dotimes (g (* 1000 ngrp))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</span></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (append-item ix))</span></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (get-list)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div><div class=""><br class=""></div><div class="">The slowdown happens when there is mutual interaction among LABELS functions, and the called functions have free vars.</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 10:28, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">I suspected that the reason for the slowdown with the internal LABELS functions might be the fact that new closures are needed, at least once on major entry, because they all reference a free variable CELL.<div class=""><br class=""></div><div class="">So here is a version without needing closure creation:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-raw2 (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (declare (fixnum ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (cell x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (cell x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr cell (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr cell nil))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (time (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (declare (fixnum g))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (declare (fixnum ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (append-item cell ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (get-list cell)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div><div class=""><br class=""></div><div class="">And indeed, it is fastest of all, at 1.4 sec. That’s more like what I would have expected.</div><div class=""><br class=""></div><div class="">So it seems that we are constructing closures more than once, possibly in each iteration of the loop at the call site of APPEND-ITEM and GET-LIST.</div><div class=""><br class=""></div><div class="">Why would the compiler need to do that?</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 09:42, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">.. and to my shock, and horror!, it actually happens that using the embedded LABELS functions is even worse than using CLOS.<div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-raw (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (time (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (append-item ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (get-list)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">Median of 3 timings for (BAKE-OFF-RAW 100) &nbsp;[ 100M conses ] is 16.432 sec.&nbsp;</div><div class=""><br class=""></div><div class="">I couldn’t believe my eyes. There must be a mistake. I tried the BAKE-OFF-LBS (struct version) again to be sure. It still shows 1.8 sec. Then I tried BAKE-OFF-RAW yet again. Still 16 sec.&nbsp;</div><div class=""><br class=""></div><div class="">What’s going on here?</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 09:29, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">ummm… yes, my DLAMBDA timings incorrectly stated that 10 groups took 60+ seconds. It took 6+ seconds for 10 groups, and scaling to 100 groups would have been the stated 60+ seconds. Sorry… End results remain the same, just mis-stated the case.<div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 09:09, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class=""><div class="">Summary: Using basic STRUCT and direct function calls provides the fastest performing encapsulation of state and behavior. Significantly faster than CLOS, hugely faster than DLAMBDA, and even faster than using vectored function dispatch through a jump vector (!!).</div><div class=""><br class=""></div><div class="">Normalized Timings (2 sig figs, median of 3 meas):</div><div class=""><br class=""></div><div class="">STRUCT<span class="Apple-tab-span" style="white-space:pre">		</span>1.0</div><div class="">Jump Vector<span class="Apple-tab-span" style="white-space:pre">	</span>1.4</div><div class="">JV Dispatch<span class="Apple-tab-span" style="white-space:pre">	</span>2.5</div><div class="">CLOS<span class="Apple-tab-span" style="white-space:pre">		</span>5.0</div><div class="">DLAMBDA<span class="Apple-tab-span" style="white-space:pre">	</span>33</div><div class="">———————</div><div class=""><br class=""></div>From time to time, I make use of Doug Hoyte’s DLAMBDA to make little embedded-intelligence objects that don’t seem to deserve the greater complexity of CLOS. DLAMBDA has the nice trait that it keeps message code adjacent to object state, rather than spreading it all out the way CLOS does. But I’m also a big fan of CLOS - don’t get me wrong.<div class=""><br class=""></div><div class="">But just for curiosity, I wanted to see what the performance overhead on DLAMBDA is. And once I saw that, compared to CLOS, I began looking for what is the fastest possible implementation (apart from coding in Assembly language…). Let’s keep this all in Lisp.</div><div class=""><br class=""></div><div class="">As a simple test, I needed a fast list constructor that could keep items in LIFO order, and provide a fast O(1) append of each additional item as they become available. I initially set this up using internal LABEL functions, and it worked very well. And it also turned out to be useful in several other places. So I decided to package it up for myself and keep the implementation in one place, instead of replicating it all over the place — the usual reason for packaging up state and behavior into objects.</div><div class=""><br class=""></div><div class="">So here is an example of the original code:</div><div class=""><br class=""></div><div class=""><div class=""><div class=""><font face="Monaco" class="">(defun collect-&gt; (pred start until-fn succ-fn</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;key</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(key &nbsp; &nbsp;#'identity)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(map-fn #'identity))</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (do ((x &nbsp; start &nbsp; (funcall succ-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((funcall until-fn x) (get-list))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (when (funcall pred (funcall key x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (append-item (funcall map-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</font></div></div></div><div class=""><br class=""></div><div class="">#F is a reader macro meaning (DECLARE (OPTIMIZE (SPEED 3) (SAFETY 0) (FLOAT 0)).</div><div class=""><br class=""></div><div class="">This code offers an O(1) FIFO list construction, for items from some collection START which satisfy some predicate PRED (using key function KEY), and which collects some mapped representation (MAP-FN) of the qualified items. Pretty simple.</div><div class=""><br class=""></div><div class="">It is that collection of 3 functions inside the LABELS clause that I want to package up. No clients need to know about the internal workings and state of the list constructor object. They just need to be able to instantiate such a constructor, call APPEND-ITEM on each value they want collected, and GET-LIST at the end to get their collected results.&nbsp;</div><div class=""><br class=""></div><div class="">They don’t need to know anything about the CELL, nor the SET-CDR mechanism, which together manages a list by tracking the tail cell of a circular list. The head of the accumulating list is always pointed to by the (CDR CELL). At the end, when they want the result, we need to furnish the head of the accumulated list, and null out the cdr of the last cons cell. Perfect conditions for an encapsulated object implementation.</div><div class=""><br class=""></div><div class="">So here is the first version of encapsulation done with DLAMBDA:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun make-list-builder ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; always in (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (dlambda</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (:append (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (:get ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil)))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</span></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">and here is the corresponding rewrite of COLLECT-&gt;:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun collect-&gt; (pred start until-fn succ-fn</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;key</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(key &nbsp; &nbsp;#'identity)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(map-fn #'identity))</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let ((lb (make-list-builder)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (do ((x &nbsp;start &nbsp;(funcall succ-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ((funcall until-fn x) (funcall lb :get))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (when (funcall pred (funcall key x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (funcall lb :append (funcall map-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div></div><div class=""><br class=""></div><div class="">DLAMBDA is sensitive to the ordering of the message responders, so I placed :APPEND first.</div><div class=""><br class=""></div><div class="">Okay, so now let’s do some timings. I want to measure realistic applications of the list builder, not making lists of hundreds of millions of items, but perhaps a thousand items, done over and over again. To get some realistic durations, we need to execute a few million times. So here is the template of our timing tests:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-dlambda (ngrp) ;; 1 grp = 1000 times of 1000-element lists</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-list-builder)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (funcall lb :append ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (funcall lb :get)))))</font></div><div class=""><br class=""></div></div><div class="">When I execute this bake-off code for 10 groups (10,000,000 conses) I got a median of 3 measurement of 60.38 sec. under LWM 7/64 on a Mac Mini (Late 2014) running OS X Sierra 10.12.3, and nothing much else happening in the machine.</div><div class="">———————————————</div><div class=""><br class=""></div><div class="">So let’s look at a CLOS implementation. Sadly, to me, this takes all that encapsulation and scatters it to the wind.</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defclass list-builder ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ((cell &nbsp;:accessor lb-cell &nbsp;:initform nil)))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defmethod lb-set-cdr ((lb list-builder) x)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lb-cell)) lb</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (setf cell (setf (cdr xcell) x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defmethod lb-append ((lb list-builder) x)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lb-cell)) lb</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (lb-set-cdr lb (cons x (cdr cell)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defmethod lb-get ((lb list-builder))</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lb-cell)) lb</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (lb-set-cdr lb nil))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">Its bake-off code looks like this:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-clos (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-instance 'list-builder)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lb-append lb ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lb-get lb)))))</font></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">And its median of 3 for 100 groups of 1M conses showed a timing of 8.952 sec. Note that this was for 10x as many conses as we used when timing the DLAMBDA implementation. In other words, CLOS is nearly 6x faster than DLAMBA. (That’s close enough for Astronomical accuracy to call it 10x faster).&nbsp;</div><div class=""><br class=""></div><div class="">This is very surprising!! At least to me… and it shows that LW has spent some effort to make CLOS efficient. A tip of the hat to them!</div><div class=""><br class=""></div><div class="">————————</div><div class="">Okay… what’s faster than all this so far? What about a jump vector dispatching to internal LABEL functions?</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun make-list-builder-v ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; always in (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp; (let ((jv (vector #'append-item #'get)))</span></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (lambda (ix &amp;rest args)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (apply (aref jv ix) args))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</font></div><div class=""><br class=""></div></div><div class=""><br class=""></div><div class="">And here is the bake-off code:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defmacro jv (jv ix &amp;rest args)</font></div><div class=""><font face="Monaco" class="">&nbsp; `(funcall ,jv ,ix ,@args))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun bake-off-jv (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-list-builder-v)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv lb 0 ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv lb 1)))))</font></div><div class=""><br class=""></div></div><div class="">Yech!… we need to know that function 0 is the APPEND-ITEM, and function 1 is the GET-LIST. But is it faster?</div><div class=""><br class=""></div><div class="">The median of 3 timings on 100M conses was 4.537s. So yes, it is about 2x faster than CLOS. Unless you have a strong need for speed, stick with CLOS.</div><div class=""><br class=""></div><div class="">—————————————————</div><div class="">Can we do any better than JV? What about skipping the internal dispatch lambda shown above, and just vectoring ourselves through the jump-vector?</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun make-list-builder-v2 ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; always in (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp;(vector #'append-item #'get)</span></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp;)))</font></div></div><div class=""><br class=""></div><div class="">and the bake-off code:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defmacro jv2 (jv ix &amp;rest args)</font></div><div class=""><font face="Monaco" class="">&nbsp; `(funcall (aref ,jv ,ix) ,@args))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun bake-off-jv2 (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-list-builder-v2)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv2 lb 0 ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv2 lb 1)))))</font></div><div class=""><br class=""></div></div><div class=""><br class=""></div><div class="">It’s timing showed a median of 3 of 2.527s. So yes, skipping the lambda dispatch is a speedup. Still…. hmmm….</div><div class="">———————————</div><div class="">Well, just for the heck of it, let’s see where a basic STRUCT implementation falls with CLOS and DLAMBDA…</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defstruct lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; cell)</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun lbs-set-cdr (lbs x)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lbs-cell)) lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><span style="font-family: Monaco;" class="">(defun lbs-append (lbs x)</span></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lbs-cell)) lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (lbs-set-cdr lbs (cons x (cdr cell)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun lbs-get (lbs)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lbs-cell)) lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (lbs-set-cdr lbs nil))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><br class=""></div></div><div class="">and its bake-off code:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-lbs (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lbs (make-lbs)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lbs-append lbs ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lbs-get lbs)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))</font></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">OMG!! It’s timing for 100M conses shows a median of 3 of 1.807s. Not only is this faster than both DLAMBDA and CLOS, but it is even faster than using jump-vectors !!!! What a surprise!</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div></div></div></blockquote></div><br class=""></div></div></blockquote></div><br class=""></div></div></div></blockquote></div><br class=""></div></div></div></blockquote></div><br class=""></div></div></div></blockquote></div><br class=""><div class="">
<div class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class="">--</span><br style="font-family: Menlo-Regular; font-size: 11px;" class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class="">Pascal Costanza</span><br style="font-family: Menlo-Regular; font-size: 11px;" class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class="">The views expressed in this email are my own, and not those of my employer.</span></div><div class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class=""><br class=""></span></div><br class="Apple-interchange-newline">

</div>


<br class=""></div></div></div></blockquote></div><br class=""></div></div></div></blockquote></div><br class=""></div></div></blockquote></div><br class=""></div></body></html>

                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: Speed of various implementation schemes...</h1><html><head><meta http-equiv="Content-Type" content="text/html charset=utf-8"></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">This version of the jump vector approach seems to give the best performance on my machine:<div class=""><br class=""></div><div class=""><div class="">(defun make-list-builder-v ()</div><div class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</div><div class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</div><div class="">&nbsp; ;; always in (cdr cell)</div><div class="">&nbsp; (declare (optimize (speed 3) (space 0) (safety 0) (debug 0) (compilation-speed 0)))</div><div class="">&nbsp; (let (cell)</div><div class="">&nbsp; &nbsp; (labels ((set-cdr (x)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get ()</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</div><div class="">&nbsp; &nbsp; &nbsp; (declare (inline set-cdr append-item get))</div><div class="">&nbsp; &nbsp; &nbsp; (let ((jv (vector #'append-item #'get)))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; (declare ((simple-array function (2)) jv))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; (lambda (ix &amp;rest args)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (apply (aref jv ix) args))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</div><div class=""><br class=""></div><div class="">(defmacro jv (jv ix &amp;rest args)</div><div class="">&nbsp; `(funcall ,jv ,ix ,@args))</div><div class=""><br class=""></div><div class="">(defun bake-off-jv (ngrp)</div><div class="">&nbsp; (time (let ((lb (make-list-builder-v)))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv lb 0 ix))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv lb 1)))))</div></div><div class=""><br class=""></div><div class="">Pascal</div><div class=""><br class=""><div><blockquote type="cite" class=""><div class="">On 11 Feb 2017, at 19:28, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">So now, I’m going back over DLAMBDA to see if some slight changes might make it much more acceptable. I certainly do appreciate its style in little cases like this.<div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><br class=""><div class=""><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 11:26, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">Oooh! That’s very interesting!! Thanks so much.<div class=""><br class=""></div><div class="">I clearly need to learn to appreciate DECLARE much more than I currently do.</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 11:25, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">Oooh! That’s very interesting!! Thanks so much.<div class=""><br class=""></div><div class="">I clearly need to learn to appreciate DECLARE much more than I currently do.</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""><div class=""><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 11:07, Pascal Costanza &lt;<a href="mailto:pc@p-cos.net" class="">pc@p-cos.net</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">When you declare the local functions inline, the first version actually is the fastest.<div class=""><br class=""></div><div class=""><div class="">(defun bake-off-raw (ngrp)</div><div class="">&nbsp; (declare (optimize (speed 3) (safety 0) (debug 0) (space 0) (compilation-speed 0)))</div><div class="">&nbsp; (let (cell)</div><div class="">&nbsp; &nbsp; (labels ((set-cdr (x)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list ()</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</div><div class="">&nbsp; &nbsp; &nbsp; (declare (inline set-cdr append-time get-list))</div><div class="">&nbsp; &nbsp; &nbsp; (time (dotimes (g (* 1000 ngrp))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (append-item ix))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (get-list)))</div><div class="">&nbsp; &nbsp; &nbsp; )))</div></div><div class=""><br class=""></div><div class="">Pascal</div><div class=""><br class=""><div class=""><blockquote type="cite" class=""><div class="">On 11 Feb 2017, at 18:58, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">Looking at the disassembly, I see that the labels functions are being closed over on the stack, only on major entry. Not repeatedly.&nbsp;<div class=""><br class=""></div><div class="">However, APPEND-ITEM and GET-LIST, once closed over, also need to call the newly constructed closure for SET-CDR. And that is sitting on the stack as a freshly made closure. So the compiled code for APPEND-ITEM and GET-LIST need to call something that must be determined dynamically each time.</div><div class=""><br class=""></div><div class="">If I make SET-CDR depend on no free variables, then it can be succinctly encapsulated and never needs closing over on the stack. So this version also runs extremely quickly:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-raw3 (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; (let (cell)</span></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (cell x) <font color="#b92d5d" class="">;; &lt;— no free vars</font></font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr cell (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr cell nil))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (time (dotimes (g (* 1000 ngrp))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</span></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (append-item ix))</span></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (get-list)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div><div class=""><br class=""></div><div class="">The slowdown happens when there is mutual interaction among LABELS functions, and the called functions have free vars.</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 10:28, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">I suspected that the reason for the slowdown with the internal LABELS functions might be the fact that new closures are needed, at least once on major entry, because they all reference a free variable CELL.<div class=""><br class=""></div><div class="">So here is a version without needing closure creation:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-raw2 (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (declare (fixnum ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (cell x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (cell x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr cell (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr cell nil))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (time (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (declare (fixnum g))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (declare (fixnum ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (append-item cell ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (get-list cell)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div><div class=""><br class=""></div><div class="">And indeed, it is fastest of all, at 1.4 sec. That’s more like what I would have expected.</div><div class=""><br class=""></div><div class="">So it seems that we are constructing closures more than once, possibly in each iteration of the loop at the call site of APPEND-ITEM and GET-LIST.</div><div class=""><br class=""></div><div class="">Why would the compiler need to do that?</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 09:42, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">.. and to my shock, and horror!, it actually happens that using the embedded LABELS functions is even worse than using CLOS.<div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-raw (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (time (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (append-item ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (get-list)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">Median of 3 timings for (BAKE-OFF-RAW 100) &nbsp;[ 100M conses ] is 16.432 sec.&nbsp;</div><div class=""><br class=""></div><div class="">I couldn’t believe my eyes. There must be a mistake. I tried the BAKE-OFF-LBS (struct version) again to be sure. It still shows 1.8 sec. Then I tried BAKE-OFF-RAW yet again. Still 16 sec.&nbsp;</div><div class=""><br class=""></div><div class="">What’s going on here?</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 09:29, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">ummm… yes, my DLAMBDA timings incorrectly stated that 10 groups took 60+ seconds. It took 6+ seconds for 10 groups, and scaling to 100 groups would have been the stated 60+ seconds. Sorry… End results remain the same, just mis-stated the case.<div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 09:09, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class=""><div class="">Summary: Using basic STRUCT and direct function calls provides the fastest performing encapsulation of state and behavior. Significantly faster than CLOS, hugely faster than DLAMBDA, and even faster than using vectored function dispatch through a jump vector (!!).</div><div class=""><br class=""></div><div class="">Normalized Timings (2 sig figs, median of 3 meas):</div><div class=""><br class=""></div><div class="">STRUCT<span class="Apple-tab-span" style="white-space:pre">		</span>1.0</div><div class="">Jump Vector<span class="Apple-tab-span" style="white-space:pre">	</span>1.4</div><div class="">JV Dispatch<span class="Apple-tab-span" style="white-space:pre">	</span>2.5</div><div class="">CLOS<span class="Apple-tab-span" style="white-space:pre">		</span>5.0</div><div class="">DLAMBDA<span class="Apple-tab-span" style="white-space:pre">	</span>33</div><div class="">———————</div><div class=""><br class=""></div>From time to time, I make use of Doug Hoyte’s DLAMBDA to make little embedded-intelligence objects that don’t seem to deserve the greater complexity of CLOS. DLAMBDA has the nice trait that it keeps message code adjacent to object state, rather than spreading it all out the way CLOS does. But I’m also a big fan of CLOS - don’t get me wrong.<div class=""><br class=""></div><div class="">But just for curiosity, I wanted to see what the performance overhead on DLAMBDA is. And once I saw that, compared to CLOS, I began looking for what is the fastest possible implementation (apart from coding in Assembly language…). Let’s keep this all in Lisp.</div><div class=""><br class=""></div><div class="">As a simple test, I needed a fast list constructor that could keep items in LIFO order, and provide a fast O(1) append of each additional item as they become available. I initially set this up using internal LABEL functions, and it worked very well. And it also turned out to be useful in several other places. So I decided to package it up for myself and keep the implementation in one place, instead of replicating it all over the place — the usual reason for packaging up state and behavior into objects.</div><div class=""><br class=""></div><div class="">So here is an example of the original code:</div><div class=""><br class=""></div><div class=""><div class=""><div class=""><font face="Monaco" class="">(defun collect-&gt; (pred start until-fn succ-fn</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;key</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(key &nbsp; &nbsp;#'identity)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(map-fn #'identity))</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (do ((x &nbsp; start &nbsp; (funcall succ-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((funcall until-fn x) (get-list))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (when (funcall pred (funcall key x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (append-item (funcall map-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</font></div></div></div><div class=""><br class=""></div><div class="">#F is a reader macro meaning (DECLARE (OPTIMIZE (SPEED 3) (SAFETY 0) (FLOAT 0)).</div><div class=""><br class=""></div><div class="">This code offers an O(1) FIFO list construction, for items from some collection START which satisfy some predicate PRED (using key function KEY), and which collects some mapped representation (MAP-FN) of the qualified items. Pretty simple.</div><div class=""><br class=""></div><div class="">It is that collection of 3 functions inside the LABELS clause that I want to package up. No clients need to know about the internal workings and state of the list constructor object. They just need to be able to instantiate such a constructor, call APPEND-ITEM on each value they want collected, and GET-LIST at the end to get their collected results.&nbsp;</div><div class=""><br class=""></div><div class="">They don’t need to know anything about the CELL, nor the SET-CDR mechanism, which together manages a list by tracking the tail cell of a circular list. The head of the accumulating list is always pointed to by the (CDR CELL). At the end, when they want the result, we need to furnish the head of the accumulated list, and null out the cdr of the last cons cell. Perfect conditions for an encapsulated object implementation.</div><div class=""><br class=""></div><div class="">So here is the first version of encapsulation done with DLAMBDA:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun make-list-builder ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; always in (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (dlambda</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (:append (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (:get ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil)))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</span></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">and here is the corresponding rewrite of COLLECT-&gt;:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun collect-&gt; (pred start until-fn succ-fn</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;key</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(key &nbsp; &nbsp;#'identity)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(map-fn #'identity))</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let ((lb (make-list-builder)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (do ((x &nbsp;start &nbsp;(funcall succ-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ((funcall until-fn x) (funcall lb :get))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (when (funcall pred (funcall key x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (funcall lb :append (funcall map-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div></div><div class=""><br class=""></div><div class="">DLAMBDA is sensitive to the ordering of the message responders, so I placed :APPEND first.</div><div class=""><br class=""></div><div class="">Okay, so now let’s do some timings. I want to measure realistic applications of the list builder, not making lists of hundreds of millions of items, but perhaps a thousand items, done over and over again. To get some realistic durations, we need to execute a few million times. So here is the template of our timing tests:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-dlambda (ngrp) ;; 1 grp = 1000 times of 1000-element lists</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-list-builder)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (funcall lb :append ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (funcall lb :get)))))</font></div><div class=""><br class=""></div></div><div class="">When I execute this bake-off code for 10 groups (10,000,000 conses) I got a median of 3 measurement of 60.38 sec. under LWM 7/64 on a Mac Mini (Late 2014) running OS X Sierra 10.12.3, and nothing much else happening in the machine.</div><div class="">———————————————</div><div class=""><br class=""></div><div class="">So let’s look at a CLOS implementation. Sadly, to me, this takes all that encapsulation and scatters it to the wind.</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defclass list-builder ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ((cell &nbsp;:accessor lb-cell &nbsp;:initform nil)))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defmethod lb-set-cdr ((lb list-builder) x)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lb-cell)) lb</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (setf cell (setf (cdr xcell) x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defmethod lb-append ((lb list-builder) x)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lb-cell)) lb</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (lb-set-cdr lb (cons x (cdr cell)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defmethod lb-get ((lb list-builder))</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lb-cell)) lb</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (lb-set-cdr lb nil))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">Its bake-off code looks like this:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-clos (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-instance 'list-builder)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lb-append lb ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lb-get lb)))))</font></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">And its median of 3 for 100 groups of 1M conses showed a timing of 8.952 sec. Note that this was for 10x as many conses as we used when timing the DLAMBDA implementation. In other words, CLOS is nearly 6x faster than DLAMBA. (That’s close enough for Astronomical accuracy to call it 10x faster).&nbsp;</div><div class=""><br class=""></div><div class="">This is very surprising!! At least to me… and it shows that LW has spent some effort to make CLOS efficient. A tip of the hat to them!</div><div class=""><br class=""></div><div class="">————————</div><div class="">Okay… what’s faster than all this so far? What about a jump vector dispatching to internal LABEL functions?</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun make-list-builder-v ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; always in (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp; (let ((jv (vector #'append-item #'get)))</span></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (lambda (ix &amp;rest args)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (apply (aref jv ix) args))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</font></div><div class=""><br class=""></div></div><div class=""><br class=""></div><div class="">And here is the bake-off code:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defmacro jv (jv ix &amp;rest args)</font></div><div class=""><font face="Monaco" class="">&nbsp; `(funcall ,jv ,ix ,@args))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun bake-off-jv (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-list-builder-v)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv lb 0 ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv lb 1)))))</font></div><div class=""><br class=""></div></div><div class="">Yech!… we need to know that function 0 is the APPEND-ITEM, and function 1 is the GET-LIST. But is it faster?</div><div class=""><br class=""></div><div class="">The median of 3 timings on 100M conses was 4.537s. So yes, it is about 2x faster than CLOS. Unless you have a strong need for speed, stick with CLOS.</div><div class=""><br class=""></div><div class="">—————————————————</div><div class="">Can we do any better than JV? What about skipping the internal dispatch lambda shown above, and just vectoring ourselves through the jump-vector?</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun make-list-builder-v2 ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; always in (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp;(vector #'append-item #'get)</span></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp;)))</font></div></div><div class=""><br class=""></div><div class="">and the bake-off code:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defmacro jv2 (jv ix &amp;rest args)</font></div><div class=""><font face="Monaco" class="">&nbsp; `(funcall (aref ,jv ,ix) ,@args))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun bake-off-jv2 (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-list-builder-v2)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv2 lb 0 ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv2 lb 1)))))</font></div><div class=""><br class=""></div></div><div class=""><br class=""></div><div class="">It’s timing showed a median of 3 of 2.527s. So yes, skipping the lambda dispatch is a speedup. Still…. hmmm….</div><div class="">———————————</div><div class="">Well, just for the heck of it, let’s see where a basic STRUCT implementation falls with CLOS and DLAMBDA…</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defstruct lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; cell)</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun lbs-set-cdr (lbs x)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lbs-cell)) lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><span style="font-family: Monaco;" class="">(defun lbs-append (lbs x)</span></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lbs-cell)) lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (lbs-set-cdr lbs (cons x (cdr cell)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun lbs-get (lbs)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lbs-cell)) lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (lbs-set-cdr lbs nil))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><br class=""></div></div><div class="">and its bake-off code:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-lbs (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lbs (make-lbs)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lbs-append lbs ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lbs-get lbs)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))</font></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">OMG!! It’s timing for 100M conses shows a median of 3 of 1.807s. Not only is this faster than both DLAMBDA and CLOS, but it is even faster than using jump-vectors !!!! What a surprise!</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div></div></div></blockquote></div><br class=""></div></div></blockquote></div><br class=""></div></div></div></blockquote></div><br class=""></div></div></div></blockquote></div><br class=""></div></div></div></blockquote></div><br class=""><div class="">
<div class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class="">--</span><br style="font-family: Menlo-Regular; font-size: 11px;" class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class="">Pascal Costanza</span><br style="font-family: Menlo-Regular; font-size: 11px;" class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class="">The views expressed in this email are my own, and not those of my employer.</span></div><div class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class=""><br class=""></span></div><br class="Apple-interchange-newline">

</div>


<br class=""></div></div></div></blockquote></div><br class=""></div></div></div></blockquote></div><br class=""></div></div></blockquote></div><br class=""></div></div></div></blockquote></div><br class=""><div class="">
<div class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class="">--</span><br style="font-family: Menlo-Regular; font-size: 11px;" class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class="">Pascal Costanza</span><br style="font-family: Menlo-Regular; font-size: 11px;" class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class="">The views expressed in this email are my own, and not those of my employer.</span></div><div class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class=""><br class=""></span></div><br class="Apple-interchange-newline">

</div>


<br class=""></div></body></html>

                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: Speed of various implementation schemes...</h1><html><head><meta http-equiv="Content-Type" content="text/html charset=utf-8"></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">Well, if I can modify DLAMBA to use Jump Vectors, then I will. But if I have to know a cardinal index in order to call a function, then I might as well hang it up and go to work for Apple...<div class=""><br class=""></div><div class="">But offhand, just reframing the DLAMBDA like this, brings down the time from 60+ sec to 4.5 sec:<div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun make-list-builder ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; always in (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(reset-list (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell nil)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (list x))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; <font color="#b92d5d" class="">(declare (inline set-cdr append-item get-list reset-list))</font></font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (let ((alst (list (cons :append #'append-item)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (cons :get &nbsp; &nbsp;#'get-list)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (cons :reset &nbsp;#'reset-list))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (lambda (sel &amp;rest args)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (apply (cdr (assoc sel alst)) args))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</font></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 11:39, Pascal Costanza &lt;<a href="mailto:pc@p-cos.net" class="">pc@p-cos.net</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">This version of the jump vector approach seems to give the best performance on my machine:<div class=""><br class=""></div><div class=""><div class="">(defun make-list-builder-v ()</div><div class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</div><div class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</div><div class="">&nbsp; ;; always in (cdr cell)</div><div class="">&nbsp; (declare (optimize (speed 3) (space 0) (safety 0) (debug 0) (compilation-speed 0)))</div><div class="">&nbsp; (let (cell)</div><div class="">&nbsp; &nbsp; (labels ((set-cdr (x)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get ()</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</div><div class="">&nbsp; &nbsp; &nbsp; (declare (inline set-cdr append-item get))</div><div class="">&nbsp; &nbsp; &nbsp; (let ((jv (vector #'append-item #'get)))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; (declare ((simple-array function (2)) jv))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; (lambda (ix &amp;rest args)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (apply (aref jv ix) args))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</div><div class=""><br class=""></div><div class="">(defmacro jv (jv ix &amp;rest args)</div><div class="">&nbsp; `(funcall ,jv ,ix ,@args))</div><div class=""><br class=""></div><div class="">(defun bake-off-jv (ngrp)</div><div class="">&nbsp; (time (let ((lb (make-list-builder-v)))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv lb 0 ix))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv lb 1)))))</div></div><div class=""><br class=""></div><div class="">Pascal</div><div class=""><br class=""><div class=""><blockquote type="cite" class=""><div class="">On 11 Feb 2017, at 19:28, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">So now, I’m going back over DLAMBDA to see if some slight changes might make it much more acceptable. I certainly do appreciate its style in little cases like this.<div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><br class=""><div class=""><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 11:26, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">Oooh! That’s very interesting!! Thanks so much.<div class=""><br class=""></div><div class="">I clearly need to learn to appreciate DECLARE much more than I currently do.</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 11:25, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">Oooh! That’s very interesting!! Thanks so much.<div class=""><br class=""></div><div class="">I clearly need to learn to appreciate DECLARE much more than I currently do.</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""><div class=""><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 11:07, Pascal Costanza &lt;<a href="mailto:pc@p-cos.net" class="">pc@p-cos.net</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">When you declare the local functions inline, the first version actually is the fastest.<div class=""><br class=""></div><div class=""><div class="">(defun bake-off-raw (ngrp)</div><div class="">&nbsp; (declare (optimize (speed 3) (safety 0) (debug 0) (space 0) (compilation-speed 0)))</div><div class="">&nbsp; (let (cell)</div><div class="">&nbsp; &nbsp; (labels ((set-cdr (x)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list ()</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</div><div class="">&nbsp; &nbsp; &nbsp; (declare (inline set-cdr append-time get-list))</div><div class="">&nbsp; &nbsp; &nbsp; (time (dotimes (g (* 1000 ngrp))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (append-item ix))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (get-list)))</div><div class="">&nbsp; &nbsp; &nbsp; )))</div></div><div class=""><br class=""></div><div class="">Pascal</div><div class=""><br class=""><div class=""><blockquote type="cite" class=""><div class="">On 11 Feb 2017, at 18:58, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">Looking at the disassembly, I see that the labels functions are being closed over on the stack, only on major entry. Not repeatedly.&nbsp;<div class=""><br class=""></div><div class="">However, APPEND-ITEM and GET-LIST, once closed over, also need to call the newly constructed closure for SET-CDR. And that is sitting on the stack as a freshly made closure. So the compiled code for APPEND-ITEM and GET-LIST need to call something that must be determined dynamically each time.</div><div class=""><br class=""></div><div class="">If I make SET-CDR depend on no free variables, then it can be succinctly encapsulated and never needs closing over on the stack. So this version also runs extremely quickly:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-raw3 (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; (let (cell)</span></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (cell x) <font color="#b92d5d" class="">;; &lt;— no free vars</font></font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr cell (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr cell nil))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (time (dotimes (g (* 1000 ngrp))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</span></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (append-item ix))</span></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (get-list)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div><div class=""><br class=""></div><div class="">The slowdown happens when there is mutual interaction among LABELS functions, and the called functions have free vars.</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 10:28, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">I suspected that the reason for the slowdown with the internal LABELS functions might be the fact that new closures are needed, at least once on major entry, because they all reference a free variable CELL.<div class=""><br class=""></div><div class="">So here is a version without needing closure creation:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-raw2 (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (declare (fixnum ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (cell x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (cell x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr cell (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr cell nil))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (time (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (declare (fixnum g))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (declare (fixnum ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (append-item cell ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (get-list cell)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div><div class=""><br class=""></div><div class="">And indeed, it is fastest of all, at 1.4 sec. That’s more like what I would have expected.</div><div class=""><br class=""></div><div class="">So it seems that we are constructing closures more than once, possibly in each iteration of the loop at the call site of APPEND-ITEM and GET-LIST.</div><div class=""><br class=""></div><div class="">Why would the compiler need to do that?</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 09:42, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">.. and to my shock, and horror!, it actually happens that using the embedded LABELS functions is even worse than using CLOS.<div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-raw (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (time (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (append-item ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (get-list)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">Median of 3 timings for (BAKE-OFF-RAW 100) &nbsp;[ 100M conses ] is 16.432 sec.&nbsp;</div><div class=""><br class=""></div><div class="">I couldn’t believe my eyes. There must be a mistake. I tried the BAKE-OFF-LBS (struct version) again to be sure. It still shows 1.8 sec. Then I tried BAKE-OFF-RAW yet again. Still 16 sec.&nbsp;</div><div class=""><br class=""></div><div class="">What’s going on here?</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 09:29, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">ummm… yes, my DLAMBDA timings incorrectly stated that 10 groups took 60+ seconds. It took 6+ seconds for 10 groups, and scaling to 100 groups would have been the stated 60+ seconds. Sorry… End results remain the same, just mis-stated the case.<div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 09:09, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class=""><div class="">Summary: Using basic STRUCT and direct function calls provides the fastest performing encapsulation of state and behavior. Significantly faster than CLOS, hugely faster than DLAMBDA, and even faster than using vectored function dispatch through a jump vector (!!).</div><div class=""><br class=""></div><div class="">Normalized Timings (2 sig figs, median of 3 meas):</div><div class=""><br class=""></div><div class="">STRUCT<span class="Apple-tab-span" style="white-space:pre">		</span>1.0</div><div class="">Jump Vector<span class="Apple-tab-span" style="white-space:pre">	</span>1.4</div><div class="">JV Dispatch<span class="Apple-tab-span" style="white-space:pre">	</span>2.5</div><div class="">CLOS<span class="Apple-tab-span" style="white-space:pre">		</span>5.0</div><div class="">DLAMBDA<span class="Apple-tab-span" style="white-space:pre">	</span>33</div><div class="">———————</div><div class=""><br class=""></div>From time to time, I make use of Doug Hoyte’s DLAMBDA to make little embedded-intelligence objects that don’t seem to deserve the greater complexity of CLOS. DLAMBDA has the nice trait that it keeps message code adjacent to object state, rather than spreading it all out the way CLOS does. But I’m also a big fan of CLOS - don’t get me wrong.<div class=""><br class=""></div><div class="">But just for curiosity, I wanted to see what the performance overhead on DLAMBDA is. And once I saw that, compared to CLOS, I began looking for what is the fastest possible implementation (apart from coding in Assembly language…). Let’s keep this all in Lisp.</div><div class=""><br class=""></div><div class="">As a simple test, I needed a fast list constructor that could keep items in LIFO order, and provide a fast O(1) append of each additional item as they become available. I initially set this up using internal LABEL functions, and it worked very well. And it also turned out to be useful in several other places. So I decided to package it up for myself and keep the implementation in one place, instead of replicating it all over the place — the usual reason for packaging up state and behavior into objects.</div><div class=""><br class=""></div><div class="">So here is an example of the original code:</div><div class=""><br class=""></div><div class=""><div class=""><div class=""><font face="Monaco" class="">(defun collect-&gt; (pred start until-fn succ-fn</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;key</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(key &nbsp; &nbsp;#'identity)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(map-fn #'identity))</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (do ((x &nbsp; start &nbsp; (funcall succ-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((funcall until-fn x) (get-list))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (when (funcall pred (funcall key x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (append-item (funcall map-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</font></div></div></div><div class=""><br class=""></div><div class="">#F is a reader macro meaning (DECLARE (OPTIMIZE (SPEED 3) (SAFETY 0) (FLOAT 0)).</div><div class=""><br class=""></div><div class="">This code offers an O(1) FIFO list construction, for items from some collection START which satisfy some predicate PRED (using key function KEY), and which collects some mapped representation (MAP-FN) of the qualified items. Pretty simple.</div><div class=""><br class=""></div><div class="">It is that collection of 3 functions inside the LABELS clause that I want to package up. No clients need to know about the internal workings and state of the list constructor object. They just need to be able to instantiate such a constructor, call APPEND-ITEM on each value they want collected, and GET-LIST at the end to get their collected results.&nbsp;</div><div class=""><br class=""></div><div class="">They don’t need to know anything about the CELL, nor the SET-CDR mechanism, which together manages a list by tracking the tail cell of a circular list. The head of the accumulating list is always pointed to by the (CDR CELL). At the end, when they want the result, we need to furnish the head of the accumulated list, and null out the cdr of the last cons cell. Perfect conditions for an encapsulated object implementation.</div><div class=""><br class=""></div><div class="">So here is the first version of encapsulation done with DLAMBDA:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun make-list-builder ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; always in (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (dlambda</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (:append (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (:get ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil)))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</span></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">and here is the corresponding rewrite of COLLECT-&gt;:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun collect-&gt; (pred start until-fn succ-fn</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;key</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(key &nbsp; &nbsp;#'identity)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(map-fn #'identity))</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let ((lb (make-list-builder)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (do ((x &nbsp;start &nbsp;(funcall succ-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ((funcall until-fn x) (funcall lb :get))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (when (funcall pred (funcall key x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (funcall lb :append (funcall map-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div></div><div class=""><br class=""></div><div class="">DLAMBDA is sensitive to the ordering of the message responders, so I placed :APPEND first.</div><div class=""><br class=""></div><div class="">Okay, so now let’s do some timings. I want to measure realistic applications of the list builder, not making lists of hundreds of millions of items, but perhaps a thousand items, done over and over again. To get some realistic durations, we need to execute a few million times. So here is the template of our timing tests:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-dlambda (ngrp) ;; 1 grp = 1000 times of 1000-element lists</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-list-builder)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (funcall lb :append ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (funcall lb :get)))))</font></div><div class=""><br class=""></div></div><div class="">When I execute this bake-off code for 10 groups (10,000,000 conses) I got a median of 3 measurement of 60.38 sec. under LWM 7/64 on a Mac Mini (Late 2014) running OS X Sierra 10.12.3, and nothing much else happening in the machine.</div><div class="">———————————————</div><div class=""><br class=""></div><div class="">So let’s look at a CLOS implementation. Sadly, to me, this takes all that encapsulation and scatters it to the wind.</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defclass list-builder ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ((cell &nbsp;:accessor lb-cell &nbsp;:initform nil)))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defmethod lb-set-cdr ((lb list-builder) x)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lb-cell)) lb</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (setf cell (setf (cdr xcell) x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defmethod lb-append ((lb list-builder) x)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lb-cell)) lb</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (lb-set-cdr lb (cons x (cdr cell)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defmethod lb-get ((lb list-builder))</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lb-cell)) lb</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (lb-set-cdr lb nil))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">Its bake-off code looks like this:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-clos (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-instance 'list-builder)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lb-append lb ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lb-get lb)))))</font></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">And its median of 3 for 100 groups of 1M conses showed a timing of 8.952 sec. Note that this was for 10x as many conses as we used when timing the DLAMBDA implementation. In other words, CLOS is nearly 6x faster than DLAMBA. (That’s close enough for Astronomical accuracy to call it 10x faster).&nbsp;</div><div class=""><br class=""></div><div class="">This is very surprising!! At least to me… and it shows that LW has spent some effort to make CLOS efficient. A tip of the hat to them!</div><div class=""><br class=""></div><div class="">————————</div><div class="">Okay… what’s faster than all this so far? What about a jump vector dispatching to internal LABEL functions?</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun make-list-builder-v ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; always in (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp; (let ((jv (vector #'append-item #'get)))</span></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (lambda (ix &amp;rest args)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (apply (aref jv ix) args))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</font></div><div class=""><br class=""></div></div><div class=""><br class=""></div><div class="">And here is the bake-off code:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defmacro jv (jv ix &amp;rest args)</font></div><div class=""><font face="Monaco" class="">&nbsp; `(funcall ,jv ,ix ,@args))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun bake-off-jv (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-list-builder-v)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv lb 0 ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv lb 1)))))</font></div><div class=""><br class=""></div></div><div class="">Yech!… we need to know that function 0 is the APPEND-ITEM, and function 1 is the GET-LIST. But is it faster?</div><div class=""><br class=""></div><div class="">The median of 3 timings on 100M conses was 4.537s. So yes, it is about 2x faster than CLOS. Unless you have a strong need for speed, stick with CLOS.</div><div class=""><br class=""></div><div class="">—————————————————</div><div class="">Can we do any better than JV? What about skipping the internal dispatch lambda shown above, and just vectoring ourselves through the jump-vector?</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun make-list-builder-v2 ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; always in (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp;(vector #'append-item #'get)</span></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp;)))</font></div></div><div class=""><br class=""></div><div class="">and the bake-off code:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defmacro jv2 (jv ix &amp;rest args)</font></div><div class=""><font face="Monaco" class="">&nbsp; `(funcall (aref ,jv ,ix) ,@args))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun bake-off-jv2 (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-list-builder-v2)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv2 lb 0 ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv2 lb 1)))))</font></div><div class=""><br class=""></div></div><div class=""><br class=""></div><div class="">It’s timing showed a median of 3 of 2.527s. So yes, skipping the lambda dispatch is a speedup. Still…. hmmm….</div><div class="">———————————</div><div class="">Well, just for the heck of it, let’s see where a basic STRUCT implementation falls with CLOS and DLAMBDA…</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defstruct lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; cell)</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun lbs-set-cdr (lbs x)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lbs-cell)) lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><span style="font-family: Monaco;" class="">(defun lbs-append (lbs x)</span></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lbs-cell)) lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (lbs-set-cdr lbs (cons x (cdr cell)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun lbs-get (lbs)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lbs-cell)) lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (lbs-set-cdr lbs nil))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><br class=""></div></div><div class="">and its bake-off code:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-lbs (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lbs (make-lbs)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lbs-append lbs ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lbs-get lbs)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))</font></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">OMG!! It’s timing for 100M conses shows a median of 3 of 1.807s. Not only is this faster than both DLAMBDA and CLOS, but it is even faster than using jump-vectors !!!! What a surprise!</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div></div></div></blockquote></div><br class=""></div></div></blockquote></div><br class=""></div></div></div></blockquote></div><br class=""></div></div></div></blockquote></div><br class=""></div></div></div></blockquote></div><br class=""><div class="">
<div class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class="">--</span><br style="font-family: Menlo-Regular; font-size: 11px;" class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class="">Pascal Costanza</span><br style="font-family: Menlo-Regular; font-size: 11px;" class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class="">The views expressed in this email are my own, and not those of my employer.</span></div><div class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class=""><br class=""></span></div><br class="Apple-interchange-newline">

</div>


<br class=""></div></div></div></blockquote></div><br class=""></div></div></div></blockquote></div><br class=""></div></div></blockquote></div><br class=""></div></div></div></blockquote></div><br class=""><div class="">
<div class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class="">--</span><br style="font-family: Menlo-Regular; font-size: 11px;" class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class="">Pascal Costanza</span><br style="font-family: Menlo-Regular; font-size: 11px;" class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class="">The views expressed in this email are my own, and not those of my employer.</span></div><div class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class=""><br class=""></span></div><br class="Apple-interchange-newline">

</div>


<br class=""></div></div></div></blockquote></div><br class=""></div></div></body></html>

                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: Speed of various implementation schemes...</h1><html><head><meta http-equiv="Content-Type" content="text/html charset=utf-8"></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">Okay!<div class=""><br class=""></div><div class="">Here is a rewrite of DLAMBDA that makes our test timings go from 60+ sec down to 4.3 sec. That’s a pretty good improvement. Functionally identical to Doug Hoyte’s version, as tested thoroughly through a large body of Butterfly code which has been heavily dependent on its proper functioning.</div><div class=""><br class=""></div><div class="">Instead of genning up a CASE expression the way Doug did, we build named LABELS functions, and perform selection to them from a getf plist which pairs the selector symbols with freshly closed function pointers. Startup may take longer than Doug’s version in order to create these new closures, but in use, all the work has been completed ahead of time.</div><div class=""><br class=""></div><div class="">This code uses Pascal’s suggestion to declare the LABELS functions as INLINE.</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">;; ----------------------------------------------------------------------</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun bad-dlambda (&amp;rest args)</font></div><div class=""><font face="Monaco" class="">&nbsp; (declare (ignore args))</font></div><div class=""><font face="Monaco" class="">&nbsp; (error "Invalid selector in dlambda"))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defmacro! dlambda (&amp;rest ds)</font></div><div class=""><font face="Monaco" class="">&nbsp; (let* ((dsels &nbsp; (mapcar #'first ds))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;has-default</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(dfnames (mapcar (lambda (sel)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (if (eq sel t)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (setf has-default g!default)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (gensym (string sel))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dsels)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; `(labels</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;,(mapcar (lambda (dfname clause)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; `(,dfname ,@(rest clause)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dfnames ds)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp;<font color="#b92d5d" class="">(declare (inline ,@dfnames)) ;; thanks Pascal...</font></font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp;(let ((,g!plst (list ,@(mapcan (lambda (dsel dfname)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (unless (eq dsel t)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; `(',dsel #',dfname)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dsels dfnames))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;,(if has-default</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; `(lambda (&amp;rest ,g!args)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(if-let (,g!fn (getf ,g!plst (first ,g!args) nil))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(apply ,g!fn (rest ,g!args))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(apply #',g!default ,g!args)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; `(lambda (,g!sel &amp;rest ,g!args)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(apply (getf ,g!plst ,g!sel 'bad-dlambda) ,g!args)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defmacro dcase (args &amp;rest clauses)</font></div><div class=""><font face="Monaco" class="">&nbsp; `(apply (dlambda</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ,@clauses)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ,args))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">#+:LISPWORKS</font></div><div class=""><font face="Monaco" class="">(editor:setup-indent "DCASE" 1)</font></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 11:42, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">Well, if I can modify DLAMBA to use Jump Vectors, then I will. But if I have to know a cardinal index in order to call a function, then I might as well hang it up and go to work for Apple...<div class=""><br class=""></div><div class="">But offhand, just reframing the DLAMBDA like this, brings down the time from 60+ sec to 4.5 sec:<div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun make-list-builder ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; always in (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(reset-list (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell nil)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (list x))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; <font color="#b92d5d" class="">(declare (inline set-cdr append-item get-list reset-list))</font></font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (let ((alst (list (cons :append #'append-item)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (cons :get &nbsp; &nbsp;#'get-list)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (cons :reset &nbsp;#'reset-list))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (lambda (sel &amp;rest args)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (apply (cdr (assoc sel alst)) args))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</font></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 11:39, Pascal Costanza &lt;<a href="mailto:pc@p-cos.net" class="">pc@p-cos.net</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">This version of the jump vector approach seems to give the best performance on my machine:<div class=""><br class=""></div><div class=""><div class="">(defun make-list-builder-v ()</div><div class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</div><div class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</div><div class="">&nbsp; ;; always in (cdr cell)</div><div class="">&nbsp; (declare (optimize (speed 3) (space 0) (safety 0) (debug 0) (compilation-speed 0)))</div><div class="">&nbsp; (let (cell)</div><div class="">&nbsp; &nbsp; (labels ((set-cdr (x)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get ()</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</div><div class="">&nbsp; &nbsp; &nbsp; (declare (inline set-cdr append-item get))</div><div class="">&nbsp; &nbsp; &nbsp; (let ((jv (vector #'append-item #'get)))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; (declare ((simple-array function (2)) jv))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; (lambda (ix &amp;rest args)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (apply (aref jv ix) args))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</div><div class=""><br class=""></div><div class="">(defmacro jv (jv ix &amp;rest args)</div><div class="">&nbsp; `(funcall ,jv ,ix ,@args))</div><div class=""><br class=""></div><div class="">(defun bake-off-jv (ngrp)</div><div class="">&nbsp; (time (let ((lb (make-list-builder-v)))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv lb 0 ix))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv lb 1)))))</div></div><div class=""><br class=""></div><div class="">Pascal</div><div class=""><br class=""><div class=""><blockquote type="cite" class=""><div class="">On 11 Feb 2017, at 19:28, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">So now, I’m going back over DLAMBDA to see if some slight changes might make it much more acceptable. I certainly do appreciate its style in little cases like this.<div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><br class=""><div class=""><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 11:26, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">Oooh! That’s very interesting!! Thanks so much.<div class=""><br class=""></div><div class="">I clearly need to learn to appreciate DECLARE much more than I currently do.</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 11:25, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">Oooh! That’s very interesting!! Thanks so much.<div class=""><br class=""></div><div class="">I clearly need to learn to appreciate DECLARE much more than I currently do.</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""><div class=""><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 11:07, Pascal Costanza &lt;<a href="mailto:pc@p-cos.net" class="">pc@p-cos.net</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">When you declare the local functions inline, the first version actually is the fastest.<div class=""><br class=""></div><div class=""><div class="">(defun bake-off-raw (ngrp)</div><div class="">&nbsp; (declare (optimize (speed 3) (safety 0) (debug 0) (space 0) (compilation-speed 0)))</div><div class="">&nbsp; (let (cell)</div><div class="">&nbsp; &nbsp; (labels ((set-cdr (x)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list ()</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</div><div class="">&nbsp; &nbsp; &nbsp; (declare (inline set-cdr append-time get-list))</div><div class="">&nbsp; &nbsp; &nbsp; (time (dotimes (g (* 1000 ngrp))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (append-item ix))</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (get-list)))</div><div class="">&nbsp; &nbsp; &nbsp; )))</div></div><div class=""><br class=""></div><div class="">Pascal</div><div class=""><br class=""><div class=""><blockquote type="cite" class=""><div class="">On 11 Feb 2017, at 18:58, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">Looking at the disassembly, I see that the labels functions are being closed over on the stack, only on major entry. Not repeatedly.&nbsp;<div class=""><br class=""></div><div class="">However, APPEND-ITEM and GET-LIST, once closed over, also need to call the newly constructed closure for SET-CDR. And that is sitting on the stack as a freshly made closure. So the compiled code for APPEND-ITEM and GET-LIST need to call something that must be determined dynamically each time.</div><div class=""><br class=""></div><div class="">If I make SET-CDR depend on no free variables, then it can be succinctly encapsulated and never needs closing over on the stack. So this version also runs extremely quickly:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-raw3 (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; (let (cell)</span></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (cell x) <font color="#b92d5d" class="">;; &lt;— no free vars</font></font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr cell (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr cell nil))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (time (dotimes (g (* 1000 ngrp))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</span></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (append-item ix))</span></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (get-list)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div><div class=""><br class=""></div><div class="">The slowdown happens when there is mutual interaction among LABELS functions, and the called functions have free vars.</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 10:28, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">I suspected that the reason for the slowdown with the internal LABELS functions might be the fact that new closures are needed, at least once on major entry, because they all reference a free variable CELL.<div class=""><br class=""></div><div class="">So here is a version without needing closure creation:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-raw2 (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (declare (fixnum ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (cell x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (cell x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr cell (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr cell nil))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (time (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (declare (fixnum g))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (declare (fixnum ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (append-item cell ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (get-list cell)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div><div class=""><br class=""></div><div class="">And indeed, it is fastest of all, at 1.4 sec. That’s more like what I would have expected.</div><div class=""><br class=""></div><div class="">So it seems that we are constructing closures more than once, possibly in each iteration of the loop at the call site of APPEND-ITEM and GET-LIST.</div><div class=""><br class=""></div><div class="">Why would the compiler need to do that?</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 09:42, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">.. and to my shock, and horror!, it actually happens that using the embedded LABELS functions is even worse than using CLOS.<div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-raw (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (time (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (append-item ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (get-list)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">Median of 3 timings for (BAKE-OFF-RAW 100) &nbsp;[ 100M conses ] is 16.432 sec.&nbsp;</div><div class=""><br class=""></div><div class="">I couldn’t believe my eyes. There must be a mistake. I tried the BAKE-OFF-LBS (struct version) again to be sure. It still shows 1.8 sec. Then I tried BAKE-OFF-RAW yet again. Still 16 sec.&nbsp;</div><div class=""><br class=""></div><div class="">What’s going on here?</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 09:29, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">ummm… yes, my DLAMBDA timings incorrectly stated that 10 groups took 60+ seconds. It took 6+ seconds for 10 groups, and scaling to 100 groups would have been the stated 60+ seconds. Sorry… End results remain the same, just mis-stated the case.<div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><blockquote type="cite" class=""><div class="">On Feb 11, 2017, at 09:09, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class=""><div class="">Summary: Using basic STRUCT and direct function calls provides the fastest performing encapsulation of state and behavior. Significantly faster than CLOS, hugely faster than DLAMBDA, and even faster than using vectored function dispatch through a jump vector (!!).</div><div class=""><br class=""></div><div class="">Normalized Timings (2 sig figs, median of 3 meas):</div><div class=""><br class=""></div><div class="">STRUCT<span class="Apple-tab-span" style="white-space:pre">		</span>1.0</div><div class="">Jump Vector<span class="Apple-tab-span" style="white-space:pre">	</span>1.4</div><div class="">JV Dispatch<span class="Apple-tab-span" style="white-space:pre">	</span>2.5</div><div class="">CLOS<span class="Apple-tab-span" style="white-space:pre">		</span>5.0</div><div class="">DLAMBDA<span class="Apple-tab-span" style="white-space:pre">	</span>33</div><div class="">———————</div><div class=""><br class=""></div>From time to time, I make use of Doug Hoyte’s DLAMBDA to make little embedded-intelligence objects that don’t seem to deserve the greater complexity of CLOS. DLAMBDA has the nice trait that it keeps message code adjacent to object state, rather than spreading it all out the way CLOS does. But I’m also a big fan of CLOS - don’t get me wrong.<div class=""><br class=""></div><div class="">But just for curiosity, I wanted to see what the performance overhead on DLAMBDA is. And once I saw that, compared to CLOS, I began looking for what is the fastest possible implementation (apart from coding in Assembly language…). Let’s keep this all in Lisp.</div><div class=""><br class=""></div><div class="">As a simple test, I needed a fast list constructor that could keep items in LIFO order, and provide a fast O(1) append of each additional item as they become available. I initially set this up using internal LABEL functions, and it worked very well. And it also turned out to be useful in several other places. So I decided to package it up for myself and keep the implementation in one place, instead of replicating it all over the place — the usual reason for packaging up state and behavior into objects.</div><div class=""><br class=""></div><div class="">So here is an example of the original code:</div><div class=""><br class=""></div><div class=""><div class=""><div class=""><font face="Monaco" class="">(defun collect-&gt; (pred start until-fn succ-fn</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;key</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(key &nbsp; &nbsp;#'identity)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(map-fn #'identity))</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get-list ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (do ((x &nbsp; start &nbsp; (funcall succ-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((funcall until-fn x) (get-list))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (when (funcall pred (funcall key x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (append-item (funcall map-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</font></div></div></div><div class=""><br class=""></div><div class="">#F is a reader macro meaning (DECLARE (OPTIMIZE (SPEED 3) (SAFETY 0) (FLOAT 0)).</div><div class=""><br class=""></div><div class="">This code offers an O(1) FIFO list construction, for items from some collection START which satisfy some predicate PRED (using key function KEY), and which collects some mapped representation (MAP-FN) of the qualified items. Pretty simple.</div><div class=""><br class=""></div><div class="">It is that collection of 3 functions inside the LABELS clause that I want to package up. No clients need to know about the internal workings and state of the list constructor object. They just need to be able to instantiate such a constructor, call APPEND-ITEM on each value they want collected, and GET-LIST at the end to get their collected results.&nbsp;</div><div class=""><br class=""></div><div class="">They don’t need to know anything about the CELL, nor the SET-CDR mechanism, which together manages a list by tracking the tail cell of a circular list. The head of the accumulating list is always pointed to by the (CDR CELL). At the end, when they want the result, we need to furnish the head of the accumulated list, and null out the cdr of the last cons cell. Perfect conditions for an encapsulated object implementation.</div><div class=""><br class=""></div><div class="">So here is the first version of encapsulation done with DLAMBDA:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun make-list-builder ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; always in (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (dlambda</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (:append (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (:get ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil)))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</span></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">and here is the corresponding rewrite of COLLECT-&gt;:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun collect-&gt; (pred start until-fn succ-fn</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;key</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(key &nbsp; &nbsp;#'identity)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(map-fn #'identity))</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let ((lb (make-list-builder)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (do ((x &nbsp;start &nbsp;(funcall succ-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ((funcall until-fn x) (funcall lb :get))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (when (funcall pred (funcall key x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (funcall lb :append (funcall map-fn x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div></div><div class=""><br class=""></div><div class="">DLAMBDA is sensitive to the ordering of the message responders, so I placed :APPEND first.</div><div class=""><br class=""></div><div class="">Okay, so now let’s do some timings. I want to measure realistic applications of the list builder, not making lists of hundreds of millions of items, but perhaps a thousand items, done over and over again. To get some realistic durations, we need to execute a few million times. So here is the template of our timing tests:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-dlambda (ngrp) ;; 1 grp = 1000 times of 1000-element lists</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-list-builder)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (funcall lb :append ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (funcall lb :get)))))</font></div><div class=""><br class=""></div></div><div class="">When I execute this bake-off code for 10 groups (10,000,000 conses) I got a median of 3 measurement of 60.38 sec. under LWM 7/64 on a Mac Mini (Late 2014) running OS X Sierra 10.12.3, and nothing much else happening in the machine.</div><div class="">———————————————</div><div class=""><br class=""></div><div class="">So let’s look at a CLOS implementation. Sadly, to me, this takes all that encapsulation and scatters it to the wind.</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defclass list-builder ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ((cell &nbsp;:accessor lb-cell &nbsp;:initform nil)))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defmethod lb-set-cdr ((lb list-builder) x)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lb-cell)) lb</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (setf cell (setf (cdr xcell) x)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defmethod lb-append ((lb list-builder) x)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lb-cell)) lb</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (lb-set-cdr lb (cons x (cdr cell)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defmethod lb-get ((lb list-builder))</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lb-cell)) lb</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (lb-set-cdr lb nil))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">Its bake-off code looks like this:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-clos (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-instance 'list-builder)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lb-append lb ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lb-get lb)))))</font></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">And its median of 3 for 100 groups of 1M conses showed a timing of 8.952 sec. Note that this was for 10x as many conses as we used when timing the DLAMBDA implementation. In other words, CLOS is nearly 6x faster than DLAMBA. (That’s close enough for Astronomical accuracy to call it 10x faster).&nbsp;</div><div class=""><br class=""></div><div class="">This is very surprising!! At least to me… and it shows that LW has spent some effort to make CLOS efficient. A tip of the hat to them!</div><div class=""><br class=""></div><div class="">————————</div><div class="">Okay… what’s faster than all this so far? What about a jump vector dispatching to internal LABEL functions?</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun make-list-builder-v ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; always in (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp; (let ((jv (vector #'append-item #'get)))</span></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (lambda (ix &amp;rest args)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (apply (aref jv ix) args))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</font></div><div class=""><br class=""></div></div><div class=""><br class=""></div><div class="">And here is the bake-off code:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defmacro jv (jv ix &amp;rest args)</font></div><div class=""><font face="Monaco" class="">&nbsp; `(funcall ,jv ,ix ,@args))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun bake-off-jv (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-list-builder-v)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv lb 0 ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv lb 1)))))</font></div><div class=""><br class=""></div></div><div class="">Yech!… we need to know that function 0 is the APPEND-ITEM, and function 1 is the GET-LIST. But is it faster?</div><div class=""><br class=""></div><div class="">The median of 3 timings on 100M conses was 4.537s. So yes, it is about 2x faster than CLOS. Unless you have a strong need for speed, stick with CLOS.</div><div class=""><br class=""></div><div class="">—————————————————</div><div class="">Can we do any better than JV? What about skipping the internal dispatch lambda shown above, and just vectoring ourselves through the jump-vector?</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun make-list-builder-v2 ()</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; An O(1) list builder object, in FIFO order. Fast append uses a</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; circular list with cell pointing at last cdr, front of list</font></div><div class=""><font face="Monaco" class="">&nbsp; ;; always in (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (let (cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (labels ((set-cdr (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(append-item (x)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr (cons x (cdr cell))))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(get ()</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(set-cdr nil))))</font></div><div class=""><span style="font-family: Monaco;" class="">&nbsp; &nbsp; &nbsp;(vector #'append-item #'get)</span></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp;)))</font></div></div><div class=""><br class=""></div><div class="">and the bake-off code:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defmacro jv2 (jv ix &amp;rest args)</font></div><div class=""><font face="Monaco" class="">&nbsp; `(funcall (aref ,jv ,ix) ,@args))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun bake-off-jv2 (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lb (make-list-builder-v2)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv2 lb 0 ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (jv2 lb 1)))))</font></div><div class=""><br class=""></div></div><div class=""><br class=""></div><div class="">It’s timing showed a median of 3 of 2.527s. So yes, skipping the lambda dispatch is a speedup. Still…. hmmm….</div><div class="">———————————</div><div class="">Well, just for the heck of it, let’s see where a basic STRUCT implementation falls with CLOS and DLAMBDA…</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defstruct lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; cell)</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun lbs-set-cdr (lbs x)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lbs-cell)) lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (when-let (xcell (or cell x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (setf cell (setf (cdr xcell) x))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; )))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><span style="font-family: Monaco;" class="">(defun lbs-append (lbs x)</span></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lbs-cell)) lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (lbs-set-cdr lbs (cons x (cdr cell)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><font face="Monaco" class=""><br class=""></font></div><div class=""><font face="Monaco" class="">(defun lbs-get (lbs)</font></div><div class=""><font face="Monaco" class="">&nbsp; #F</font></div><div class=""><font face="Monaco" class="">&nbsp; (with-accessors ((cell lbs-cell)) lbs</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; (prog1</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; (cdr cell)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; (lbs-set-cdr lbs nil))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; ))</font></div><div class=""><br class=""></div></div><div class="">and its bake-off code:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Monaco" class="">(defun bake-off-lbs (ngrp)</font></div><div class=""><font face="Monaco" class="">&nbsp; (time (let ((lbs (make-lbs)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (g (* 1000 ngrp))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dotimes (ix 1000)</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lbs-append lbs ix))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lbs-get lbs)))</font></div><div class=""><font face="Monaco" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))</font></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">OMG!! It’s timing for 100M conses shows a median of 3 of 1.807s. Not only is this faster than both DLAMBDA and CLOS, but it is even faster than using jump-vectors !!!! What a surprise!</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div></div></div></blockquote></div><br class=""></div></div></blockquote></div><br class=""></div></div></div></blockquote></div><br class=""></div></div></div></blockquote></div><br class=""></div></div></div></blockquote></div><br class=""><div class="">
<div class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class="">--</span><br style="font-family: Menlo-Regular; font-size: 11px;" class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class="">Pascal Costanza</span><br style="font-family: Menlo-Regular; font-size: 11px;" class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class="">The views expressed in this email are my own, and not those of my employer.</span></div><div class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class=""><br class=""></span></div><br class="Apple-interchange-newline">

</div>


<br class=""></div></div></div></blockquote></div><br class=""></div></div></div></blockquote></div><br class=""></div></div></blockquote></div><br class=""></div></div></div></blockquote></div><br class=""><div class="">
<div class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class="">--</span><br style="font-family: Menlo-Regular; font-size: 11px;" class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class="">Pascal Costanza</span><br style="font-family: Menlo-Regular; font-size: 11px;" class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class="">The views expressed in this email are my own, and not those of my employer.</span></div><div class=""><span style="font-family: Menlo-Regular; font-size: 11px;" class=""><br class=""></span></div><br class="Apple-interchange-newline">

</div>


<br class=""></div></div></div></blockquote></div><br class=""></div></div></div></div></blockquote></div><br class=""></div></body></html>

                </article>
               </section>
              </section>
             </div>
            </div>
            <footer class="d-flex justify-content-center">
             <div>
              Updated at: 2020-12-07 08:27 UTC
             </div>
            </footer>
           </body>
          </html>