<!DOCTYPE html>
<html lang=en>
           <head>
            <meta charset=UTF-8>
            <title>Multiple CAS (MCAS) versus Locks</title>
            <link rel=stylesheet
                  href=https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css
                  integrity=sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2
                  crossorigin=anonymous>
            <style>
section.tree {
    padding-left: 2em;
}
section.tree:first-child {
    padding-left: 0;
}
.article-link {
  margin-bottom: 1em;
}
</style>
<!-- Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-9X3G9MMWZP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-9X3G9MMWZP');
</script>

           </head>
           <body>
            <header class="d-flex justify-content-center">
             <nav
                  class="navbar navbar-light bg-light w-100 mx-5 mb-3">
              <a class=navbar-brand href="/">Lisp HUG Maillist Archive</a>
             </nav>
            </header>
            <div class="d-flex justify-content-center">
             <div class="w-100 mx-5 px-3">
              <section class=tree>
               <article class=email>
                <h1>Multiple CAS (MCAS) versus Locks</h1><html><head><meta http-equiv="Content-Type" content="text/html charset=us-ascii"></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">Here is a good read on lock-free programming:<div class=""><br class=""></div><div class="">UCCL Tech Report 579, "Practical lock-freedom" by Keir Fraser, Feb 2004</div><div class=""><a href="http://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-579.pdf" class="">http://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-579.pdf</a></div><div class=""><br class=""></div><div class="">I adapted his work on MCAS and CCAS to LW, in these (approx) 100 LOC:</div><div class=""><br class=""></div><div class=""></div></body></html>

               </article>
               <section class=tree>
                <article class=email>
                 <h1>Re: Multiple CAS (MCAS) versus Locks</h1><html><head><meta http-equiv="Content-Type" content="text/html charset=utf-8"></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">I found a needed correction to Keir’s code down in the MCAS helper routine.<div class=""><br class=""></div><div class="">The convention is that any cells subject to modification by MCAS should always be read by MCAS-READ. Similarly for CCAS / CCAS-READ. The reason for that is the a speculative probe may be under way from another thread, and the exploration will be pushed along by us when we use the proper MCAS-READ and CCAS-READ. That’s what gives his code the wait-free character, in addition to lock-free.</div><div class=""><br class=""></div><div class="">But down in his code for MCAS he performs a CCAS followed by a peek at what was accomplished. He uses direct pointer access to the cell instead of using a CCAS-READ.</div><div class=""><br class=""></div><div class="">I found that while that works… the overall system performance is actually enhanced by adhering to the protocol and using a CCAS-READ instead of a direct pointer access. I think that speed up happens because the CCAS-READ pushes along other speculative MCAS/CCAS operations to negative conclusions, which works in our current MCAS favor. Otherwise, there will be occasional CAS-descriptors in the cell instead of what we had anticipated, making us more likely to fail.</div><div class=""><br class=""></div><div class="">The speed up is about 10-20% by using CCAS-READ instead of direct pointer access.</div><div class=""><br class=""></div><div class="">In the Lisp equivalent, our (REF-VALUE p) operation is equivalent to C’s direct pointer access, *p, while (MAKE-REF x) is equivalent to C’s &amp;x (address-of) operation.&nbsp;</div><div class=""><br class=""></div><div class=""><div class=""><font face="Menlo" class="">(defun mcas-help (desc)</font></div><div class=""><font face="Menlo" class="">&nbsp; #F</font></div><div class=""><font face="Menlo" class="">&nbsp; (declare (mcas-desc desc))</font></div><div class=""><font face="Menlo" class="">&nbsp; (let ((triples &nbsp; &nbsp;(mcas-desc-triples desc))</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; (status-ref (mcas-desc-status desc)))</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp;&nbsp;</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; (labels ((decide (desired)</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cas status-ref :undecided desired)</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(let ((success (eq :successful (ref-value status-ref))))</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(map nil (lambda (triple)</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (apply #'patch-up success triple))</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; triples)</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;success))</font></div><div class=""><font face="Menlo" class=""><br class=""></font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(patch-up (success ref old new)</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cas ref desc (if success new old)))</font></div><div class=""><font face="Menlo" class=""><br class=""></font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(try-mcas (ref old new)</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <font color="#b92d5d" class="">&nbsp;(ccas ref old desc status-ref)</font></font></div><div class=""><font color="#b92d5d" face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(let ((v (ccas-read ref))) ;; ccas-read makes it faster than when using ref-value (!??)</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(cond ((and (eq v old)</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(eq :undecided (ref-value status-ref)))</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;; must have changed beneath us when we</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;; looked, then changed back again. So try</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;; again. (ABA Update?)</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (try-mcas ref old new))</font></div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div><blockquote type="cite" class=""><div class="">On Feb 24, 2017, at 16:18, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=us-ascii" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">Here is a good read on lock-free programming:<div class=""><br class=""></div><div class="">UCCL Tech Report 579, "Practical lock-freedom" by Keir Fraser, Feb 2004</div><div class=""><a href="http://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-579.pdf" class="">http://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-579.pdf</a></div><div class=""><br class=""></div><div class="">I adapted his work on MCAS and CCAS to LW, in these (approx) 100 LOC:</div><div class=""><br class=""></div><div class=""></div></div><span id="cid:3DD91700-87F7-4634-B38B-77E5637E5FA0@hsd1.az.comcast.net.">&lt;MCAS-car.lisp&gt;</span><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class=""><div class=""></div><div class=""><br class=""></div><div class="">Using MCAS, I was able to speed up my Lisp implementation of Reppy Channels from 25-50 kRPC/sec to now 357 kRPC/sec, where an RPC is a dual communication exchange from a client thread to a server thread and receiving back the server response. Each RPC exchange now takes roughly 2.8 microseconds on my Mac Mini.</div><div class=""><br class=""></div><div class="">With Reppy Channels, you have the opportunity for thread rendezvous IF you can simultaneously mark both threads with each other’s communication data. If a thread has been previously marked, then no-go. So I needed a dual-CAS instruction. MCAS fits the bill nicely, with room for growth. Just be sure to request multiple-cell CAS with the same object request ordering, to avoid deadlock. I use a sequentially assigned ID in each object to effect my ordering. Address order cannot be relied upon in a GC Lisp heap.</div><div class=""><br class=""></div><div class="">With SMP multiprocessing, the use of locks can be a frequent bottleneck. Presumably the speed up occurs because a blocked Lock causes a process thread switch, whereas, even though the code in MCAS is substantial, it pays to keep the CPU’s attention. A factor of 10x in speed up is significant in my accounting.</div><div class=""><br class=""></div><div class="">The nice thing about Keir’s work is that these implement not only lock-free CAS, but wait-free too, as other threads gaining on the structure can help your MCAS operation along if it is found pending.</div><div class=""><br class=""></div><div class="">Cheers,&nbsp;</div><div class=""><br class=""></div><div class="">- DM</div></div></div></blockquote></div><br class=""></div></body></html>

                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: Multiple CAS (MCAS) versus Locks</h1><html><head><meta http-equiv="Content-Type" content="text/html charset=utf-8"></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">An implementation of Reppy Channels for Lispworks has been uploaded to GitHub:<div class=""><br class=""></div><div class=""><a href="https://github.com/dbmcclain/Reppy-Channels" class="">https://github.com/dbmcclain/Reppy-Channels</a>&nbsp; (License free)</div><div class=""><br class=""></div><div class="">This is a lock-free / wait-free implementation that provides for composable events, automatic scavenging of dead-end threads (if you use the channel-ref protocol), cleanup-actions on failed rendezvous, and is more than 2x faster than equivalent (where that’s even possible!) lock-bound (e.g., mailbox) implementations.</div><div class=""><br class=""></div><div class="">Unlike the lightweight green threads of CML, our threads are heavy and so we should avoid just popping them off willy nilly in the manner of CML programming. But we can automatically reclaim dead-end threads using Lisp’s GC finalization protocol. Making events and channels is fairly light weight, and so are readily composed on the fly.</div><div class=""><br class=""></div><div class="">The speed benefits, as well as composable events, and wrappers for failed rendezvous paths, argue strongly in favor of Reppy Channels for many purposes where lock-bound implementations had previously been used.</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div></body></html>

                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: Multiple CAS (MCAS) versus Locks</h1>
                 <pre>And so here is a corrected version of MCAS, including extensions to refer to either the CAR or the CDR of a ref-cell.

And along with it, there is an implementation of a fast lock-free/wait-free FIFO queue. All the threads in the world can simultaneously access and update these queues without need for exclusive lock control.


</pre>
                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: Multiple CAS (MCAS) versus Locks</h1>
                 <pre>All this work on MCAS has me looking for other good applications of it. So this morning I sat down to do a Read/Write Gate. Along the way, I pushed myself for minimalism, and found that MCAS is never needed there…

Here is a sort of minimalist Read/Write Gate (many readers, one writer) that is recursive and SMP ready, using only a single CAS instruction. Any number of RW Gates can be set up as needed. About 100 LOC.


</pre>
                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: Multiple CAS (MCAS) versus Locks</h1>
                 <pre>um… yeah… (red face)

Here is a corrected version…


</pre>
                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: Multiple CAS (MCAS) versus Locks</h1>
                 <p>
                  Unable to parse email body. Email id is 14270
                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: Multiple CAS (MCAS) versus Locks</h1><html><head><meta http-equiv="Content-Type" content="text/html charset=utf-8"></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">Hi Martiin,<div class=""><br class=""></div><div class="">Yes indeed… I think this fixes things…</div><div class=""><br class=""></div><div class=""><div class="">(defun make-rwgate ()</div><div class="">&nbsp; (list 0))</div><div class=""><br class=""></div><div class="">(defun rwg-cas (gate locktype)</div><div class="">&nbsp; (let ((new &nbsp; &nbsp;(case locktype</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (:read &nbsp;t)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (:write mp:*current-process*))))</div><div class="">&nbsp; &nbsp; (and (sys:compare-and-swap (cdr gate)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(and (cdr gate)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;new)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(sys:atomic-fixnum-incf (car gate)))</div><div class="">&nbsp; &nbsp; ))</div><div class=""><br class=""></div><div class=""><font color="#b92d5d" class="">(defun rwg-release (gate)</font></div><div class=""><font color="#b92d5d" class="">&nbsp; (let ((v (cdr gate)))</font></div><div class=""><font color="#b92d5d" class="">&nbsp; &nbsp; (when (zerop (sys:atomic-fixnum-decf (car gate)))</font></div><div class=""><font color="#b92d5d" class="">&nbsp; &nbsp; &nbsp; (sys:compare-and-swap (cdr gate) v nil))))</font></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div><blockquote type="cite" class=""><div class="">On Mar 1, 2017, at 07:44, Martin Simmons &lt;<a href="mailto:martin@lispworks.com" class="">martin@lispworks.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><div class="">Hi David,<br class=""><br class="">Unfortunately there is a problem with rwg-cas v.s. rwg-release. &nbsp;Suppose the<br class="">following sequence of events occurs:<br class=""><br class="">0. Initially *gate* is free, i.e. (nil . 0).<br class=""><br class="">1. Thread A evaluates (rwg-cas *gate* :read) and then (rwg-release *gate*),<br class=""> &nbsp;&nbsp;which reaches the start of the (setf (car gate) nil). &nbsp;*gate* is now<br class=""> &nbsp;&nbsp;(t . 0).<br class=""><br class="">2. Thread B evaluates (rwg-cas *gate* :read), which succeeds and *gate* is now<br class=""> &nbsp;&nbsp;(t . 1).<br class=""><br class="">3. Thread A evaluates the setf and *gate* is now (nil . 1). &nbsp;This is an<br class=""> &nbsp;&nbsp;illegal state because it would allow a write lock to be taken even though<br class=""> &nbsp;&nbsp;thread B still has a read lock.<br class=""><br class="">-- <br class="">Martin Simmons<br class="">LispWorks Ltd<br class=""><a href="http://www.lispworks.com/" class="">http://www.lispworks.com/</a><br class=""><br class="">_______________________________________________<br class="">Lisp Hug - the mailing list for LispWorks users<br class="">lisp-hug@lispworks.com<br class="">http://www.lispworks.com/support/lisp-hug.html<br class=""><br class=""></div></div></blockquote></div><br class=""></div></body></html>

                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: Multiple CAS (MCAS) versus Locks</h1><html><head><meta http-equiv="Content-Type" content="text/html charset=utf-8"></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">nope… needs an MCAS after all…<div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""><div><blockquote type="cite" class=""><div class="">On Mar 1, 2017, at 09:08, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">Hi Martiin,<div class=""><br class=""></div><div class="">Yes indeed… I think this fixes things…</div><div class=""><br class=""></div><div class=""><div class="">(defun make-rwgate ()</div><div class="">&nbsp; (list 0))</div><div class=""><br class=""></div><div class="">(defun rwg-cas (gate locktype)</div><div class="">&nbsp; (let ((new &nbsp; &nbsp;(case locktype</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (:read &nbsp;t)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (:write mp:*current-process*))))</div><div class="">&nbsp; &nbsp; (and (sys:compare-and-swap (cdr gate)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(and (cdr gate)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;new)</div><div class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(sys:atomic-fixnum-incf (car gate)))</div><div class="">&nbsp; &nbsp; ))</div><div class=""><br class=""></div><div class=""><font color="#b92d5d" class="">(defun rwg-release (gate)</font></div><div class=""><font color="#b92d5d" class="">&nbsp; (let ((v (cdr gate)))</font></div><div class=""><font color="#b92d5d" class="">&nbsp; &nbsp; (when (zerop (sys:atomic-fixnum-decf (car gate)))</font></div><div class=""><font color="#b92d5d" class="">&nbsp; &nbsp; &nbsp; (sys:compare-and-swap (cdr gate) v nil))))</font></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><blockquote type="cite" class=""><div class="">On Mar 1, 2017, at 07:44, Martin Simmons &lt;<a href="mailto:martin@lispworks.com" class="">martin@lispworks.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><div class="">Hi David,<br class=""><br class="">Unfortunately there is a problem with rwg-cas v.s. rwg-release. &nbsp;Suppose the<br class="">following sequence of events occurs:<br class=""><br class="">0. Initially *gate* is free, i.e. (nil . 0).<br class=""><br class="">1. Thread A evaluates (rwg-cas *gate* :read) and then (rwg-release *gate*),<br class=""> &nbsp;&nbsp;which reaches the start of the (setf (car gate) nil). &nbsp;*gate* is now<br class=""> &nbsp;&nbsp;(t . 0).<br class=""><br class="">2. Thread B evaluates (rwg-cas *gate* :read), which succeeds and *gate* is now<br class=""> &nbsp;&nbsp;(t . 1).<br class=""><br class="">3. Thread A evaluates the setf and *gate* is now (nil . 1). &nbsp;This is an<br class=""> &nbsp;&nbsp;illegal state because it would allow a write lock to be taken even though<br class=""> &nbsp;&nbsp;thread B still has a read lock.<br class=""><br class="">-- <br class="">Martin Simmons<br class="">LispWorks Ltd<br class=""><a href="http://www.lispworks.com/" class="">http://www.lispworks.com/</a><br class=""><br class="">_______________________________________________<br class="">Lisp Hug - the mailing list for LispWorks users<br class=""><a href="mailto:lisp-hug@lispworks.com" class="">lisp-hug@lispworks.com</a><br class="">http://www.lispworks.com/support/lisp-hug.html<br class=""><br class=""></div></div></blockquote></div><br class=""></div></div></div></blockquote></div><br class=""></div></body></html>

                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: Multiple CAS (MCAS) versus Locks</h1><html><head><meta http-equiv="Content-Type" content="text/html charset=utf-8"></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class=""><div class="">This fixes things… Since we are attempting simultaneous ownership and count modifications, it really does need an MCAS after all.</div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><div class=""><font face="Menlo" class="">(defstruct (rwgate</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (:constructor %make-rwgate))</font></div><div class=""><font face="Menlo" class="">&nbsp; hdref</font></div><div class=""><font face="Menlo" class="">&nbsp; tlref)</font></div><div class=""><font face="Menlo" class=""><br class=""></font></div><div class=""><font face="Menlo" class="">(defun make-rwgate ()</font></div><div class=""><font face="Menlo" class="">&nbsp; (let ((cell (list 0)))</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; (%make-rwgate</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp;;; pre-allocate read-only refs</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp;:hdref &nbsp;(car-ref cell)</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp;:tlref &nbsp;(cdr-ref cell))))</font></div><div class=""><font face="Menlo" class=""><br class=""></font></div><div class=""><font face="Menlo" class="">(defun rwg-cas (gate locktype)</font></div><div class=""><font face="Menlo" class="">&nbsp; (declare (rwgate gate)</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(optimize (speed 3) (safety 0) (float 0))</font></div><div class=""><font face="Menlo" class="">&nbsp; (let* ((new &nbsp; &nbsp;(case locktype</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (:read &nbsp;t)</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (:write mp:*current-process*)))</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(hdref (rwgate-hdref gate))</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(tlref (rwgate-tlref gate))</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(hd &nbsp; &nbsp;(mcas-read hdref))</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(tl &nbsp; &nbsp;(mcas-read tlref)))</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; (cond ((mcas `((,hdref ,hd &nbsp;,(1+ hd))</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(,tlref ,(and tl</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;new) &nbsp;,new)))</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;; we got it</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;)</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((eq new tl)</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;; try again - we might have just failed on the count</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(rwg-cas gate locktype))</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; )))</font></div><div class=""><font face="Menlo" class=""><br class=""></font></div><div class=""><font face="Menlo" class="">(defun rwg-release (gate)</font></div><div class=""><font face="Menlo" class="">&nbsp; (declare (rwgate gate)</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(optimize (speed 3) (safety 0) (float 0))</font></div><div class=""><font face="Menlo" class="">&nbsp; (let* ((hdref &nbsp;(rwgate-hdref gate))</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(tlref &nbsp;(rwgate-tlref gate))</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(hd &nbsp; &nbsp; (mcas-read hdref))</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(tl &nbsp; &nbsp; (mcas-read tlref))</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(new &nbsp; &nbsp;(when (&gt; hd 1)</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;tl)))</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; (unless (mcas `((,hdref &nbsp;,hd &nbsp;,(1- hd))</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (,tlref &nbsp;,tl &nbsp;,new)))</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; &nbsp; (rwg-release gate))</font></div><div class=""><font face="Menlo" class="">&nbsp; &nbsp; ))</font></div><div class=""><br class=""></div></div></body></html>

                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: Multiple CAS (MCAS) versus Locks</h1>
                 <pre>Heh! I went back 8 years and, looking through my Okeanos OODBMS code, I found that I (er, rather, LispWorks) had already solved this RW-Gate problem with their shared locks… I giant tip of the hat to Martin and company!!

Here it is re-worked from Okeanos with abort cleanup functions as well as timeouts


</pre>
                </article>
               </section>
              </section>
             </div>
            </div>
            <footer class="d-flex justify-content-center">
             <div>
              Updated at: 2020-12-07 08:27 UTC
             </div>
            </footer>
           </body>
          </html>