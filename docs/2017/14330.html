<!DOCTYPE html>
<html lang=en>
           <head>
            <meta charset=UTF-8>
            <title>Understanding Lisp History...</title>
            <link rel=stylesheet
                  href=https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css
                  integrity=sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2
                  crossorigin=anonymous>
            <style>
section.tree {
    padding-left: 2em;
}
section.tree:first-child {
    padding-left: 0;
}
.article-link {
  margin-bottom: 1em;
}
</style>
<!-- Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-9X3G9MMWZP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-9X3G9MMWZP');
</script>

           </head>
           <body>
            <header class="d-flex justify-content-center">
             <nav
                  class="navbar navbar-light bg-light w-100 mx-5 mb-3">
              <a class=navbar-brand href="/">Lisp HUG Maillist Archive</a>
             </nav>
            </header>
            <div class="d-flex justify-content-center">
             <div class="w-100 mx-5 px-3">
              <section class=tree>
               <article class=email>
                <h1>Understanding Lisp History...</h1><html><head><meta http-equiv="Content-Type" content="text/html charset=utf-8"></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">I just ran across a relatively recent dissertation that goes a long way toward explaining the reasons for the present state of Common Lisp.<div class=""><br class=""></div><div class=""><a href="https://web.wpi.edu/Pubs/ETD/Available/etd-090110-124904/unrestricted/jshutt.pdf" class="">https://web.wpi.edu/Pubs/ETD/Available/etd-090110-124904/unrestricted/jshutt.pdf</a></div><div class=""><br class=""></div><div class="">I wasn’t around in the earliest days of the evolution of Lisp, and so I was never directly aware of Funarg problems, had never heard of Fexprs, and was only aware of macro hygiene issues by way of an introduction by Paul Graham in “On Lisp” and the surrounding discussions among Schemers.</div><div class=""><br class=""></div><div class="">Reading through this dissertation helps a lot to illuminate the issues of the time, and how they were resolved in the definition of Common Lisp. But I fear we might also have lost some expressive power along the way.</div><div class=""><br class=""></div><div class="">For me, the reading is a bit slow going and technically difficult, but seems worthwhile to expend the effort to understand.</div><div class=""><br class=""></div><div class="">This dissertation has given rise to a new implementation of Scheme known as Kernel. It doesn’t sound like a practical utilitarian language in the same sense as our Common Lisp today. But it is interesting nonetheless. I’m still slogging my way through, and looking for a compelling case to include some semblance of Fexprs. Offhand, so far, even though Macros are intentionally limited forms of Fexprs, they might have all the qualities we actually need in our day to day practical programming.</div><div class=""><br class=""></div><div class="">I’d love to hear comments from anyone more knowledgeable.</div><div class=""><br class=""></div><div class="">- DM</div></body></html>

               </article>
               <section class=tree>
                <article class=email>
                 <h1>Re: Understanding Lisp History...</h1><html><head><meta http-equiv="Content-Type" content="text/html charset=utf-8"></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class=""><div class="">Kent Pitman explained why we have macros and not fexprs. The paper is from 1980.</div><div class=""><br class=""></div><div class=""><a href="http://www.nhplace.com/kent/Papers/Special-Forms.html" class="">http://www.nhplace.com/kent/Papers/Special-Forms.html</a></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">There has been recently some research on fexprs (especially what you found, the Kernel language), but the main problem is to make them compilable in a useful way. Expressive power also means that you have a lot of things possibly happening at runtime which make it very difficult to understand what your program is doing.</div><div class=""><br class=""></div><div class="">On the Lisp Machine one had fexprs, too. But they were not much used and most of the software was using macros. Especially because fexprs could not be usefully compiled at that time. Macros could be expanded at compile time, thus all the developers were using them...</div><div class=""><br class=""></div><br class=""><div><blockquote type="cite" class=""><div class="">Am 23.04.2017 um 14:58 schrieb David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt;:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">I just ran across a relatively recent dissertation that goes a long way toward explaining the reasons for the present state of Common Lisp.<div class=""><br class=""></div><div class=""><a href="https://web.wpi.edu/Pubs/ETD/Available/etd-090110-124904/unrestricted/jshutt.pdf" class="">https://web.wpi.edu/Pubs/ETD/Available/etd-090110-124904/unrestricted/jshutt.pdf</a></div><div class=""><br class=""></div><div class="">I wasn’t around in the earliest days of the evolution of Lisp, and so I was never directly aware of Funarg problems, had never heard of Fexprs, and was only aware of macro hygiene issues by way of an introduction by Paul Graham in “On Lisp” and the surrounding discussions among Schemers.</div><div class=""><br class=""></div><div class="">Reading through this dissertation helps a lot to illuminate the issues of the time, and how they were resolved in the definition of Common Lisp. But I fear we might also have lost some expressive power along the way.</div><div class=""><br class=""></div><div class="">For me, the reading is a bit slow going and technically difficult, but seems worthwhile to expend the effort to understand.</div><div class=""><br class=""></div><div class="">This dissertation has given rise to a new implementation of Scheme known as Kernel. It doesn’t sound like a practical utilitarian language in the same sense as our Common Lisp today. But it is interesting nonetheless. I’m still slogging my way through, and looking for a compelling case to include some semblance of Fexprs. Offhand, so far, even though Macros are intentionally limited forms of Fexprs, they might have all the qualities we actually need in our day to day practical programming.</div><div class=""><br class=""></div><div class="">I’d love to hear comments from anyone more knowledgeable.</div><div class=""><br class=""></div><div class="">- DM</div></div></div></blockquote></div><br class=""></body></html>

                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: Understanding Lisp History...</h1><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>
<body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">
Although my Lisp days started before Common Lisp, when fexprs ruled the Earth, I’d not see Kernel before. Some interesting issues with it described&nbsp;<a href="https://eighty-twenty.org/2011/09/29/fexprs-remain-inscrutable" class="">here</a>.
<div class=""><br class="">
<div>
<blockquote type="cite" class="">
<div class="">On Apr 23, 2017, at 7:58 AM, David McClain &lt;<a href="mailto:dbm@refined-audiometrics.com" class="">dbm@refined-audiometrics.com</a>&gt; wrote:</div>
<br class="Apple-interchange-newline">
<div class="">
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">
I just ran across a relatively recent dissertation that goes a long way toward explaining the reasons for the present state of Common Lisp.
<div class=""><br class="">
</div>
<div class=""><a href="https://urldefense.proofpoint.com/v2/url?u=https-3A__web.wpi.edu_Pubs_ETD_Available_etd-2D090110-2D124904_unrestricted_jshutt.pdf&amp;d=DwMFaQ&amp;c=yHlS04HhBraes5BQ9ueu5zKhE7rtNXt_d012z2PA6ws&amp;r=rYww9Ur1WoBi28j2XhN4rwFLo31INs66FdFiX_Ro7pI&amp;m=dMlN-3vXKw0uipUcyjMjpn5nO4S1FKl0xwYLDIDTIFM&amp;s=Y7rgwOazC4DdXZqZ1cZXBbuCj1ImNbzjZl9pkAiX1WU&amp;e=" class="">https://web.wpi.edu/Pubs/ETD/Available/etd-090110-124904/unrestricted/jshutt.pdf</a></div>
<div class=""><br class="">
</div>
<div class="">I wasn’t around in the earliest days of the evolution of Lisp, and so I was never directly aware of Funarg problems, had never heard of Fexprs, and was only aware of macro hygiene issues by way of an introduction by Paul Graham in “On Lisp” and
 the surrounding discussions among Schemers.</div>
<div class=""><br class="">
</div>
<div class="">Reading through this dissertation helps a lot to illuminate the issues of the time, and how they were resolved in the definition of Common Lisp. But I fear we might also have lost some expressive power along the way.</div>
<div class=""><br class="">
</div>
<div class="">For me, the reading is a bit slow going and technically difficult, but seems worthwhile to expend the effort to understand.</div>
<div class=""><br class="">
</div>
<div class="">This dissertation has given rise to a new implementation of Scheme known as Kernel. It doesn’t sound like a practical utilitarian language in the same sense as our Common Lisp today. But it is interesting nonetheless. I’m still slogging my way
 through, and looking for a compelling case to include some semblance of Fexprs. Offhand, so far, even though Macros are intentionally limited forms of Fexprs, they might have all the qualities we actually need in our day to day practical programming.</div>
<div class=""><br class="">
</div>
<div class="">I’d love to hear comments from anyone more knowledgeable.</div>
<div class=""><br class="">
</div>
<div class="">- DM</div>
</div>
</div>
</blockquote>
</div>
<br class="">
<div class=""><span class="Apple-style-span" style="border-collapse: separate; font-variant-ligatures: normal; font-variant-east-asian: normal; font-variant-position: normal; line-height: normal; border-spacing: 0px;"><span class="Apple-style-span" style="border-collapse: separate; color: rgb(0, 0, 0); font-family: Helvetica; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-align: -webkit-auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-border-horizontal-spacing: 0px; -webkit-border-vertical-spacing: 0px; -webkit-text-decorations-in-effect: none; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px;  ">
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; " class="">
<span class="Apple-style-span" style="border-collapse: separate; color: rgb(0, 0, 0); font-family: Helvetica; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-align: -webkit-auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-border-horizontal-spacing: 0px; -webkit-border-vertical-spacing: 0px; -webkit-text-decorations-in-effect: none; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px;  ">
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; " class="">
------------------<br class="">
Christopher Riesbeck<br class="">
Home page:&nbsp;<a href="http://www.cs.northwestern.edu/~riesbeck" class="">http://www.cs.northwestern.edu/~riesbeck</a><br class="">
Calendar: <a href="http://www.cs.northwestern.edu/~riesbeck/calendar.html" class="">
http://www.cs.northwestern.edu/~riesbeck/calendar.html</a><br class="">
<br class="">
</div>
</span></div>
</span></span></div>
<br class="">
</div>
</body>
</html>

                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: Understanding Lisp History...</h1>
                 <pre>For anyone interested, here's a Lisp 1.5, containing FEXPR's, 
dynamically scoped variables and GC, written in MC6800 assembler (very 
readable, IMO).  It was only 4K (not M, not G) long.

https://github.com/guitarvydas/frits-van-der-wateren-lisp

pt

_______________________________________________
Lisp Hug - the mailing list for LispWorks users
lisp-hug@lispworks.com
http://www.lispworks.com/support/lisp-hug.html

</pre>
                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: Understanding Lisp History...</h1>
                 <pre>On 2017-04-23 10:36 AM, Rainer Joswig wrote:
&gt ... but the main problem is to make them compilable in a useful way.

I have to wonder if this assumption should be questioned.

The idea that compilation was necessary, was all the rage in the '80's.

YACC, and all of the accompanying trade-offs (e.g. LR, LALR, etc.) was 
researched and invented because it was simply unimaginable to use 
backtracking parsers back then.

In the late '90's we used backtracking parsers (the TXL language) to 
slurp in millions of lines of COBOL and highlight Y2K issues.

Today, I use Prolog for parsing.  Prolog allows me to easily parse 2D 
diagrams and convert them to running code.  I have a book on my shelf 
which expends incredible energy trying to show the theories of how to 
fit "above" and "below" relationships into the YACC/CFG paradigm, to 
little avail, since Prolog (and probably miniKanren) does it so easily.

And, neural nets were almost discarded back then.  Now, given increased 
processing power, deep learning drives cars.

Uncompiled JS is now the most ubiquitous language, found in every browser.

pt

_______________________________________________
Lisp Hug - the mailing list for LispWorks users
lisp-hug@lispworks.com
http://www.lispworks.com/support/lisp-hug.html

</pre>
                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: Understanding Lisp History...</h1><html><head><meta http-equiv="Content-Type" content="text/html charset=us-ascii"></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">Neural networks are compiled (-&gt; OpenCL), even to specialized hardware. Javascript is compiled (see for example&nbsp;<a href="https://en.wikipedia.org/wiki/Chrome_V8" class="">https://en.wikipedia.org/wiki/Chrome_V8</a>) - and it has no macros and no fexprs. Prolog has compilers.<div class=""><br class=""></div><div class="">If you want fully dynamic runtime transformations of Lisp code, you might want to think about: why and at what cost? A language/implementation is a tool and the features are selected knowing the tradeoffs. Using runtime transformations may give you more flexibility, but then you get more possibilities for runtime errors in complicated dynamic code...</div><div class=""><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><div><blockquote type="cite" class=""><div class="">Am 23.04.2017 um 18:38 schrieb Paul Tarvydas &lt;<a href="mailto:paultarvydas@gmail.com" class="">paultarvydas@gmail.com</a>&gt;:</div><br class="Apple-interchange-newline"><div class=""><div class="">On 2017-04-23 10:36 AM, Rainer Joswig wrote:<br class=""><blockquote type="cite" class="">... but the main problem is to make them compilable in a useful way.<br class=""></blockquote><br class="">I have to wonder if this assumption should be questioned.<br class=""><br class="">The idea that compilation was necessary, was all the rage in the '80's.<br class=""><br class="">YACC, and all of the accompanying trade-offs (e.g. LR, LALR, etc.) was researched and invented because it was simply unimaginable to use backtracking parsers back then.<br class=""><br class="">In the late '90's we used backtracking parsers (the TXL language) to slurp in millions of lines of COBOL and highlight Y2K issues.<br class=""><br class="">Today, I use Prolog for parsing. &nbsp;Prolog allows me to easily parse 2D diagrams and convert them to running code. &nbsp;I have a book on my shelf which expends incredible energy trying to show the theories of how to fit "above" and "below" relationships into the YACC/CFG paradigm, to little avail, since Prolog (and probably miniKanren) does it so easily.<br class=""><br class="">And, neural nets were almost discarded back then. &nbsp;Now, given increased processing power, deep learning drives cars.<br class=""><br class="">Uncompiled JS is now the most ubiquitous language, found in every browser.<br class=""><br class="">pt<br class=""><br class="">_______________________________________________<br class="">Lisp Hug - the mailing list for LispWorks users<br class=""><a href="mailto:lisp-hug@lispworks.com" class="">lisp-hug@lispworks.com</a><br class="">http://www.lispworks.com/support/lisp-hug.html<br class=""></div></div></blockquote></div><br class=""></div></div></body></html>

                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: Understanding Lisp History...</h1>
                 <pre>On 23 Apr 2017, at 15:36, Rainer Joswig &lt;joswig@lisp.de&gt wrote:
&gt 
&gt There has been recently some research on fexprs (especially what you found, the Kernel language), but the main problem is to make them compilable in a useful way. Expressive power also means that you have a lot of things possibly happening at runtime which make it very difficult to understand what your program is doing.

It seems to me that something like this:

(defun f (p a b c)
  (funcall (if p a b) c))

Is a pretty good example of the kind of horrible nightmare you get into: what is it meant to do if a is a fexpr and b is an expr?

I first learnt Lisp in dialects (Standard Lisp &amp; Cambridge Lisp) which had fexprs, and I'm fairly sure that I have no idea what they would have done with code like that except I think either they'd have treated both like exprs or something completely undefined would have happened.

If you want something actually sensible to happen then I think you end up with just huge and pervasive changes to everything: every function which takes a functional argument has to be prepared for it to be a fexpr and thus has to evaluate its other arguments only in the case that the thing isn't a fexpr (and it therefore needs the lexical environment those arguments came from so it can evaluate them).

Also, macros can get you quite a lot of what FEXPRs could (perhaps all of it?) albeit with different names for things (so, not EVAL to get the value of something) and you can't poke inside forms and expect to be able to get at the lexical environments of bits of them:

https://gist.github.com/tfeb/865bc9bf3f24d9c65574ad42df2c8f6b

(This is just a hack because I was bored waiting for an apparently infinitely slow supercomputer to do actually get around to running my code: it's not meant as a serious answer to the problem!)

--tim

_______________________________________________
Lisp Hug - the mailing list for LispWorks users
lisp-hug@lispworks.com
http://www.lispworks.com/support/lisp-hug.html

</pre>
                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>
                  Unable to render article 14339 because of ":DEFAULT stream decoding error on 
                  #&lt;SB-SYS:FD-STREAM for \"socket 192.168.43.216:52762, peer: 
                  116.202.254.214:119\" {1004501953}&gt: the octet sequence #(160) cannot be 
                  decoded." error</h1>
                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: Understanding Lisp History...</h1>
                 <pre>On 25 Apr 2017, at 22:18, Christopher Riesbeck &lt;c-riesbeck@northwestern.edu&gt wrote:
&gt 
&gt FUNCALL didn't exist in Lisp 1.5 (or 1.6). APPLY was limited to and EXPRs and LAMBDAs, according to the Lisp in Lisp definition in the Stanford 1.6 manual.

I think that Lisp 1.5 / 1.6 were Lisp-2s (that sounds very odd to say)?  Cambridge Lisp (which I started with) is a Lisp-1 so it doesn't need funcall (it has apply).   I don't remember what Standard Lisp was (but since the implementations I used were build on Cambridge Lisp they were probably Lisp-1s too).   From the manual it looks like apply in Cambridge Lisp probably doesn't work with fexprs, but it's not clear.

I think the answer is that the semantics of old lisps were just incoherent (certainly Cambridge Lisp had the normal interpreter-is-dynamically-scoped / compiler isn't thing).   It's easy (well, easy for me) to forget how much of this mess CL &amp; Scheme cleaned up.


_______________________________________________
Lisp Hug - the mailing list for LispWorks users
lisp-hug@lispworks.com
http://www.lispworks.com/support/lisp-hug.html

</pre>
                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: Understanding Lisp History...</h1>
                 <pre>
&gt Am 26.04.2017 um 14:15 schrieb tfb@tfeb.org:
&gt 
&gt On 25 Apr 2017, at 22:18, Christopher Riesbeck &lt;c-riesbeck@northwestern.edu&gt wrote:
&gt&gt 
&gt&gt FUNCALL didn't exist in Lisp 1.5 (or 1.6). APPLY was limited to and EXPRs and LAMBDAs, according to the Lisp in Lisp definition in the Stanford 1.6 manual.
&gt 
&gt I think that Lisp 1.5 / 1.6 were Lisp-2s (that sounds very odd to say)?  Cambridge Lisp (which I started with) is a Lisp-1 so it doesn't need funcall (it has apply).   I don't remember what Standard Lisp was (but since the implementations I used were build on Cambridge Lisp they were probably Lisp-1s too).   From the manual it looks like apply in Cambridge Lisp probably doesn't work with fexprs, but it's not clear.
&gt 
&gt I think the answer is that the semantics of old lisps were just incoherent (certainly Cambridge Lisp had the normal interpreter-is-dynamically-scoped / compiler isn't thing).   It's easy (well, easy for me) to forget how much of this mess CL &amp; Scheme cleaned up.

Absolutely true.

The compiler and runtime of a robust implementation like LispWorks is really light-years ahead of what we had with Cambridge Lisp. Just remembering it is painful. The Cambridge Lisp implementation I used had not much runtime safety and zero safety when using the FFI. It looked interesting and it had quite a bit functionality on those small personal computers of that time. But in practice it was painful to use. It was a great relief for me to have access to usually much more robust Common Lisp implementations, where I would reduce safety only in selected portions of my code.

For me, the robustness of LispWorks is one of its main features. ;-)




_______________________________________________
Lisp Hug - the mailing list for LispWorks users
lisp-hug@lispworks.com
http://www.lispworks.com/support/lisp-hug.html

</pre>
                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>from diagrams to Lisp</h1>
                 <pre>We have a project in which we use a free UML tool to create high level pictures of the system.
Of course the evolving system escapes the pictures and someone has to go redraw them....

We would like to move to the point where the diagram was a representation of the system at least at the same level of abstraction as the pictures.
There are a couple of graphical tools out there focused on other languages but I have been unable to discover any that emit Lisp.

Any recommendations would be appreciated.

Best Regards,
Tom Thurman





_______________________________________________
Lisp Hug - the mailing list for LispWorks users
lisp-hug@lispworks.com
http://www.lispworks.com/support/lisp-hug.html

</pre>
                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: from diagrams to Lisp</h1>
                 <pre>On 4/26/17 Apr 26 -12:23 PM, Thomas Thurman wrote:
&gt We have a project in which we use a free UML tool to create high level pictures of the system.
&gt Of course the evolving system escapes the pictures and someone has to go redraw them....
&gt 
&gt We would like to move to the point where the diagram was a representation of the system at least at the same level of abstraction as the pictures.
&gt There are a couple of graphical tools out there focused on other languages but I have been unable to discover any that emit Lisp.
&gt 

It would require you to write or find a code-walker, but if you did
that, you could use CL-DOT + graphviz to render your diagrams.

Cheers,
r

_______________________________________________
Lisp Hug - the mailing list for LispWorks users
lisp-hug@lispworks.com
http://www.lispworks.com/support/lisp-hug.html

</pre>
                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: from diagrams to Lisp</h1>
                 <pre>On 2017-04-26 01:23 PM, Thomas Thurman wrote:
 &gt We have a project in which we use a free UML tool to create high 
level pictures of the system.
 &gt Of course the evolving system escapes the pictures and someone has to 
go redraw them....
 &gt
 &gt We would like to move to the point where the diagram was a 
representation of the system at least at the same level of abstraction 
as the pictures.
 &gt There are a couple of graphical tools out there focused on other 
languages but I have been unable to discover any that emit Lisp.
 &gt
 &gt Any recommendations would be appreciated.

1. I have been compiling diagrams to code for several decades, but most 
of my work was OEM and not open-sourced.

I do have an example diagram compiler on my github 
https://github.com/guitarvydas/vsh .  It uses yEd (which is not a good 
"diagrams are code" editor (nothing is), but serviceable).  It 
self-compiles, to an assembly language (8 instructions).  Currently, it 
uses the assembler to create pipes and forks, acting as a visual shell 
for linux.  This could be ported to emit / interpret lisp. The diagram 
compiler uses Lisp loops instead of Prolog.

2. I have that there are only 2 box kinds in UML that can be compiled 
(I'd have to find my UML book to remember which boxes). UML also uses 
StateCharts, which can be compiled.  [Unfortunately, StateCharts allow 
for hidden concurrency - a bad idea IMO].

3. I have found that I use 2 kinds of diagrams.  (A) A top level 
architecture (hierarchical) diagram which is composed of concurrent 
boxes and lines (patterned after CAD/CAM for digital electronics). (B) 
Leaf nodes represented as state machines (StateCharts with all 
concurrency removed).  Snippets of code (expressions) on the transitions 
and entry/exit points specify the actual textual code at those points 
(such annotations should remain as textual code, not diagrams).

4. Look to see where Full Metal Jacket is at these days.  It created 
functional lisp from diagrams. http://web.onetel.com/~hibou/fmj/FMJ.html

5. Look at Drakon (real rocket science! :-).  It's written in Tcl/Tk, 
emits C, Erlang, etc. and it looked easy enough to port to lisp when I 
last looked at it a couple of years ago.  I think it needed one extra 
hack added to it to emit a closing paren for lisp. 
http://drakon-editor.sourceforge.net/language.html

6. FBP, flow-based programming http://www.jpaulmorrison.com/fbp/ (C++ 
and Java).  noFlo https://noflojs.org/ (JS).  FBP is very similar to the 
top level I use (I use "events" instead of "flows"). I don't know how 
hard it would be to port their emitters.  OTOH, diagram compilers tend 
to emit very regular code, so maybe an AWK script would be enough...

7. node-red?  JS.  (Allows for only 0 or 1 input ports, an odd notion IMO).

8. There are two papers on my github that describe one of the tools we 
built (and used to program a smart meter system).

I'd be glad to discuss any of the above, via email.

pt

_______________________________________________
Lisp Hug - the mailing list for LispWorks users
lisp-hug@lispworks.com
http://www.lispworks.com/support/lisp-hug.html

</pre>
                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>
                  Unable to render article 14345 because of ":DEFAULT stream decoding error on 
                  #&lt;SB-SYS:FD-STREAM for \"socket 192.168.43.216:52764, peer: 
                  116.202.254.214:119\" {1004FB8603}&gt: the octet sequence #(160) cannot be 
                  decoded." error</h1>
                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: from diagrams to Lisp</h1>
                 <pre>
Thanks!
We will take a look at these and review our pictures to see what makes sense.
(I have looked at Drakon before but the graphics in the version we looked at were dodgy, as connections wandered a bit on the diagram).
I will take you up on your kind offer when I have more questions.

Best Regards,
Thomas Thurman

&gt On Apr 26, 2017, at 1:36 PM, Paul Tarvydas &lt;paultarvydas@gmail.com&gt wrote:
&gt 
&gt On 2017-04-26 01:23 PM, Thomas Thurman wrote:
&gt &gt We have a project in which we use a free UML tool to create high level pictures of the system.
&gt &gt Of course the evolving system escapes the pictures and someone has to go redraw them....
&gt &gt
&gt &gt We would like to move to the point where the diagram was a representation of the system at least at the same level of abstraction as the pictures.
&gt &gt There are a couple of graphical tools out there focused on other languages but I have been unable to discover any that emit Lisp.
&gt &gt
&gt &gt Any recommendations would be appreciated.
&gt 
&gt 1. I have been compiling diagrams to code for several decades, but most of my work was OEM and not open-sourced.
&gt 
&gt I do have an example diagram compiler on my github https://github.com/guitarvydas/vsh .  It uses yEd (which is not a good "diagrams are code" editor (nothing is), but serviceable).  It self-compiles, to an assembly language (8 instructions).  Currently, it uses the assembler to create pipes and forks, acting as a visual shell for linux.  This could be ported to emit / interpret lisp. The diagram compiler uses Lisp loops instead of Prolog.
&gt 
&gt 2. I have that there are only 2 box kinds in UML that can be compiled (I'd have to find my UML book to remember which boxes). UML also uses StateCharts, which can be compiled.  [Unfortunately, StateCharts allow for hidden concurrency - a bad idea IMO].
&gt 
&gt 3. I have found that I use 2 kinds of diagrams.  (A) A top level architecture (hierarchical) diagram which is composed of concurrent boxes and lines (patterned after CAD/CAM for digital electronics). (B) Leaf nodes represented as state machines (StateCharts with all concurrency removed).  Snippets of code (expressions) on the transitions and entry/exit points specify the actual textual code at those points (such annotations should remain as textual code, not diagrams).
&gt 
&gt 4. Look to see where Full Metal Jacket is at these days.  It created functional lisp from diagrams. http://web.onetel.com/~hibou/fmj/FMJ.html
&gt 
&gt 5. Look at Drakon (real rocket science! :-).  It's written in Tcl/Tk, emits C, Erlang, etc. and it looked easy enough to port to lisp when I last looked at it a couple of years ago.  I think it needed one extra hack added to it to emit a closing paren for lisp. http://drakon-editor.sourceforge.net/language.html
&gt 
&gt 6. FBP, flow-based programming http://www.jpaulmorrison.com/fbp/ (C++ and Java).  noFlo https://noflojs.org/ (JS).  FBP is very similar to the top level I use (I use "events" instead of "flows"). I don't know how hard it would be to port their emitters.  OTOH, diagram compilers tend to emit very regular code, so maybe an AWK script would be enough...
&gt 
&gt 7. node-red?  JS.  (Allows for only 0 or 1 input ports, an odd notion IMO).
&gt 
&gt 8. There are two papers on my github that describe one of the tools we built (and used to program a smart meter system).
&gt 
&gt I'd be glad to discuss any of the above, via email.
&gt 
&gt pt
&gt 


_______________________________________________
Lisp Hug - the mailing list for LispWorks users
lisp-hug@lispworks.com
http://www.lispworks.com/support/lisp-hug.html

</pre>
                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: from diagrams to Lisp</h1><html><head><meta http-equiv="Content-Type" content="text/html charset=utf-8"></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class=""><br class=""><div><blockquote type="cite" class=""><div class="">On 26 Apr 2017, at 19:23, Thomas Thurman &lt;<a href="mailto:thurman.tom@imonmail.com" class="">thurman.tom@imonmail.com</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><div class="">We have a project in which we use a free UML tool to create high level pictures of the system.<br class="">Of course the evolving system escapes the pictures and someone has to go redraw them....<br class=""><br class="">We would like to move to the point where the diagram was a representation of the system at least at the same level of abstraction as the pictures.<br class="">There are a couple of graphical tools out there focused on other languages but I have been unable to discover any that emit Lisp.<br class=""><br class="">Any recommendations would be appreciated.</div></div></blockquote><br class=""></div><div>I can’t recommend it (it probably is not even available anymore), but in the 90s there was a tool named OMTool (pre-UML) that was written apparently in Smalltalk, and that saved the model and diagrams as sexps.</div><div><br class=""></div><div>Nowadays, most UML tools are able to save the model in XML using a standard in UML DTD. &nbsp;You could therefore implement a tool that would read these XML files and produce lisp sources.</div><div><br class=""></div><div>Modelio (which is the free evolution of the commercial CASE tool Objecteering), is able to generate code for various languages (thru plug-ins, some of them still being commercial). &nbsp;It should be possible to write a Modelio plug-in to generate lisp code; it’s written in Java, I guess one could write such plug-ins in Common Lisp using ABCL.</div><div><br class=""></div><div><br class=""></div><div>Now, I would suggest the reverse: write the UML model in form of sexps, and use them to generate the lisp code (ie. implement the macros to interpret those sexps as lisp code), and to generate UML XML files that can then be loaded in a UML OO CASE tool to draw the diagrams.</div><div><br class=""></div><div><br class=""></div><div class="">
<div style="color: rgb(0, 0, 0); letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class=""><div style="color: rgb(0, 0, 0); letter-spacing: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">--&nbsp;<br class="">__Pascal J. Bourguignon__<br class=""><br class=""><br class=""></div></div>

</div>
<br class=""></body></html>

                </article>
               </section>
              </section>
             </div>
            </div>
            <footer class="d-flex justify-content-center">
             <div>
              Updated at: 2020-12-07 08:26 UTC
             </div>
            </footer>
           </body>
          </html>