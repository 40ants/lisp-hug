<!DOCTYPE html>
<html lang=en>
           <head>
            <meta charset=UTF-8>
            <title>ENSURE-XX-AFTER-XX</title>
            <meta name=viewport
                  content="width=device-width, initial-scale=1.0">
            <link rel=stylesheet
                  href=https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css
                  integrity=sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2
                  crossorigin=anonymous>
            <style>
section.tree {
    padding-left: 2em;
}
section.tree:first-child {
    padding-left: 0;
}
.article-link {
  margin-bottom: 1em;
}
</style>
<!-- Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-9X3G9MMWZP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-9X3G9MMWZP');
</script>

           </head>
           <body>
            <header class="d-flex justify-content-center">
             <nav
                  class="navbar navbar-light bg-light w-100 mx-5 mb-3">
              <a class=navbar-brand href="/">Lisp HUG Maillist Archive</a>
             </nav>
            </header>
            <div class="d-flex justify-content-center">
             <div class="w-100 mx-5 px-3">
              <section class=tree>
               <article class=email>
                <h1>ENSURE-XX-AFTER-XX</h1><html><head><meta http-equiv="Content-Type" content="text/html; charset=us-ascii"></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; line-break: after-white-space;" class="">LW/64 for SMP contains 4 SYS primitives,&nbsp;<div class="">- SYS:ENSURE-LOADS-AFTER-LOADS</div><div class="">- SYS:ENSURE-MEMORY-AFTER-STORE</div><div class="">- SYS:ENSURE-STORES-AFTER-MEMORY</div><div class="">- SYS:ENSURE-STORES-AFTER-STORES</div><div class=""><br class=""></div><div class="">The LW documentation mentions these breifly. But on X86 all but ENSURE-MEMORY-AFTER-STORE are simply do-nothing functions. The remaining one, ENSURE-MEMORY-AFTER-STORE, executes an MFENCE instruction.</div><div class=""><br class=""></div><div class="">Here is a simple snippet of code that demonstrates the behavior of ENSURE-MEMORY-AFTER-STORE:</div><div class=""><br class=""></div><div class=""><div class=""><div class=""><font face="Monaco" class=""><span style="font-style: normal;" class="">(defun tst ()</span></font></div><div class=""><font face="Monaco" class=""><span style="font-style: normal;" class="">&nbsp; (let ((begin-sem1 (mp:make-semaphore :count 0))</span></font></div><div class=""><font face="Monaco" class=""><span style="font-style: normal;" class="">&nbsp; &nbsp; &nbsp; &nbsp; (begin-sem2 (mp:make-semaphore :count 0))</span></font></div><div class=""><font face="Monaco" class=""><span style="font-style: normal;" class="">&nbsp; &nbsp; &nbsp; &nbsp; (sem-r1 &nbsp; &nbsp; (mp:make-semaphore :count 0))</span></font></div><div class=""><font face="Monaco" class=""><span style="font-style: normal;" class="">&nbsp; &nbsp; &nbsp; &nbsp; (sem-r2 &nbsp; &nbsp; (mp:make-semaphore :count 0))</span></font></div><div class=""><font face="Monaco" class=""><span style="font-style: normal;" class="">&nbsp; &nbsp; &nbsp; &nbsp; (det &nbsp; &nbsp; &nbsp; &nbsp;0)</span></font></div><div class=""><font face="Monaco" class=""><span style="font-style: normal;" class="">&nbsp; &nbsp; &nbsp; &nbsp; (x &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0)</span></font></div><div class=""><font face="Monaco" class=""><span style="font-style: normal;" class="">&nbsp; &nbsp; &nbsp; &nbsp; (y &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0)</span></font></div><div class=""><font face="Monaco" class=""><span style="font-style: normal;" class="">&nbsp; &nbsp; &nbsp; &nbsp; (r1 &nbsp; &nbsp; &nbsp; &nbsp; 1)</span></font></div><div class=""><font face="Monaco" class=""><span style="font-style: normal;" class="">&nbsp; &nbsp; &nbsp; &nbsp; (r2 &nbsp; &nbsp; &nbsp; &nbsp; 1))</span></font></div><div class=""><font face="Monaco" class=""><span style="font-style: normal;" class="">&nbsp; &nbsp; (flet ((thr1 ()</span></font></div><div class=""><font face="Monaco" class=""><span style="font-style: normal;" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(loop do</span></font></div><div class=""><font face="Monaco" class=""><span style="font-style: normal;" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(mp:semaphore-acquire begin-sem1)</span></font></div><div class=""><font face="Monaco" class=""><span style="font-style: normal;" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(loop until (zerop (lw:mt-random 8)))</span></font></div><div class=""><font face="Monaco" class=""><span style="font-style: normal;" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf x 1)</span></font></div><div class=""><font face="Monaco" class=""><span style="font-style: normal;" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span></font></div><div class=""><font face="Monaco" class=""><span style="font-style: normal;" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;; at least 1 thread with an MFENCE prevents reorders overall</span></font></div><div class=""><font face="Monaco" class=""><span style="font-style: normal;" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;; (sys:ensure-memory-after-store)</span></font></div><div class=""><font face="Monaco" class=""><span style="font-style: normal;" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span></font></div><div class=""><font face="Monaco" class=""><span style="font-style: normal;" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf r1 y)</span></font></div><div class=""><font face="Monaco" class=""><span style="font-style: normal;" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(mp:semaphore-release sem-r1)))</span></font></div><div class=""><font face="Monaco" class=""><span style="font-style: normal;" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(thr2 ()</span></font></div><div class=""><font face="Monaco" class=""><span style="font-style: normal;" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(loop do</span></font></div><div class=""><font face="Monaco" class=""><span style="font-style: normal;" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(mp:semaphore-acquire begin-sem2)</span></font></div><div class=""><font face="Monaco" class=""><span style="font-style: normal;" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(loop until (zerop (lw:mt-random 8)))</span></font></div><div class=""><font face="Monaco" class=""><span style="font-style: normal;" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf y 1)</span></font></div><div class=""><font face="Monaco" class=""><span style="font-style: normal;" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;; (sys:ensure-memory-after-store) ;; 2nd one not needed</span></font></div><div class=""><font face="Monaco" class=""><span style="font-style: normal;" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(setf r2 x)</span></font></div><div class=""><font face="Monaco" class=""><span style="font-style: normal;" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(mp:semaphore-release sem-r2))))</span></font></div><div class=""><font face="Monaco" class=""><span style="font-style: normal;" class="">&nbsp; &nbsp; &nbsp; (let ((proc1 (mp:process-run-function :thread1 () #'thr1))</span></font></div><div class=""><font face="Monaco" class=""><span style="font-style: normal;" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (proc2 (mp:process-run-function :thread2 () #'thr2)))</span></font></div><div class=""><font face="Monaco" class=""><span style="font-style: normal;" class="">&nbsp; &nbsp; &nbsp; &nbsp; (unwind-protect</span></font></div><div class=""><font face="Monaco" class=""><span style="font-style: normal;" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (loop for iter from 0 do</span></font></div><div class=""><font face="Monaco" class=""><span style="font-style: normal;" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (setf x 0</span></font></div><div class=""><font face="Monaco" class=""><span style="font-style: normal;" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; y 0)</span></font></div><div class=""><font face="Monaco" class=""><span style="font-style: normal;" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (mp:semaphore-release begin-sem1)</span></font></div><div class=""><font face="Monaco" class=""><span style="font-style: normal;" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (mp:semaphore-release begin-sem2)</span></font></div><div class=""><font face="Monaco" class=""><span style="font-style: normal;" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (mp:semaphore-acquire sem-r1)</span></font></div><div class=""><font face="Monaco" class=""><span style="font-style: normal;" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (mp:semaphore-acquire sem-r2)</span></font></div><div class=""><font face="Monaco" class=""><span style="font-style: normal;" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (when (and (zerop r1)</span></font></div><div class=""><font face="Monaco" class=""><span style="font-style: normal;" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(zerop r2))</span></font></div><div class=""><font face="Monaco" class=""><span style="font-style: normal;" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (incf det)</span></font></div><div class=""><font face="Monaco" class=""><span style="font-style: normal;" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (format t "~D reorders detected after ~D iterations~%" det iter)))</span></font></div><div class=""><font face="Monaco" class=""><span style="font-style: normal;" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (mp:process-terminate proc1)</span></font></div><div class=""><font face="Monaco" class=""><span style="font-style: normal;" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (mp:process-terminate proc2))</span></font></div><div class=""><font face="Monaco" class=""><span style="font-style: normal;" class="">&nbsp; &nbsp; &nbsp; &nbsp; ))))</span></font></div></div></div><div class=""><br class=""></div><div class=""><br class=""></div><div class="">With the ENSURE-MEMORY-AFTER-STORE commented out, a run of this code produces output like this:</div><div class=""><br class=""></div><div class=""><div class="">CL-USER 98 &gt; (tst)</div><div class="">1 reorders detected after 33123 iterations</div><div class="">2 reorders detected after 80515 iterations</div><div class="">3 reorders detected after 402985 iterations</div><div class="">4 reorders detected after 920288 iterations</div><div class="">5 reorders detected after 1137734 iterations</div><div class="">6 reorders detected after 1152909 iterations</div><div class="">7 reorders detected after 1344047 iterations</div><div class="">8 reorders detected after 2496919 iterations</div></div><div class="">...</div><div class=""><br class=""></div><div class="">Kill the function with Break from the Listener window.</div><div class=""><br class=""></div><div class="">By uncommenting at least one of the ENSURE-MEMORY-AFTER-STORE, a re-run of the code produces quiet output.</div><div class=""><br class=""></div><div class="">The above code certainly is not a demonstration of how one should program shared mutable access. But it is a possible component for lock-free primitives.</div><div class=""><br class=""></div><div class="">What it demonstrates is that the Intel X86 will reorder loads / stores as needed to keep the CPU as busy as possible. These are not instruction reorderings, but rather just the re-scheduling of memory transfers, which can vary with conditions such as cache state, and main memory access times.</div><div class=""><br class=""></div><div class="">A single thread can never detect its own orderings. It takes SMP to be able to show the effect.</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><br class=""></div></body></html>

               </article>
               <section class=tree>
                <article class=email>
                 <h1>Re: ENSURE-XX-AFTER-XX</h1>
                 <p>
                  Unable to parse email body. Email id is 15132
                </article>
               </section>
              </section>
             </div>
            </div>
            <footer class="d-flex justify-content-center">
             <div>
              Updated at: 2020-12-10 08:29 UTC
             </div>
            </footer>
           </body>
          </html>