<!DOCTYPE html>
<html lang=en>
           <head>
            <meta charset=UTF-8>
            <title>Calendar Widget?</title>
            <meta name=viewport
                  content="width=device-width, initial-scale=1.0">
            <link rel=stylesheet
                  href=https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css
                  integrity=sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2
                  crossorigin=anonymous>
            <style>
section.tree {
    padding-left: 2em;
}
section.tree:first-child {
    padding-left: 0;
}
.article-link {
  margin-bottom: 1em;
}
</style>
<!-- Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-9X3G9MMWZP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-9X3G9MMWZP');
</script>

           </head>
           <body>
            <header class="d-flex justify-content-center">
             <nav
                  class="navbar navbar-light bg-light w-100 mx-5 mb-3">
              <a class=navbar-brand href="/">Lisp HUG Maillist Archive</a>
             </nav>
            </header>
            <div class="d-flex justify-content-center">
             <div class="w-100 mx-5 px-3">
              <section class=tree>
               <article class=email>
                <h1>Calendar Widget?</h1><html><head><meta http-equiv="Content-Type" content="text/html charset=us-ascii"></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; ">It is becoming more frequently the case that having a little Calendar widget available to the user in GUI's would be vary convenient to have. Has anyone seen one of those for Lisp?<div><br><div apple-content-edited="true">
<span class="Apple-style-span" style="border-collapse: separate; color: rgb(0, 0, 0); font-family: Helvetica; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-align: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-border-horizontal-spacing: 0px; -webkit-border-vertical-spacing: 0px; -webkit-text-decorations-in-effect: none; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; "><div>Dr. David McClain</div><div><a href="mailto:dbm@refined-audiometrics.com">dbm@refined-audiometrics.com</a></div><div><br></div></span><br class="Apple-interchange-newline">

</div>
<br></div></body></html>

               </article>
               <section class=tree>
                <article class=email>
                 <h1>Re: Calendar Widget?</h1>
                 <pre>
Am 11.08.13 19:18, schrieb David McClain:
&gt It is becoming more frequently the case that having a little Calendar
&gt widget available to the user in GUI's would be vary convenient to have.
&gt Has anyone seen one of those for Lisp?
&gt
&gt Dr. David McClain
&gt dbm@refined-audiometrics.com &lt;mailto:dbm@refined-audiometrics.com&gt
&gt
&gt
&gt
http://www.weitz.de/midgets/

jens

_______________________________________________
Lisp Hug - the mailing list for LispWorks users
lisp-hug@lispworks.com
http://www.lispworks.com/support/lisp-hug.html


</pre>
                </article>
                <section class=tree>
                 <article class=email>
                  <h1>Re: Calendar Widget?</h1>
                  <p>
                   Unable to parse email body. Email id is 12384
                 </article>
                 <section class=tree>
                  <article class=email>
                   <h1>Re: Calendar Widget?</h1>
                   <pre>
Hi Madhu,

I can't compile this code because of :

  (user:date :utime utime :stream nil :tz (tz tz-pane))

Do you know how to define this date function?


Best,
Camille


On 12 ao√ªt 2013, at 04:39, Madhu &lt;enometh@meer.net&gt wrote:

&gt 
&gt 
&gt * Jens Teich &lt;5207C96E.4010608@jensteich.de&gt Wrote on Sun, 11 Aug 2013 19:27:10 +0200:
&gt | Am 11.08.13 19:18, schrieb David McClain:
&gt |
&gt |&gt It is becoming more frequently the case that having a little Calendar
&gt |&gt widget available to the user in GUI's would be vary convenient to have.
&gt |&gt Has anyone seen one of those for Lisp?
&gt |
&gt | http://www.weitz.de/midgets/
&gt 
&gt A few years ago, when I was getting started with CAPI I needed to
&gt extend this widget, and ended up rewriting it, I'm appending that
&gt code, (now placed in Public Domain) in case it is useful for your
&gt further tinkering. --- Madhu
&gt 
&gt 
&gt ;;; -*- Mode: LISP; Package: :cl-user; BASE: 10; Syntax: ANSI-Common-Lisp; -*-
&gt ;;;
&gt ;;;   Time-stamp: &lt;2009-10-11 18:41:33 IST&gt
&gt ;;;   Touched: Tue Jun 02 21:47:14 2009 +0530 &lt;enometh@meer.net&gt
&gt ;;;   Bugs-To: enometh@meer.net
&gt ;;;   Status: Experimental.  Do not redistribute
&gt ;;;   Copyright (C) 2009 Madhu.  All Rights Reserved.
&gt ;;;
&gt (defpackage "DATE-TIME-CAPI"
&gt  (:use "CL")
&gt  (:export
&gt   "DATE-INTERFACE"
&gt   "DATE-INTERFACE-DAY"
&gt   "DATE-INTERFACE-MONTH"
&gt   "DATE-INTERFACE-YEAR"
&gt   "DATE-TIME-INTERFACE"
&gt   "PROMPT-FOR-DATE-AND-TIME"
&gt   "TIME-INTERFACE"
&gt   "TIME-INTERFACE-HOUR"
&gt   "TIME-INTERFACE-MINUTE"
&gt   "TIME-INTERFACE-SECOND"))
&gt (in-package "DATE-TIME-CAPI")
&gt 
&gt ;; 0       1       2     3     4      5     6    7           8
&gt ;; second, minute, hour, date, month, year, day, daylight-p, zone
&gt 
&gt (defun first-day-of-month (month year)	;  "Mon 0"
&gt  (nth-value 6 (decode-universal-time
&gt 		(encode-universal-time 0 0 0 1 month year))))
&gt 
&gt (defun days-in-month (month year)
&gt  (ecase month
&gt    (1 31) (2 (if (system::leap-year-p year) 29 28)) (3 31) (4 30)
&gt    (5 31) (6 30) (7 31) (8 31) (9 30) (10 31) (11 30) (12 31)))
&gt 
&gt 
&gt ;;; ----------------------------------------------------------------------
&gt ;;;
&gt ;;;
&gt ;;;
&gt 
&gt (capi:define-interface date-interface ()
&gt  ((day :initform (nth-value 3 (get-decoded-time))
&gt 	:initarg :day :reader date-interface-day)
&gt   (last-day-of-month-hack :initform nil)
&gt   (month :initform (nth-value 4 (get-decoded-time))
&gt 	  :initarg :month :reader date-interface-month)
&gt   (year :initform (nth-value 5 (get-decoded-time))
&gt 	 :initarg :year :reader date-interface-year)
&gt   (pbuts :initform
&gt 	  (loop for i below 49
&gt 		collect (make-instance 'capi:item-pinboard-object
&gt 			  :print-function
&gt 			  (lambda (x)
&gt 			    (typecase x
&gt 			      (null "")
&gt 			      (string x)
&gt 			      (t (princ-to-string x)))))
&gt 		into ret finally (return (apply 'vector ret))))
&gt   (callback :initarg :callback :initform nil)
&gt   start end)
&gt  (:panes
&gt   (month-pane capi:option-pane
&gt 	       :selected-item month
&gt 	       :items '(1 2 3 4 5 6 7 8 9 10 11 12)
&gt 	       :print-function (lambda (n)
&gt 				 (elt #("Jan" "Feb" "Mar" "Apr" "May" "Jun"
&gt 					"Jul" "Aug" "Sep" "Oct" "Nov" "Dec")
&gt 				      (1- n)))
&gt 	       :callback-type :interface-data
&gt 	       :selection-callback (lambda (intf data)
&gt 				     (unless (= month data)
&gt 				       (reset-calendar-date-highlight intf)
&gt 				       (setq month data)
&gt 				       (reset-date-interface intf)
&gt 				       (when callback (funcall callback intf)))))
&gt   (year-pane capi:text-input-range
&gt 	      :value year :start 1 :end 4500 :callback-type :interface-data
&gt 	      :callback (lambda (intf data)
&gt 			  (unless (= year data)
&gt 			    (reset-calendar-date-highlight intf)
&gt 			    (setq year data)
&gt 			    (reset-date-interface intf)
&gt 			    (when callback (funcall callback intf)))))
&gt   (calendar-pane capi:pinboard-layout
&gt 		  :input-model '(((:button-1 :press) select-calendar-date))
&gt 		  :fit-size-to-children t
&gt 		  :visible-min-width 300
&gt 		  :visible-min-height 150
&gt 		  :description (coerce pbuts 'list)))
&gt  (:layouts
&gt   (row-layout capi:row-layout '(month-pane year-pane))
&gt   (column-layout capi:column-layout '(row-layout calendar-pane)))
&gt  (:default-initargs
&gt   :create-callback 'reset-date-interface
&gt   :title "Date Interface:"
&gt   :layout 'column-layout))
&gt 
&gt (defun initialize-calendar-pane (date-interface calendar-pane)
&gt  (check-type date-interface date-interface)
&gt  (check-type calendar-pane capi:pinboard-layout)
&gt  (multiple-value-bind (left top right bottom)
&gt      (gp:get-string-extent calendar-pane "XXX"
&gt 			    (capi:simple-pane-font calendar-pane))
&gt    (let ((width (- right left)) (height (- bottom top)))
&gt      ;;(setq width (floor (* width 2)) height (floor (* height 2)))
&gt      (with-slots (pbuts) date-interface
&gt 	(loop for i below 49 for p = (elt pbuts i)
&gt 	      for (row col) = (multiple-value-list (floor i 7))
&gt 	      when (&lt; i 7) do
&gt 	      (setf (capi:item-data p)
&gt 		    (elt #("Sun" "Mon" "Tue" "Wed" "Thu" "Fri" "Sat") i))
&gt 	      do
&gt 	      (capi:set-hint-table
&gt 	       p (list :x (+ (* 2 col width) (floor width 2))
&gt 		       :y (+ (* 2 row height) (floor height 2))
&gt 		       :external-min-width width
&gt 		       :external-min-height height
&gt 		       :external-max-width t
&gt 		       :external-max-height t))
&gt 	      (setf (capi:pinboard-pane-position p)
&gt 		    (values (+ (* col 2 width) (floor width 2))
&gt 			    (+ (* row 2 height) (floor height 2)))
&gt 		    (capi:pinboard-pane-size p)
&gt 		    (values width height)))))))
&gt 
&gt (defun reset-calendar-date-highlight (intf)
&gt  "Internal."
&gt  (check-type intf date-interface)
&gt  (with-slots (day pbuts start calendar-pane) intf
&gt    (capi:unhighlight-pinboard-object
&gt     calendar-pane (elt pbuts (+ start day -1))
&gt     :redisplay t)))
&gt 
&gt (defun reset-date-interface (intf)
&gt  "Internal."
&gt  (check-type intf date-interface)
&gt  (with-slots (day month year pbuts calendar-pane start end) intf
&gt    (unless (capi:item-data (elt pbuts 0))
&gt      (initialize-calendar-pane intf calendar-pane))
&gt    ;;0  1  2  3  4  5  6
&gt    ;;S  M0 T  W  T  F  S
&gt    ;;7  8  9 10 11 12 13
&gt    (setq start (+ 7 (mod (+ (first-day-of-month month year) 8) 7))
&gt 	  end (+ start (days-in-month month year)))
&gt    (with-slots (last-day-of-month-hack) intf ;XXX
&gt      (cond ((&lt; (+ day start) end)
&gt 	     (when (and last-day-of-month-hack
&gt 			(&lt; last-day-of-month-hack end))
&gt 	       (setq day last-day-of-month-hack)
&gt 	       (setq last-day-of-month-hack nil)))
&gt 	    (t (setq last-day-of-month-hack day)
&gt 	       (setq day (- end start)))))
&gt    (loop for i from 7 below 49
&gt 	  for p = (elt pbuts i)
&gt 	  for d = (- i start -1)
&gt 	  do
&gt 	  (setf (capi:item-data p)
&gt 		(if (and (&lt;= start i) (&lt; i end)) d))
&gt 	  (if (= d day)
&gt 	      (capi:highlight-pinboard-object calendar-pane p
&gt 					      :redisplay t))
&gt 	  (capi:redraw-pinboard-object p t))))
&gt 
&gt (defun select-calendar-date (calendar-pane x y)
&gt  "Internal."
&gt  (check-type calendar-pane capi:pinboard-layout)
&gt  (let ((p (capi:pinboard-object-at-position calendar-pane x y)))
&gt    (typecase p
&gt      (capi:item-pinboard-object
&gt       (when (numberp (capi:item-data p))
&gt 	 (let ((intf (capi:element-interface calendar-pane)))
&gt 	   (check-type intf date-interface)
&gt 	   (with-slots (day callback) intf
&gt 	     (unless (= day (capi:item-data p))
&gt 	       (reset-calendar-date-highlight intf)
&gt 	       (setq day (capi:item-data p))
&gt 	       (reset-date-interface intf)
&gt 	       (when callback (funcall callback intf))))))))))
&gt 
&gt (defun date-interface-set (self &amp;key (redisplay t) ((:day dd)) ((:month mm))
&gt 			   ((:year yy)) &amp;aux modp)
&gt  (check-type self date-interface)
&gt  (when dd (check-type dd (integer 1 31)))
&gt  (when mm (check-type mm (integer 1 12)))
&gt  (when yy (check-type yy (integer 0)))	;TODO
&gt  (with-slots (day month year year-pane month-pane callback) self
&gt    (when dd
&gt      (unless (= dd day)
&gt 	(when redisplay
&gt 	  (reset-calendar-date-highlight self))
&gt 	(setq day dd)
&gt 	(setq modp t)))
&gt    (when mm
&gt      (unless (= mm month)
&gt 	(unless modp
&gt 	  (when redisplay
&gt 	    (reset-calendar-date-highlight self)))
&gt 	(setq month mm)
&gt 	(setq modp t)))
&gt    (when yy
&gt      (unless (= yy year)
&gt 	(unless modp
&gt 	  (when redisplay
&gt 	    (reset-calendar-date-highlight self)))
&gt 	(setq year yy)
&gt 	(setq modp t)))
&gt    (unless (= year (capi:text-input-range-value year-pane))
&gt      (setf (capi:text-input-range-value year-pane ) year))
&gt    (unless (= month (capi:choice-selected-item month-pane))
&gt      (setf (capi:choice-selected-item month-pane) month))
&gt    (when modp
&gt      (when redisplay
&gt 	(reset-date-interface self))
&gt      (when callback (funcall callback self)))))
&gt 
&gt #||
&gt (capi:display(setq $x (make-instance 'date-interface)))
&gt (date-interface-year $x)
&gt (date-interface-month $x)
&gt (date-interface-day $x)
&gt (date-interface-set $x :day 30)
&gt (date-interface-set $x :day 30 :year 1974 :month 2)
&gt (date-interface-set $x :month 3 :year 1974)
&gt (capi:display $x)
&gt ||#
&gt 
&gt 
&gt ;;; ----------------------------------------------------------------------
&gt ;;;
&gt ;;;
&gt ;;;
&gt 
&gt (defun reset-time-interface (intf)
&gt  "Internal."
&gt  (check-type intf time-interface)
&gt  (with-slots (callback) intf
&gt    (when callback (funcall callback intf))))
&gt 
&gt (capi:define-interface time-interface  ()
&gt  ((hour :initarg :hour :initform (nth-value 2 (get-decoded-time))
&gt 	 :reader time-interface-hour)
&gt   (minute :initarg :minute :initform (nth-value 1 (get-decoded-time))
&gt 	   :reader time-interface-minute)
&gt   (second :initarg :minute :initform (nth-value 0 (get-decoded-time))
&gt 	   :reader time-interface-second)
&gt   (callback :initarg :callback :initform nil))
&gt  (:panes
&gt   (hour-pane capi:text-input-range :start 0 :end 23 :value hour
&gt 	      :wraps-p t :callback-type :interface-data :callback
&gt 	      (lambda (intf data) (setq hour data) (reset-time-interface intf)))
&gt   (minute-pane capi:text-input-range :start 0 :end 59 :value minute
&gt 		:wraps-p t :callback-type :interface-data :callback
&gt 		(lambda (intf data) (setq minute data) (reset-time-interface intf)))
&gt   (second-pane capi:text-input-range :start 0 :end 59 :value second
&gt 		:wraps-p t :callback-type :interface-data :callback
&gt 		(lambda (intf data) (setq second data) (reset-time-interface intf))))
&gt  (:layouts
&gt   (row-layout capi:row-layout '(hour-pane minute-pane second-pane)))
&gt  (:default-initargs
&gt   :create-callback 'reset-time-interface
&gt   :title "Time: HH:MM:SS"
&gt   :layout 'row-layout))
&gt 
&gt (defun time-interface-set (self &amp;key ((:hour hh)) ((:minute mm))
&gt 			   ((:second ss))  &amp;aux modp)
&gt  (check-type self time-interface)
&gt  (when hh (check-type hh (integer 0 23)))
&gt  (when mm (check-type mm (integer 0 59)))
&gt  (when ss (check-type ss (integer 0 59)))
&gt  (with-slots (hour minute second hour-pane minute-pane second-pane) self
&gt    (when hh
&gt      (unless (= hh hour)
&gt 	(setq hour hh)
&gt 	(setq modp t)))
&gt    (when mm
&gt      (unless (= mm minute)
&gt 	(setq minute mm)
&gt 	(setq modp t)))
&gt    (when ss
&gt      (unless (= ss second)
&gt 	(setq second ss)
&gt 	(setq modp t)))
&gt    (mapcar (lambda (value pane)
&gt 	      (when value
&gt 		(unless (= value (capi:text-input-range-value pane))
&gt 		  (setf (capi:text-input-range-value pane) value))))
&gt 	    (list hour minute second)
&gt 	    (list hour-pane minute-pane second-pane)))
&gt  (when modp (reset-time-interface self)))
&gt 
&gt #||
&gt (capi:display (setq $x (make-instance 'time-interface)))
&gt (time-interface-set $x :hour 10)
&gt (time-interface-set $x :minute 10)
&gt (time-interface-minute $x)
&gt ||#
&gt 
&gt 
&gt ;;;----------------------------------------------------------------------
&gt ;;;
&gt ;;; CAPI TIMEZONE INTERFACE FOR COMMONLISP TIMEZONES
&gt ;;;
&gt 
&gt (defun %format-tz (zone)
&gt  (check-type zone (rational -24 24))
&gt  (format nil "~?" "~:[+~;-~]~2,'0d~2,'0d"
&gt 	  (multiple-value-bind (hour min) (truncate zone 1)
&gt 	    (list (plusp zone) (abs hour) (truncate (* 60 (abs min)))))))
&gt 
&gt (defun %parse-rational (string)
&gt  "Read [+-][0-9]*[/][0-9]*.  Return a rational number. Second return value is
&gt a new string consisting of just the legal characters in the input specified in
&gt the previous regexp."
&gt  (let (sign num den slash corrected)
&gt    (map nil (lambda (c)
&gt 	       (case c
&gt 		 ((#\- #\+)
&gt 		  (when (and (not sign) (not num))
&gt 		    (push c corrected)
&gt 		    (setq sign (ecase c (#\+ 1) (#\- -1)))))
&gt 		 ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
&gt 		  (cond ((not slash)
&gt 			 (unless num (setq num 0))
&gt 			 (push c corrected)
&gt 			 (setq num (+ (* num 10) (digit-char-p c))))
&gt 			(t (unless den (setq den 0))
&gt 			   (push c corrected)
&gt 			   (setq den (+ (* den 10) (digit-char-p c))))))
&gt 		 (#\/ (unless slash
&gt 			(push c corrected)
&gt 			(setq slash t)))))
&gt 	 string)
&gt    (let ((ret num))
&gt      (when ret
&gt 	(when sign
&gt 	  (setq ret (* sign ret)))
&gt 	(when slash
&gt 	  (when den
&gt 	    (unless (zerop den)
&gt 	      (setq ret (/ ret den)))
&gt 	    (check-type ret rational))))
&gt      (values ret (coerce (nreverse corrected) 'string)))))
&gt 
&gt (defun %signum (x)
&gt  (if (zerop x)
&gt      1
&gt      (signum x)))
&gt 
&gt (defun %setf-tz (obj new-tz &amp;optional where)
&gt  "Optional argument WHERE indicates which slot of OBJ is triggering the
&gt change, and so should not be set."
&gt  (check-type obj timezone-interface)
&gt  (assert (and (rationalp new-tz) (&lt;= -24 new-tz 24) (integerp (* 3600 new-tz))))
&gt  (macrolet ((%bif (b &amp;body body)
&gt 	       `(unless (etypecase where
&gt 			  (atom (eql ,b where))
&gt 			  (list (find ,b where)))
&gt 		  ,@body)))
&gt    (with-slots (tz ppout hhtxt mmtxt tzinp callback) obj
&gt      (%bif 'tz (setq tz new-tz))
&gt      (%bif 'ppout (setf (capi:title-pane-text ppout) (%format-tz tz)))
&gt      (multiple-value-bind (hh mm2) (truncate tz 1)
&gt 	(multiple-value-bind (mm ss) (truncate (* (abs mm2) 60) 1)
&gt 	  (declare (ignore ss))		; unfortunately
&gt 	  (%bif 'hhtxt (setf (capi:text-input-range-value hhtxt) (* (- (%signum hh)) (abs hh))))
&gt 	  (%bif 'mmtxt (setf (capi:text-input-range-value mmtxt) mm))))
&gt      (%bif 'tzinp (setf (capi:text-input-pane-text tzinp) (princ-to-string tz)))
&gt      (when callback (funcall callback obj)))))
&gt 
&gt (capi:define-interface timezone-interface ()
&gt  ((tz :initform -11/2 :accessor tz :initarg :tz)
&gt   (callback :initarg :callback :initform nil))
&gt  (:panes
&gt   (ppout capi:title-pane :text (%format-tz tz))
&gt   (sptxt capi:title-pane :text ":")
&gt   (hhtxt capi:text-input-range :start -23 :end 23 :wraps-p t
&gt 	  :value (* (- (%signum tz)) (truncate tz))
&gt 	  :callback-type :interface-data
&gt 	  :callback (lambda (intf hh)
&gt 		      (assert (&lt;= -23 hh 23))
&gt 		      (let ((mm (capi:text-input-range-value mmtxt)))
&gt 			(assert (&lt;= 0 mm 59))
&gt 			(%setf-tz intf
&gt 				  (* (- (%signum hh))
&gt 				     (+ (abs hh) (/ mm 60)))
&gt 				  'hhtxt))))
&gt   (mmtxt capi:text-input-range :start 0 :end 59 :wraps-p t
&gt 	  :value (abs (* 60 (nth-value 1 (truncate tz 1))))
&gt 	  :callback-type :interface-data
&gt 	  :callback (lambda (intf mm)
&gt 		      (assert (&lt;= 0 mm 59))
&gt 		      (let ((hh (capi:text-input-range-value hhtxt)))
&gt 			(assert (&lt;= -23 hh 23))
&gt 			(%setf-tz intf
&gt 				  (* (- (%signum hh))
&gt 				     (+ (abs hh) (/ mm 60)))
&gt 				  'mmtxt))))
&gt   (tzinp capi:text-input-pane
&gt 	  :text (princ-to-string tz)
&gt 	  :help-key 'tzinp		;FIXME
&gt 	  :max-characters 10
&gt 	  :max-width t
&gt 	  :callback (lambda (data intf)
&gt 		      (funcall (capi:text-input-pane-change-callback tzinp)
&gt 			       data tzinp intf 0)
&gt 		      (setf (capi:text-input-pane-text tzinp)
&gt 			    (princ-to-string tz)))
&gt 	  :change-callback (lambda (text self intf caret)
&gt 			     (declare (ignore self caret))
&gt 			     (multiple-value-bind (new-tz corrected)
&gt 				 (%parse-rational text)
&gt 			       (unless (equal (capi:text-input-pane-text tzinp) corrected)
&gt 				 (setf (capi:text-input-pane-text tzinp) corrected))
&gt 			       (when (and new-tz (&lt;= -24 new-tz 24) (integerp (* 3600 new-tz)))
&gt 				 (%setf-tz intf new-tz 'tzinp))))))
&gt  (:layouts
&gt   (hhmm capi:row-layout '(hhtxt sptxt mmtxt) :adjust :center)
&gt   (main-layout capi:column-layout '(ppout hhmm tzinp)))
&gt  (:default-initargs
&gt   :title "Common Lisp Timezone:"
&gt   :layout 'main-layout
&gt   :enable-tooltips t
&gt   :help-callback
&gt   (lambda (intf pane type help-key)
&gt     (declare (ignore intf pane))
&gt     (when (and (eq type :tooltip)
&gt 		(eq help-key 'tzinp))
&gt       "time zone n. a rational multiple of 1/3600 between -24 (inclusive) and 24 (inclusive) that represents a time zone as a number of hours offset from Greenwich Mean Time. Time zone values increase with motion to the west, so Massachusetts, U.S.A. is in time zone 5, California, U.S.A. is time zone 8, and Moscow, Russia is time zone -3."))))
&gt 
&gt (defmethod (setf tz) :around (new-tz (obj timezone-interface) &amp;optional)
&gt  (unless (= new-tz (slot-value obj 'tz))
&gt    (%setf-tz obj new-tz)))
&gt 
&gt #+nil
&gt (capi:display (setq $x (make-instance 'timezone-interface :tz -6 :callback (lambda (x) (warn "bzzt: ~S" x)))))
&gt 
&gt 
&gt ;;; ----------------------------------------------------------------------
&gt ;;;
&gt ;;; CAPI DATE-TIME INTERFACE
&gt ;;;
&gt 
&gt (capi:define-interface date-time-interface ()
&gt  ((supplied-tz :initform 0 :initarg :tz)
&gt   (utime :initform 0 :initarg :utime)
&gt   (callback :initarg :callback :initform nil)
&gt   (selfstash :initform nil))
&gt  (:panes
&gt   (date-display capi:display-pane :text "" :title "Date/Time:"
&gt 		 :max-width t)
&gt   (tz-pane timezone-interface :tz supplied-tz
&gt 	    :callback
&gt 	    (lambda (intf)
&gt 	      (assert (eql intf tz-pane)) ;
&gt 	      (multiple-value-bind
&gt 		    (second minute hour date month year weekday dstp timezone)
&gt 		  (decode-universal-time utime (tz tz-pane))
&gt 		(declare (ignore weekday))
&gt 		(assert (null dstp))
&gt 		(assert (= timezone (tz tz-pane)))
&gt 		(date-interface-set date-interface :day date :month month :year year)
&gt 		(time-interface-set time-interface :hour hour :minute minute :second second)
&gt 		(setq utime (encode-universal-time
&gt 			     second minute hour date month year (tz tz-pane)))
&gt 		(setf (capi:display-pane-text date-display)
&gt 		      (user:date :utime utime :stream nil :tz (tz tz-pane))))
&gt 	      (when callback (if selfstash (funcall callback selfstash)))))
&gt   (time-interface time-interface :title "Time:"
&gt 		   :callback
&gt 		   (lambda (intf)
&gt 		     (with-slots (hour minute second) intf
&gt 		       (multiple-value-bind (sec min hr date mnth year wkdy dstp
&gt 						 timezone)
&gt 			   (decode-universal-time utime (tz tz-pane))
&gt 			 (declare (ignore hr min sec wkdy))
&gt 			 (assert (null dstp))
&gt 			 (assert (= timezone (tz tz-pane)))
&gt 			 (setq utime (encode-universal-time
&gt 				      second minute hour date mnth year (tz tz-pane)))
&gt 			 (setf (capi:display-pane-text date-display)
&gt 			       (user:date :utime utime :stream nil :tz (tz tz-pane)))
&gt 			 (when callback (if selfstash (funcall callback selfstash)))))))
&gt   (date-interface date-interface :title "Date"
&gt 		   :callback
&gt 		   (lambda (intf)
&gt 		     (with-slots (day month year) intf
&gt 		       (multiple-value-bind (sec min hr date mnth yr wkdy dstp timezone)
&gt 			   (decode-universal-time utime (tz tz-pane))
&gt 			 (declare (ignore date mnth yr wkdy))
&gt 			 (assert (null dstp))
&gt 			 (assert (= timezone (tz tz-pane)))
&gt 			 (setq utime (encode-universal-time sec min hr day month year (tz tz-pane)))
&gt 			 (setf (capi:display-pane-text date-display)
&gt 			       (user:date :utime utime :stream nil :tz (tz tz-pane)))
&gt 			 (when callback (if selfstash (funcall callback selfstash))))))))
&gt  (:layouts
&gt   (output-panes capi:column-layout '(date-display tz-pane))
&gt   (date-time-layout capi:column-layout
&gt 		     '(date-interface time-interface output-panes)))
&gt  (:default-initargs
&gt   :create-callback
&gt   (lambda (intf)
&gt     (check-type intf date-time-interface)
&gt     (with-slots (selfstash) intf
&gt       (setq selfstash intf)))
&gt   :layout 'date-time-layout))
&gt 
&gt (defmethod initialize-instance :after ((intf date-time-interface) &amp;key)
&gt  (with-slots (utime) intf
&gt    (date-time-interface-set intf :time utime)))
&gt 
&gt #+nil
&gt (capi:display (setq $x (make-instance 'date-time-interface
&gt 			 :callback (lambda (x) (warn "~S" x)))))
&gt 
&gt 
&gt ;;; ----------------------------------------------------------------------
&gt ;;;
&gt ;;;
&gt ;;;
&gt 
&gt (defun extract-properties (plist indicator-list &amp;aux ret)
&gt  "Internal. Cannot use NIL as indicator."
&gt  (loop (multiple-value-bind (indicator value tail)
&gt 	    (get-properties plist indicator-list)
&gt 	  (if indicator (setq ret (cons indicator (cons value ret))))
&gt 	  (if (endp tail) (return ret))
&gt 	  (setq plist (cddr tail)))))
&gt 
&gt (defun date-time-interface-set (self &amp;rest keys &amp;key time day month year
&gt 				hour minute second (tz nil tz-supplied-p))
&gt  (declare (ignore day month year hour minute second))
&gt  (check-type self date-time-interface)
&gt  (when time (check-type time (integer 0)))
&gt  (when tz (check-type tz (rational -12 12))) ;TODO
&gt  (when time
&gt    (unless tz (setq tz (tz (slot-value self 'tz-pane))))
&gt    (multiple-value-bind (ss mm hh dt mon yr wkdy dstp timezone)
&gt 	(decode-universal-time time tz)
&gt      (declare (ignore wkdy))
&gt      (assert (null dstp))
&gt      (assert (= timezone tz))
&gt      (setf (getf keys :hour) (setq hour hh))
&gt      (setf (getf keys :minute) (setq minute mm))
&gt      (setf (getf keys :second) (setq second ss))
&gt      (setf (getf keys :month) (setq month mon))
&gt      (setf (getf keys :year) (setq year yr))
&gt      (setf (getf keys :day) (setq day dt))))
&gt  (when keys
&gt    (with-slots (date-interface time-interface) self
&gt      (apply #'date-interface-set date-interface
&gt 	     (append '(:redisplay nil)
&gt 		     (extract-properties keys '(:month :day :year))))
&gt      (apply #'time-interface-set time-interface
&gt 	     (extract-properties keys '(:second :minute :hour)))))
&gt  (when tz-supplied-p
&gt    (setf (tz (slot-value self 'tz-pane)) tz)))
&gt 
&gt (defun prompt-for-date-and-time (&amp;optional (title "Select Date:") &amp;rest keys)
&gt  "KEYS accepted: TZ is a common lisp timezone. TIME is a common lisp
&gt universal time which overrides the HOUR MINUTE SECOND DAY MONTH YEAR keys
&gt which can also be specified."
&gt  (let ((x (make-instance 'date-time-interface)))
&gt    (apply #'date-time-interface-set x keys)
&gt    (capi:popup-confirmer
&gt     x title
&gt     :ok-function #'(lambda (intf)
&gt 		      (declare (ignore intf))
&gt 		      (slot-value x 'utime)))))
&gt 
&gt #+nil
&gt (prompt-for-date-and-time "Foo" :time 3336371200 :tz -11/2)
&gt 
&gt ;;; TODO: parse-time:parse-time text-input-pane
&gt 
&gt _______________________________________________
&gt Lisp Hug - the mailing list for LispWorks users
&gt lisp-hug@lispworks.com
&gt http://www.lispworks.com/support/lisp-hug.html
&gt 


_______________________________________________
Lisp Hug - the mailing list for LispWorks users
lisp-hug@lispworks.com
http://www.lispworks.com/support/lisp-hug.html


</pre>
                  </article>
                 </section>
                 <section class=tree>
                  <article class=email>
                   <h1>Re: Calendar Widget?</h1>
                   <pre>

* Camille Troillard &lt;5CB0219F-1EEB-4C93-9B88-44EDAD751093@osculator.net&gt :
Wrote on Mon, 12 Aug 2013 09:56:31 +0200:

| I can't compile this code because of :
|
|   (user:date :utime utime :stream nil :tz (tz tz-pane))
|
| Do you know how to define this date function?


I apologize for not having cleaned up that code before posting. I'm
appending the definiton I used for DATE, --- Regards, Madhu


(defun USER::date (&amp;key (stream *standard-output*) (utime (get-universal-time)) tz
	     uutime)
  (when uutime
    (when utime (warn "ignoring UTIME using UUTIME"))
    (setq utime (+ +unix-epoch+ uutime)))
  (multiple-value-bind (second minute hour date month year day daylight-p zone)
      (if tz
	  (decode-universal-time utime tz)
	  (decode-universal-time utime))
    (when daylight-p (decf zone))	; check
    (format stream "~a ~a ~2,' d ~2,'0d:~2,'0d:~2,'0d ~4d ~?"
	    (ecase day
	      (0 "Mon") (1 "Tue") (2 "Wed") (3 "Thu") (4 "Fri")
	      (5 "Sat") (6 "Sun"))
	    (ecase month
	      (1 "Jan") (2 "Feb") (3 "Mar") (4 "Apr") (5 "May") (6 "Jun")
	      (7 "Jul") (8 "Aug") (9 "Sep") (10 "Oct") (11 "Nov") (12 "Dec"))
	    date hour minute second year
	    "~:[+~;-~]~2,'0d~2,'0d"
	    (multiple-value-bind (hour min) (truncate zone 1)
	      (list (plusp zone) (abs hour) (* 60 (abs min)))))))

_______________________________________________
Lisp Hug - the mailing list for LispWorks users
lisp-hug@lispworks.com
http://www.lispworks.com/support/lisp-hug.html


</pre>
                  </article>
                 </section>
                 <section class=tree>
                  <article class=email>
                   <h1>Re: Calendar Widget?</h1>
                   <pre>

[Trying again to post an appropriate definition of DATE and fix another
bug...]

* Camille Troillard &lt;5CB0219F-1EEB-4C93-9B88-44EDAD751093@osculator.net&gt :
Wrote on Mon, 12 Aug 2013 09:56:31 +0200:

| I can't compile this code because of :
|
|   (user:date :utime utime :stream nil :tz (tz tz-pane))
|
| Do you know how to define this date function?


I apologize for not having cleaned up that code before posting. I'm
appending the definiton I used for DATE.
I also noticed a bug in the posted dialog prompting code, in
DATE-TIME-INTERFACE-SET, where the form

	"(setf (tz (slot-value self 'tz-pane)) tz)"

was evaluated later than expected.  I'm appending a kludged definition
of that function that patches this. ---Regards and regrets, Madhu


(defun user::date (&amp;key (stream *standard-output*)
		   (utime (get-universal-time)) tz)
  (multiple-value-bind (second minute hour date month year day daylight-p zone)
      (if tz
	  (decode-universal-time utime tz)
	  (decode-universal-time utime))
    (when daylight-p (decf zone))	; check
    (format stream "~a ~a ~2,' d ~2,'0d:~2,'0d:~2,'0d ~4d ~?"
	    (ecase day
	      (0 "Mon") (1 "Tue") (2 "Wed") (3 "Thu") (4 "Fri")
	      (5 "Sat") (6 "Sun"))
	    (ecase month
	      (1 "Jan") (2 "Feb") (3 "Mar") (4 "Apr") (5 "May") (6 "Jun")
	      (7 "Jul") (8 "Aug") (9 "Sep") (10 "Oct") (11 "Nov") (12 "Dec"))
	    date hour minute second year
	    "~:[+~;-~]~2,'0d~2,'0d"
	    (multiple-value-bind (hour min) (truncate zone 1)
	      (list (plusp zone) (abs hour) (* 60 (abs min)))))))


(eval-when (load eval compile) (export '(user::date) :user))


(defun date-time-interface-set (self &amp;rest keys &amp;key time day month year
				hour minute second (tz nil tz-supplied-p))
  (declare (ignore day month year hour minute second))
  (check-type self date-time-interface)
  (when time (check-type time (integer 0)))
  (when tz (check-type tz (rational -12 12))) ;TODO
  (when tz-supplied-p                         ; XXX madhu 20130813
    (setf (tz (slot-value self 'tz-pane)) tz))
  (when time
    (unless tz (setq tz (tz (slot-value self 'tz-pane))))
    (multiple-value-bind (ss mm hh dt mon yr wkdy dstp timezone)
	(decode-universal-time time tz)
      (declare (ignore wkdy))
      (assert (null dstp))
      (assert (= timezone tz))
      (setf (getf keys :hour) (setq hour hh))
      (setf (getf keys :minute) (setq minute mm))
      (setf (getf keys :second) (setq second ss))
      (setf (getf keys :month) (setq month mon))
      (setf (getf keys :year) (setq year yr))
      (setf (getf keys :day) (setq day dt))))
  (when keys
    (with-slots (date-interface time-interface) self
      (apply #'date-interface-set date-interface
	     (append '(:redisplay nil)
		     (extract-properties keys '(:month :day :year))))
      (apply #'time-interface-set time-interface
	     (extract-properties keys '(:second :minute :hour))))))

_______________________________________________
Lisp Hug - the mailing list for LispWorks users
lisp-hug@lispworks.com
http://www.lispworks.com/support/lisp-hug.html


</pre>
                  </article>
                 </section>
                </section>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: Calendar Widget?</h1>
                 <pre>
David McClain wrote on Sun, 11 Aug 2013 10:18:03 -0700 21:18:

| It is becoming more frequently the case that having a little Calendar
| widget available to the user in GUI's would be vary convenient to have.
| Has anyone seen one of those for Lisp?

I have written one quite a while ago
http://en.ystok.ru/products/ywidgets/

As I have no time to provide docs for Ystok-Widgets Professional Edition, I
am thinking of releasing it "in small pieces" by inquiry. If you wanted to
dig into large sources, I would be pleased to send them in private E-Mail.
--
Sincerely,
Dmitry Ivanov
lisp.ystok.ru

_______________________________________________
Lisp Hug - the mailing list for LispWorks users
lisp-hug@lispworks.com
http://www.lispworks.com/support/lisp-hug.html


</pre>
                </article>
               </section>
              </section>
             </div>
            </div>
            <footer class="d-flex justify-content-center">
             <div>
              Updated at: 2020-12-10 08:35 UTC
             </div>
            </footer>
           </body>
          </html>