<!DOCTYPE html>
<html lang=en>
           <head>
            <meta charset=UTF-8>
            <title>A few newbie questions</title>
            <link rel=stylesheet
                  href=https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css
                  integrity=sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2
                  crossorigin=anonymous>
            <style>
section.tree {
    padding-left: 2em;
}
section.tree:first-child {
    padding-left: 0;
}
.article-link {
  margin-bottom: 1em;
}
</style>
<!-- Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-9X3G9MMWZP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-9X3G9MMWZP');
</script>

           </head>
           <body>
            <header class="d-flex justify-content-center">
             <nav
                  class="navbar navbar-light bg-light w-100 mx-5 mb-3">
              <a class=navbar-brand href="/">Lisp HUG Maillist Archive</a>
             </nav>
            </header>
            <div class="d-flex justify-content-center">
             <div class="w-100 mx-5 px-3">
              <section class=tree>
               <article class=email>
                <h1>A few newbie questions</h1>
                <p>
                 Unable to parse email body. Email id is 11834
               </article>
               <section class=tree>
                <article class=email>
                 <h1>Re: A few newbie questions</h1>
                 <p>
                  Unable to parse email body. Email id is 11837
                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: A few newbie questions</h1>
                 <pre>
Hi Gerry,

On Wed, Jan 2, 2013 at 6:42 PM, Gerry Weaver &lt;gerryw@compvia.com&gt wrote:

&gt 1. How does LispWorks run time performance compare to the rest of the
&gt available Lisp implementations (64bit Linux)? I know there are some
&gt benchmark comparisons out there, but I'm looking for something more in the
&gt way of real world experiences.

I'm pretty sure you can, for each existing CL implementation X, come
up with a suitable benchmark where X "wins".  In real world usage,
though, all mature CL implementations which compile to machine code
are generally fast enough.  You will sometimes come to a point where
something needs to be faster and then (assuming of course that your
algorithms and data structures are OK) you'll have to resort to the
profiler to find the bottleneck and then optimize one or two critical
functions using things like DECLARE and DISASSEMBLE.  This
optimization process is mostly implementation-specific, but - again -
all good CL compilers will be able to generate (with help from the
programmer) machine code which is as fast or almost as fast as code
coming from a C compiler.

&gt 2. How portable is LispWorks between other Lisp implementations?

As long as you're writing pure CL according to the standard it is 100%
portable - as should be expected.

&gt 3. What are the other reasons someone would choose LispWorks over the rest?

A: CAPI,  B: The MP implementation,  C: Cross-platform (Win, Mac,
Linux, etc.),  D: FLI,  E: Very good documentation,  F: Stellar
support,  G: This mailing list,  H: More stuff that I forgot... :)

&gt Lisp in general

I'd send the rest to a different mailing list.  I've seen (and
answered) questions like these a million times already (or at least it
feels like that).

Cheers,
Edi.

_______________________________________________
Lisp Hug - the mailing list for LispWorks users
lisp-hug@lispworks.com
http://www.lispworks.com/support/lisp-hug.html


</pre>
                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: A few newbie questions</h1>
                 <p>
                  Unable to parse email body. Email id is 11839
                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: A few newbie questions</h1>
                 <pre>
Hello, Gerry.

I'll take a stab at answering some of your questions in a fairly
haphazard way. :-)

My first experience using Lisp came after pondering Greenspun's Tenth
Rule of Programming
(http://en.wikipedia.org/wiki/Greenspun%27s_tenth_rule):

    "Any sufficiently complicated C or Fortran program contains an ad
hoc, informally-specified, bug-ridden, slow implementation of half of
Common Lisp."

At the time I was working on a multi-dimensional calculation engine
that was driven in part by user-defined formulas. The engine was
written in Delphi (a Pascal variant) and used a hand-built
interpreter. After pondering the rule the lightbulb went off; that
interpreter was the kind of thing Greenspun was talking about. I went
on a six-week coding bender and re-implemented the entire calculation
engine in Lisp (using LispWorks).

The end result was that a million lines of Delphi code turned into a
hundred thousand lines of Lisp code. And the Lisp engine ran six times
faster on average. Why? Well, Greenspun's rule. What the Lisp engine
did was to transform user formulas into Lisp, and then compile that
Lisp to native code (at runtime using the LispWorks compiler). The
entire interpreter disappeared. On top of that, Lisp had a very large
toolkit that eliminated a lot of work we had done by hand in Delphi.
For example, Lisp had fantastic arrays, and LispWorks had a very nice
parser toolkit.

Despite the tremendous success of the experiment the Lisp calc engine
never made it into production. I'll explain why in a bit.

My second experience using Lisp was actually with a Lisp-like
language, Scheme. Take a look at http://www.dazzit.com/. Nearly
everything you see--and a whole lot that you can't--is done using
Scheme. We have a pure-functional data processing pipeline that pulls
data from different sources, process it in different ways, feeds the
result into a highly specialized database engine, serves results using
a multi-threaded web server. All of that is Scheme. In that particular
project we had originally intended to use Scheme only in the "highly
specialized database engine", but as our needs grew we kept
discovering that Scheme worked better than a number of other tools we
tried. Here's one example. The web server was originally "pluggable";
we had an IIS front-end, an Apache front-end, a Java front-end. (The
current site, http://www.dazzit.com/, is really a large-scale
proof-of-concept for the underlying technology.) For reasons I won't
fully explain we realized that we'd be better served by a single
Scheme implementation--but here's the kicker. In Scheme we were able
to define a mutation-free subset of the language, and we were able to
use that language (and only that language) when serving pages. That
meant that we could create a multi-threaded web server that was
*guaranteed* to never have threading bugs.

Now let me try to circle back to some of the things you asked.

Getting a good feel for Lisp and Scheme requires immersion. You have
to really make an effort to get a feel for the languages, a feel for
how to use them properly. Otherwise you're just writing C code in a
different style. The one book I'd recommend more than any other is
http://norvig.com/paip.html. The book isn't just about AI programming;
it's about how to take advantage of Lisp to solve complex problems.
But one book won't be enough; you'll have to be willing to put in the
time and effort to find and read as many examples of good style as you
can.

In my opinion Lisp and Scheme work best in small teams of highly
capable people. I think they allow for tremendous leverage, but I
think they take skill, talent and effort to use properly.

In my opinion too the greatest strength of Lisp and Scheme is also its
greatest weakness: they grant you leverage by allowing you to create
specialized languages aimed at tackling specialized problems. Great!
But how well documented is the language you just created? Will anyone
else understand it? Will you grok it six months from now? A year from
now? Maybe. But that really comes back to the "skill and talent"
point. You see, in C (or Python or Ruby) the distinction between "the
language" and "your code" is very clear; conditionals look like this,
loops like that. In Lisp-like languages everything looks the same, and
if someone else has tackled a problem in a way that's very different
from what you're used to it can take substantial effort to find your
way around--to understand how things work, to understand how to use
them. Good documentation can help, but few projects allocate
substantial money to internal documentation.

That's why the vastly superior Lisp calc engine never went into
production. At the time I was responsible for a team of 25 working on
that project, and things like performance and line count were only two
of the factors I had to consider. In that case Lisp couldn't overcome
the hurdles. In a later project it could, and a Lisp-like language was
an excellent choice. It allowed a small team to produce a very
high-performance product using relatively little code.

PS: There's one important issue I haven't touched on: the relative
dearth of shared Lisp and Scheme libraries.

On Wed, Jan 2, 2013 at 12:42 PM, Gerry Weaver &lt;gerryw@compvia.com&gt wrote:
&gt Hello All,
&gt
&gt I am new to Lisp and I have a few newbie type questions. If someone would be
&gt so kind as to help me out with these, it would be very much appreciated.
&gt
&gt I have been programming for a long time. My experience is mainly in C, C++
&gt and C#. I'm on a bit of a quest to find a suitable replacement for C++. I
&gt have looked at quite a few languages over the last several months (C#,
&gt OCaml, Scheme, Smalltalk, etc.). It has come down to a choice between Lisp
&gt and C#. In either case I would need to develop some libraries to support the
&gt kind of work I do, so they are more or less equal in that regard. I have
&gt been playing a lot with Lisp lately and this has led to several questions.
&gt
&gt LispWorks - I have been using IDEs for development for some time now and I
&gt am finding it very difficult to go back to something like emacs. This has
&gt led me to LispWorks as my preferred solution for a Lisp IDE. However,
&gt LispWorks is quite expensive and I really need to justify the expense.
&gt
&gt 1. How does LispWorks run time performance compare to the rest of the
&gt available Lisp implementations (64bit Linux)? I know there are some
&gt benchmark comparisons out there, but I'm looking for something more in the
&gt way of real world experiences.
&gt
&gt 2. How portable is LispWorks between other Lisp implementations?
&gt
&gt 3. What are the other reasons someone would choose LispWorks over the rest?
&gt
&gt Lisp in general
&gt
&gt 1. Lisp has a pretty steep learning curve for someone who has been doing
&gt C/C++ for 25 years. I am having some trouble estimating the boost in
&gt programming productivity that Lisp could provide. It does seem that there is
&gt an increase, I just don't have enough experience with it yet to know. Could
&gt someone that has programmed in other languages for a reasonable period of
&gt time before using Lisp, share their experiences?
&gt
&gt 2. I have spent enough time with Lisp to start to appreciate some of it's
&gt more powerful features. What I'm struggling to understand, is why there
&gt aren't more applications. I have ask this question before, but no one has
&gt provided a very satisfying answer. If Lisp is as powerful and productive as
&gt it seems on the surface, I would think there would be a lot more evidence of
&gt that fact. Please don't misunderstand. I'm not trolling or trying to start a
&gt war. I am just trying to understand how this came to be. One of the things
&gt that led me to remove Smalltalk from my list of candidates, was that I
&gt realized programming in the large would be a bit problematic. It looks like
&gt a large code base would be completely unmanageable. I'm not able to
&gt visualize that shortcoming in Lisp yet. Is there a similar issue? Does it
&gt simply boil down to popularity, complexity, price of entry, etc.?
&gt
&gt 3. One of the language features on my short list when looking for a language
&gt is the ability to use the language itself as a scripting extension. I know
&gt Lisp has the eval function, but I have read/heard a lot of people warn
&gt against using it. Is there a safe way or perhaps a package that is available
&gt to provide a safe (sandbox) environment for running arbitrary Lisp code at
&gt run time?
&gt
&gt 4. I have read several of the most popular books on Lisp and have done a
&gt fair bit of experimentation. I am having a hard time making the mental shift
&gt of solving problems in the functional Lisp way. Can anyone recommend a book
&gt or article that they feel helped the most in this area. I guess I'm still
&gt looking for the description or analogy that will help me start making the
&gt mental transition. I found an article using XML to explain a couple of Lisp
&gt concepts that was very helpful for the intended purpose. I'm trying to find
&gt a similar thing for program design and structure.
&gt
&gt 5. Is there a good book or article available on Lisp , which addresses best
&gt practices and coding style? I have come across several instances where
&gt someone will make a statement regarding code not being "Lispy" or on bad
&gt Lisp programming style. However, I'm finding it difficult to come up with
&gt some basic guidelines.
&gt
&gt  6. I have heard and read a lot of things from the Lisp community regarding
&gt the general benefits of the Lisp language. Likewise, I have come across many
&gt folks that do not use Lisp, enumerating the various reasons for their
&gt decision. I suspect that there is a fair amount of FUD being spread by folks
&gt that were, for what ever reason, not able to make the switch to Lisp. I see
&gt the same thing regarding the C/C++ language all the time. There is a lot of
&gt FUD, but it's not coming from anyone who is actually proficient in either
&gt language. It is just an attempt to justify the inability to learn/use the
&gt language effectively. I'm sure, to some extent, this must be true with Lisp.
&gt What I would like to know is what Lisper's actually think some of the
&gt downsides to using Lisp are.
&gt
&gt 7. I'm trying to figure out what the best workflow is for Lisp development.
&gt I am aware of the init files and the ability to save an image with
&gt environmental state. What is the workflow that y'all use on your projects?
&gt
&gt 8. Assuming that you wanted to use Lisp on as many projects as possible,
&gt what type of projects do you feel that Lisp would be the wrong choice and
&gt why?. This would not include the obvious low level system programming kind
&gt of thing.
&gt
&gt I apologize for such a long post. I have been saving these up for a while.
&gt Any and all help or advice would be greatly appreciated.
&gt
&gt Thanks,
&gt Gerry
&gt
&gt

_______________________________________________
Lisp Hug - the mailing list for LispWorks users
lisp-hug@lispworks.com
http://www.lispworks.com/support/lisp-hug.html


</pre>
                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: A few newbie questions</h1>
                 <pre>
Gerry Weaver &lt;gerryw &lt;at&gt compvia.com&gt writes:

&gt 2. I have spent enough time with Lisp to start to appreciate some of it's more 
powerful features. What I'm struggling to understand, is why there aren't more 
applications.

Lisp (CL and Scheme) has a long history of use in music technology, sound 
synthesis and computer-assisted composition. Here are two programs that I use 
virtually every day:

http://repmus.ircam.fr/openmusic/home
http://www2.siba.fi/pwgl/index.html

Both the above are built using LispWorks.

Chris



_______________________________________________
Lisp Hug - the mailing list for LispWorks users
lisp-hug@lispworks.com
http://www.lispworks.com/support/lisp-hug.html


</pre>
                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: A few newbie questions</h1>
                 <p>
                  Unable to parse email body. Email id is 11851
                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: A few newbie questions</h1>
                 <pre>
True, we need more developers using LispWorks, and then I think they would have the resources to beef it up. 

On Jan 2, 2013, at 2:58 PM, Rangarajan Krishnamoorthy wrote:

&gt 
&gt Hi,
&gt Nice discussion. Coming from C++/Java/C# background I am a bit surprised
&gt that in spite of so many great minds working in Lisp, there are 2 glaring
&gt "deficiencies" (sorry, I don't mean to offend!)
&gt 1) No great IDE like, for example, http://www.jetbrains.com/idea/
&gt 2) Limited UI libraries compared to what you can find in Java/C#
&gt 
&gt Even for object persistence, I find very  limited choice. Hope these improve
&gt in due course.
&gt 
&gt Regards,
&gt Rangarajan
&gt 
&gt -----Original Message-----
&gt From: owner-lisp-hug@lispworks.com [mailto:owner-lisp-hug@lispworks.com] On
&gt Behalf Of Michael Lenaghan
&gt Sent: Thursday, January 3, 2013 12:29 AM
&gt To: Gerry Weaver
&gt Cc: Lisp Hug Lispworks [lisp-hug@lispworks.com]
&gt Subject: Re: A few newbie questions
&gt 
&gt 
&gt Hello, Gerry.
&gt 
&gt I'll take a stab at answering some of your questions in a fairly haphazard
&gt way. :-)
&gt 
&gt My first experience using Lisp came after pondering Greenspun's Tenth Rule
&gt of Programming
&gt (http://en.wikipedia.org/wiki/Greenspun%27s_tenth_rule):
&gt 
&gt    "Any sufficiently complicated C or Fortran program contains an ad hoc,
&gt informally-specified, bug-ridden, slow implementation of half of Common
&gt Lisp."
&gt 
&gt At the time I was working on a multi-dimensional calculation engine that was
&gt driven in part by user-defined formulas. The engine was written in Delphi (a
&gt Pascal variant) and used a hand-built interpreter. After pondering the rule
&gt the lightbulb went off; that interpreter was the kind of thing Greenspun was
&gt talking about. I went on a six-week coding bender and re-implemented the
&gt entire calculation engine in Lisp (using LispWorks).
&gt 
&gt The end result was that a million lines of Delphi code turned into a hundred
&gt thousand lines of Lisp code. And the Lisp engine ran six times faster on
&gt average. Why? Well, Greenspun's rule. What the Lisp engine did was to
&gt transform user formulas into Lisp, and then compile that Lisp to native code
&gt (at runtime using the LispWorks compiler). The entire interpreter
&gt disappeared. On top of that, Lisp had a very large toolkit that eliminated a
&gt lot of work we had done by hand in Delphi.
&gt For example, Lisp had fantastic arrays, and LispWorks had a very nice parser
&gt toolkit.
&gt 
&gt Despite the tremendous success of the experiment the Lisp calc engine never
&gt made it into production. I'll explain why in a bit.
&gt 
&gt My second experience using Lisp was actually with a Lisp-like language,
&gt Scheme. Take a look at http://www.dazzit.com/. Nearly everything you
&gt see--and a whole lot that you can't--is done using Scheme. We have a
&gt pure-functional data processing pipeline that pulls data from different
&gt sources, process it in different ways, feeds the result into a highly
&gt specialized database engine, serves results using a multi-threaded web
&gt server. All of that is Scheme. In that particular project we had originally
&gt intended to use Scheme only in the "highly specialized database engine", but
&gt as our needs grew we kept discovering that Scheme worked better than a
&gt number of other tools we tried. Here's one example. The web server was
&gt originally "pluggable"; we had an IIS front-end, an Apache front-end, a Java
&gt front-end. (The current site, http://www.dazzit.com/, is really a
&gt large-scale proof-of-concept for the underlying technology.) For reasons I
&gt won't fully explain we realized that we'd be better served by a single
&gt Scheme implementation--but here's the kicker. In Scheme we were able to
&gt define a mutation-free subset of the language, and we were able to use that
&gt language (and only that language) when serving pages. That meant that we
&gt could create a multi-threaded web server that was
&gt *guaranteed* to never have threading bugs.
&gt 
&gt Now let me try to circle back to some of the things you asked.
&gt 
&gt Getting a good feel for Lisp and Scheme requires immersion. You have to
&gt really make an effort to get a feel for the languages, a feel for how to use
&gt them properly. Otherwise you're just writing C code in a different style.
&gt The one book I'd recommend more than any other is
&gt http://norvig.com/paip.html. The book isn't just about AI programming; it's
&gt about how to take advantage of Lisp to solve complex problems.
&gt But one book won't be enough; you'll have to be willing to put in the time
&gt and effort to find and read as many examples of good style as you can.
&gt 
&gt In my opinion Lisp and Scheme work best in small teams of highly capable
&gt people. I think they allow for tremendous leverage, but I think they take
&gt skill, talent and effort to use properly.
&gt 
&gt In my opinion too the greatest strength of Lisp and Scheme is also its
&gt greatest weakness: they grant you leverage by allowing you to create
&gt specialized languages aimed at tackling specialized problems. Great!
&gt But how well documented is the language you just created? Will anyone else
&gt understand it? Will you grok it six months from now? A year from now? Maybe.
&gt But that really comes back to the "skill and talent"
&gt point. You see, in C (or Python or Ruby) the distinction between "the
&gt language" and "your code" is very clear; conditionals look like this, loops
&gt like that. In Lisp-like languages everything looks the same, and if someone
&gt else has tackled a problem in a way that's very different from what you're
&gt used to it can take substantial effort to find your way around--to
&gt understand how things work, to understand how to use them. Good
&gt documentation can help, but few projects allocate substantial money to
&gt internal documentation.
&gt 
&gt That's why the vastly superior Lisp calc engine never went into production.
&gt At the time I was responsible for a team of 25 working on that project, and
&gt things like performance and line count were only two of the factors I had to
&gt consider. In that case Lisp couldn't overcome the hurdles. In a later
&gt project it could, and a Lisp-like language was an excellent choice. It
&gt allowed a small team to produce a very high-performance product using
&gt relatively little code.
&gt 
&gt PS: There's one important issue I haven't touched on: the relative dearth of
&gt shared Lisp and Scheme libraries.
&gt 
&gt On Wed, Jan 2, 2013 at 12:42 PM, Gerry Weaver &lt;gerryw@compvia.com&gt wrote:
&gt&gt Hello All,
&gt&gt 
&gt&gt I am new to Lisp and I have a few newbie type questions. If someone 
&gt&gt would be so kind as to help me out with these, it would be very much
&gt appreciated.
&gt&gt 
&gt&gt I have been programming for a long time. My experience is mainly in C, 
&gt&gt C++ and C#. I'm on a bit of a quest to find a suitable replacement for 
&gt&gt C++. I have looked at quite a few languages over the last several 
&gt&gt months (C#, OCaml, Scheme, Smalltalk, etc.). It has come down to a 
&gt&gt choice between Lisp and C#. In either case I would need to develop 
&gt&gt some libraries to support the kind of work I do, so they are more or 
&gt&gt less equal in that regard. I have been playing a lot with Lisp lately and
&gt this has led to several questions.
&gt&gt 
&gt&gt LispWorks - I have been using IDEs for development for some time now 
&gt&gt and I am finding it very difficult to go back to something like emacs. 
&gt&gt This has led me to LispWorks as my preferred solution for a Lisp IDE. 
&gt&gt However, LispWorks is quite expensive and I really need to justify the
&gt expense.
&gt&gt 
&gt&gt 1. How does LispWorks run time performance compare to the rest of the 
&gt&gt available Lisp implementations (64bit Linux)? I know there are some 
&gt&gt benchmark comparisons out there, but I'm looking for something more in 
&gt&gt the way of real world experiences.
&gt&gt 
&gt&gt 2. How portable is LispWorks between other Lisp implementations?
&gt&gt 
&gt&gt 3. What are the other reasons someone would choose LispWorks over the
&gt rest?
&gt&gt 
&gt&gt Lisp in general
&gt&gt 
&gt&gt 1. Lisp has a pretty steep learning curve for someone who has been 
&gt&gt doing C/C++ for 25 years. I am having some trouble estimating the 
&gt&gt boost in programming productivity that Lisp could provide. It does 
&gt&gt seem that there is an increase, I just don't have enough experience 
&gt&gt with it yet to know. Could someone that has programmed in other 
&gt&gt languages for a reasonable period of time before using Lisp, share their
&gt experiences?
&gt&gt 
&gt&gt 2. I have spent enough time with Lisp to start to appreciate some of 
&gt&gt it's more powerful features. What I'm struggling to understand, is why 
&gt&gt there aren't more applications. I have ask this question before, but 
&gt&gt no one has provided a very satisfying answer. If Lisp is as powerful 
&gt&gt and productive as it seems on the surface, I would think there would 
&gt&gt be a lot more evidence of that fact. Please don't misunderstand. I'm 
&gt&gt not trolling or trying to start a war. I am just trying to understand 
&gt&gt how this came to be. One of the things that led me to remove Smalltalk 
&gt&gt from my list of candidates, was that I realized programming in the 
&gt&gt large would be a bit problematic. It looks like a large code base 
&gt&gt would be completely unmanageable. I'm not able to visualize that 
&gt&gt shortcoming in Lisp yet. Is there a similar issue? Does it simply boil
&gt down to popularity, complexity, price of entry, etc.?
&gt&gt 
&gt&gt 3. One of the language features on my short list when looking for a 
&gt&gt language is the ability to use the language itself as a scripting 
&gt&gt extension. I know Lisp has the eval function, but I have read/heard a 
&gt&gt lot of people warn against using it. Is there a safe way or perhaps a 
&gt&gt package that is available to provide a safe (sandbox) environment for 
&gt&gt running arbitrary Lisp code at run time?
&gt&gt 
&gt&gt 4. I have read several of the most popular books on Lisp and have done 
&gt&gt a fair bit of experimentation. I am having a hard time making the 
&gt&gt mental shift of solving problems in the functional Lisp way. Can 
&gt&gt anyone recommend a book or article that they feel helped the most in 
&gt&gt this area. I guess I'm still looking for the description or analogy 
&gt&gt that will help me start making the mental transition. I found an 
&gt&gt article using XML to explain a couple of Lisp concepts that was very 
&gt&gt helpful for the intended purpose. I'm trying to find a similar thing for
&gt program design and structure.
&gt&gt 
&gt&gt 5. Is there a good book or article available on Lisp , which addresses 
&gt&gt best practices and coding style? I have come across several instances 
&gt&gt where someone will make a statement regarding code not being "Lispy" 
&gt&gt or on bad Lisp programming style. However, I'm finding it difficult to 
&gt&gt come up with some basic guidelines.
&gt&gt 
&gt&gt 6. I have heard and read a lot of things from the Lisp community 
&gt&gt regarding the general benefits of the Lisp language. Likewise, I have 
&gt&gt come across many folks that do not use Lisp, enumerating the various 
&gt&gt reasons for their decision. I suspect that there is a fair amount of 
&gt&gt FUD being spread by folks that were, for what ever reason, not able to 
&gt&gt make the switch to Lisp. I see the same thing regarding the C/C++ 
&gt&gt language all the time. There is a lot of FUD, but it's not coming from 
&gt&gt anyone who is actually proficient in either language. It is just an 
&gt&gt attempt to justify the inability to learn/use the language effectively.
&gt I'm sure, to some extent, this must be true with Lisp.
&gt&gt What I would like to know is what Lisper's actually think some of the 
&gt&gt downsides to using Lisp are.
&gt&gt 
&gt&gt 7. I'm trying to figure out what the best workflow is for Lisp
&gt development.
&gt&gt I am aware of the init files and the ability to save an image with 
&gt&gt environmental state. What is the workflow that y'all use on your projects?
&gt&gt 
&gt&gt 8. Assuming that you wanted to use Lisp on as many projects as 
&gt&gt possible, what type of projects do you feel that Lisp would be the 
&gt&gt wrong choice and why?. This would not include the obvious low level 
&gt&gt system programming kind of thing.
&gt&gt 
&gt&gt I apologize for such a long post. I have been saving these up for a while.
&gt&gt Any and all help or advice would be greatly appreciated.
&gt&gt 
&gt&gt Thanks,
&gt&gt Gerry
&gt&gt 
&gt&gt 
&gt 
&gt _______________________________________________
&gt Lisp Hug - the mailing list for LispWorks users lisp-hug@lispworks.com
&gt http://www.lispworks.com/support/lisp-hug.html
&gt 
&gt 
&gt 
&gt _______________________________________________
&gt Lisp Hug - the mailing list for LispWorks users
&gt lisp-hug@lispworks.com
&gt http://www.lispworks.com/support/lisp-hug.html
&gt 

_______________________________________________
Lisp Hug - the mailing list for LispWorks users
lisp-hug@lispworks.com
http://www.lispworks.com/support/lisp-hug.html


</pre>
                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: A few newbie questions</h1>
                 <pre>
On Wed, Jan 2, 2013 at 11:58 PM, Rangarajan Krishnamoorthy
&lt;ranga@mmsindia.com&gt wrote:

&gt 1) No great IDE like, for example, http://www.jetbrains.com/idea/

Different strokes for different folks.  I for one like the LispWorks
IDE a lot better than almost everything else I've seen.

Of course, with a language like Java where 70% of your code is boiler
plate stuff, you need a different kind of development environment.
(SCNR...)

&gt 2) Limited UI libraries compared to what you can find in Java/C#

Have you tried CAPI?  What's missing?  How many UI libraries do you
need to write one program?

_______________________________________________
Lisp Hug - the mailing list for LispWorks users
lisp-hug@lispworks.com
http://www.lispworks.com/support/lisp-hug.html


</pre>
                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: A few newbie questions</h1><div dir="ltr"><br><div class="gmail_extra"><div class="gmail_quote">On Thu, Jan 3, 2013 at 12:15 AM, Edi Weitz <span dir="ltr">&lt;<a href="mailto:edi@agharta.de" target="_blank">edi@agharta.de</a>&gt;</span> wrote:<br><blockquote class="gmail_quote" style="margin:0 0 0 .8ex;border-left:1px #ccc solid;padding-left:1ex">
<div class="im"><br>
On Wed, Jan 2, 2013 at 11:58 PM, Rangarajan Krishnamoorthy<br>
&lt;<a href="mailto:ranga@mmsindia.com">ranga@mmsindia.com</a>&gt; wrote:<br>
<br>
&gt; 1) No great IDE like, for example, <a href="http://www.jetbrains.com/idea/" target="_blank">http://www.jetbrains.com/idea/</a><br>
<br>
</div>Different strokes for different folks. Â I for one like the LispWorks<br>
IDE a lot better than almost everything else I&#39;ve seen.<br></blockquote><div><br></div><div style>No flame-wars intended with this response, just adding my $0.02:</div><div style><br></div><div style>Anybody looked at using Emacs and a recent (quicklisp version) of SLIME? It transforms your regular Emacs editor into a true development environment that abstracts from the CL implementation running below it: equal productivity in all your implementations, including your favorite (LispWorks).</div>
<div style><br></div><div style>Unfortunately, SLIME is a bit underdocumented at the moment, making it hard to grasp for entry-level lispers, but I&#39;m sure co-lispers on the #lisp channel on irc://<a href="http://chat.freenode.net">chat.freenode.net</a> can help out if anybody has questions.</div>
<div style><br></div><div style><br></div><div style>Bye,</div><div style><br></div><div style><br></div><div style>Erik.</div></div></div></div>


                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: A few newbie questions</h1>
                 <pre>
Gerry Weaver &lt;gerryw@compvia.com&gt writes:

&gt I'm sorry. I had intended to mention the kind of projects that I work
&gt on. I mainly do consulting for banks and various financial
&gt applications. 

I work for a Norwegian stock broker, Netfonds (http://www.netfonds.no).
We have a fair bit of financial applications, as you might imagine.
Most of them in Common Lisp (Lispworks).

We are not in the HFT market, so our order systems have not been
designed for an environment where the number of feet of cabling between
us and the matching engine is significant, but for our use, Lispworks
has proven fast enough for both market data handling and order
management.  Orders are handled in Lisp from the moment they are
received from the client applications (counting our php frontend as a
client app here) until they enter the wire en route to the appropriate
exchange.  In the other direction, we have Lisp systems reading from the
various firehoses that are market data feeds, converting to a common
format and either pushing to client applications or hanging on to the
data until polled by the web pages.

We have risk management systems crunching large numbers in realtime,
customer relations systems, backoffice and settlement systems, etc, all
written in lisp.  Most of our systems need to talk to a database at some
point, and that is of course no problem.

As you describe, the bulk of our systems are server side and communicate
through custom protocols.  We are not in the business of selling
shrink-wrapped software, we write software for internal use.  Thus, you
will generally not find our applications out in the world.  I suspect
this is the case for quite a lot of Lisp software.

We do have one client application, PrimeTrader, which is given away
freely, and written in Common Lisp.  Leveraging CAPI as the GUI library,
the same codebase is delivered as Windows, Mac and Linux executables
with an absolute minimum of platform-specific tweaks.  (We also have an
iPhone app called PrimeTrader touch.  That is a separate codebase, in
Objective-C, for no other reason than Objective-C being the default for
IOS development.)

The decision of going with Lispworks over other lisp implementations was
taken before my time, so I don't really know the rationale for it, but
we've had no need to move away from it.

-- 
Mvh/Regards
Peder O. Klingenberg
Netfonds Bank AS

_______________________________________________
Lisp Hug - the mailing list for LispWorks users
lisp-hug@lispworks.com
http://www.lispworks.com/support/lisp-hug.html


</pre>
                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: A few newbie questions</h1>
                 <pre>
Hi Gerry,

my fat 2c, while repeating some information mentioned already (I tend
to write and revise the copy several times):

For performance, when things get slow (from the users point of view),
and after profiling you can
- use CL declarations (with the help of :explain declaration to
understand what LW compiler is thinking about your code, and help it
produce a faster code when possible)
- or build on your experience in C/C++, and build a library talking
with your LW through FLI.

&gt 2. How portable is LispWorks between other Lisp implementations?
LW is a CL implementation whose implementation of CL standard should
be portable with other Common-Lisp implementations. The extras (GUI,
MP, FLI, etc ...) are specific to LW which is expected since these are
distinguishing features in CL implementations.

&gt 3. What are the other reasons someone would choose LispWorks over the rest?
- The Graphical debugger and Break points  - a must for me.
- The availability of both, an interpreter and a native compiler (IMO,
absence of an interpreter is a disservice to the CL developer).
- Graphical profiler.
- Graphical Class browser.
- Graphical Inspector for going deep into objects.
- Removing Functions, Generic functions and methods is so much easy
with the provided browsers.
- Cross platform GUI, (meaning almost less things to care/think/budget
about while developing an application across multiple platforms.).
- Price compared with the other CL implementation those packaged with IDE.
- in addition to the CLHS, the LW excellent documentation.


&gt 1. ..... .... , share their experiences?
For me, the boost came from the ability to:
- quickly go from an idea (i.e in simple form a certain function
definition  to trying that idea, without the need to create
boilerplate code to run the function. code in a living system.
- easily inspect objects when an error occur, the bugs here are kind
of living creature that you can instrument, deal with it while the
problem is hot not after a while.
- use Macros. I think of them like code generation wizards, but with
ability to redefine the wizard itself at your own well. in general the
redefinition should propagate to the sites using the original macro,
without touching them.


2. I have spent enough time with Lisp to start ...
Here is different sources to get a hint on the applications developed
with CL (and Lisp in general) - note that some companies hide their
use of CL for competition reasons:

- Meetings and conferences: they will have demos of applications
developed with Lisp/CL:
CL specific
http://weitz.de/eclm2005/
http://weitz.de/eclm2006/
http://www.weitz.de/eclm2008/
http://www.weitz.de/eclm2009/
http://weitz.de/eclm2011/

Lisp in general
http://www.international-lisp-conference.org/2007/speakers
http://www.international-lisp-conference.org/2005/speakers.html
http://www.international-lisp-conference.org/2009/speakers
http://www.international-lisp-conference.org/2010/index

- this is an old summary page linking lisp companies (note that some
were closed, others were bought)
http://pchristensen.com/blog/lisp-companies/

- (Lisp, not CL specific) the answers here mention some applications:
http://programmers.stackexchange.com/questions/55284/is-lisp-still-useful-in-todays-world-which-version-is-most-used


&gt 3. .... Is there a safe way or perhaps a package that is available to provide a safe (sandbox) environment for running arbitrary Lisp code at run time?
as I understand 'eval' does allow for kind of scripting, but does not
provide sandbox environment. and I do not know any other means for
doing such thing in CL.


4. I have read several .......
- Could you specify which books you had read, so I can see if there is
something that went under the radar and can qualify as a suggestion.

5. Is there a good book or article available on Lisp , which addresses
best practices and coding style? I have come across several instances
where someone will make a statement regarding code not being "Lispy"
or on bad Lisp programming style. However, I'm finding it difficult to
come up with some basic guidelines.
- This is the one which I read several times and keep referring to frequently
http://norvig.com/luv-slides.ps


7. I'm trying to figure out what the best workflow is for Lisp
development. I am aware of the init files and the ability to save an
image with environmental state. What is the workflow that y'all use on
your projects?
- live in the REPL.
- once you define a function, play with it, see if it respond to you
as you expected.
- use the Graphical inspector to tinker with the results/objects.
- when you are faced with debugger launch the Graphical one and play
with the frames.
- do some side projects in CL and ask for guidelines and comments on
what in your CL code smells like C/C++.

HIH

Ala'a

On Wed, Jan 2, 2013 at 9:42 PM, Gerry Weaver &lt;gerryw@compvia.com&gt wrote:
&gt Hello All,
&gt
&gt I am new to Lisp and I have a few newbie type questions. If someone would be
&gt so kind as to help me out with these, it would be very much appreciated.
&gt
&gt I have been programming for a long time. My experience is mainly in C, C++
&gt and C#. I'm on a bit of a quest to find a suitable replacement for C++. I
&gt have looked at quite a few languages over the last several months (C#,
&gt OCaml, Scheme, Smalltalk, etc.). It has come down to a choice between Lisp
&gt and C#. In either case I would need to develop some libraries to support the
&gt kind of work I do, so they are more or less equal in that regard. I have
&gt been playing a lot with Lisp lately and this has led to several questions.
&gt
&gt LispWorks - I have been using IDEs for development for some time now and I
&gt am finding it very difficult to go back to something like emacs. This has
&gt led me to LispWorks as my preferred solution for a Lisp IDE. However,
&gt LispWorks is quite expensive and I really need to justify the expense.
&gt
&gt 1. How does LispWorks run time performance compare to the rest of the
&gt available Lisp implementations (64bit Linux)? I know there are some
&gt benchmark comparisons out there, but I'm looking for something more in the
&gt way of real world experiences.
&gt
&gt 2. How portable is LispWorks between other Lisp implementations?
&gt
&gt 3. What are the other reasons someone would choose LispWorks over the rest?
&gt
&gt Lisp in general
&gt
&gt 1. Lisp has a pretty steep learning curve for someone who has been doing
&gt C/C++ for 25 years. I am having some trouble estimating the boost in
&gt programming productivity that Lisp could provide. It does seem that there is
&gt an increase, I just don't have enough experience with it yet to know. Could
&gt someone that has programmed in other languages for a reasonable period of
&gt time before using Lisp, share their experiences?
&gt
&gt 2. I have spent enough time with Lisp to start to appreciate some of it's
&gt more powerful features. What I'm struggling to understand, is why there
&gt aren't more applications. I have ask this question before, but no one has
&gt provided a very satisfying answer. If Lisp is as powerful and productive as
&gt it seems on the surface, I would think there would be a lot more evidence of
&gt that fact. Please don't misunderstand. I'm not trolling or trying to start a
&gt war. I am just trying to understand how this came to be. One of the things
&gt that led me to remove Smalltalk from my list of candidates, was that I
&gt realized programming in the large would be a bit problematic. It looks like
&gt a large code base would be completely unmanageable. I'm not able to
&gt visualize that shortcoming in Lisp yet. Is there a similar issue? Does it
&gt simply boil down to popularity, complexity, price of entry, etc.?
&gt
&gt 3. One of the language features on my short list when looking for a language
&gt is the ability to use the language itself as a scripting extension. I know
&gt Lisp has the eval function, but I have read/heard a lot of people warn
&gt against using it. Is there a safe way or perhaps a package that is available
&gt to provide a safe (sandbox) environment for running arbitrary Lisp code at
&gt run time?
&gt
&gt 4. I have read several of the most popular books on Lisp and have done a
&gt fair bit of experimentation. I am having a hard time making the mental shift
&gt of solving problems in the functional Lisp way. Can anyone recommend a book
&gt or article that they feel helped the most in this area. I guess I'm still
&gt looking for the description or analogy that will help me start making the
&gt mental transition. I found an article using XML to explain a couple of Lisp
&gt concepts that was very helpful for the intended purpose. I'm trying to find
&gt a similar thing for program design and structure.
&gt
&gt 5. Is there a good book or article available on Lisp , which addresses best
&gt practices and coding style? I have come across several instances where
&gt someone will make a statement regarding code not being "Lispy" or on bad
&gt Lisp programming style. However, I'm finding it difficult to come up with
&gt some basic guidelines.
&gt
&gt  6. I have heard and read a lot of things from the Lisp community regarding
&gt the general benefits of the Lisp language. Likewise, I have come across many
&gt folks that do not use Lisp, enumerating the various reasons for their
&gt decision. I suspect that there is a fair amount of FUD being spread by folks
&gt that were, for what ever reason, not able to make the switch to Lisp. I see
&gt the same thing regarding the C/C++ language all the time. There is a lot of
&gt FUD, but it's not coming from anyone who is actually proficient in either
&gt language. It is just an attempt to justify the inability to learn/use the
&gt language effectively. I'm sure, to some extent, this must be true with Lisp.
&gt What I would like to know is what Lisper's actually think some of the
&gt downsides to using Lisp are.
&gt
&gt 7. I'm trying to figure out what the best workflow is for Lisp development.
&gt I am aware of the init files and the ability to save an image with
&gt environmental state. What is the workflow that y'all use on your projects?
&gt
&gt 8. Assuming that you wanted to use Lisp on as many projects as possible,
&gt what type of projects do you feel that Lisp would be the wrong choice and
&gt why?. This would not include the obvious low level system programming kind
&gt of thing.
&gt
&gt I apologize for such a long post. I have been saving these up for a while.
&gt Any and all help or advice would be greatly appreciated.
&gt
&gt Thanks,
&gt Gerry
&gt
&gt

_______________________________________________
Lisp Hug - the mailing list for LispWorks users
lisp-hug@lispworks.com
http://www.lispworks.com/support/lisp-hug.html


</pre>
                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: A few newbie questions</h1>
                 <pre>
On Thu, Jan 3, 2013 at 4:36 PM, Ala'a Mohammad &lt;amalawi@gmail.com&gt wrote:

&gt - Meetings and conferences: they will have demos of applications
&gt developed with Lisp/CL:

While you're at it:

  http://www.lispworks.com/success-stories/index.html

Cheers,
Edi.

_______________________________________________
Lisp Hug - the mailing list for LispWorks users
lisp-hug@lispworks.com
http://www.lispworks.com/support/lisp-hug.html


</pre>
                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>RE: A few newbie questions</h1>
                 <pre>
Lispworks competitor Franz also has an extensive list of applications as well:

http://franz.com/sucess 

-----Original Message-----
From: owner-lisp-hug@lispworks.com [mailto:owner-lisp-hug@lispworks.com] On Behalf Of Edi Weitz
Sent: Thursday, January 03, 2013 11:15 AM
To: Ala'a Mohammad
Cc: Gerry Weaver; Lisp Hug Lispworks [lisp-hug@lispworks.com]
Subject: Re: A few newbie questions


On Thu, Jan 3, 2013 at 4:36 PM, Ala'a Mohammad &lt;amalawi@gmail.com&gt wrote:

&gt - Meetings and conferences: they will have demos of applications
&gt developed with Lisp/CL:

While you're at it:

  http://www.lispworks.com/success-stories/index.html

Cheers,
Edi.

_______________________________________________
Lisp Hug - the mailing list for LispWorks users
lisp-hug@lispworks.com
http://www.lispworks.com/support/lisp-hug.html


_______________________________________________
Lisp Hug - the mailing list for LispWorks users
lisp-hug@lispworks.com
http://www.lispworks.com/support/lisp-hug.html


</pre>
                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: A few newbie questions</h1>
                 <pre>
It seems my subconsciousness is working retrieving old links :)

ScoreCleaner

http://scorecleaner.com/

http://www.reddit.com/r/lisp/comments/njvla/scorecleaner_a_new_desktop_application_for_mac_os/

On Thu, Jan 3, 2013 at 8:14 PM, Edi Weitz &lt;edi@agharta.de&gt wrote:
&gt On Thu, Jan 3, 2013 at 4:36 PM, Ala'a Mohammad &lt;amalawi@gmail.com&gt wrote:
&gt
&gt&gt - Meetings and conferences: they will have demos of applications
&gt&gt developed with Lisp/CL:
&gt
&gt While you're at it:
&gt
&gt   http://www.lispworks.com/success-stories/index.html
&gt
&gt Cheers,
&gt Edi.

_______________________________________________
Lisp Hug - the mailing list for LispWorks users
lisp-hug@lispworks.com
http://www.lispworks.com/support/lisp-hug.html


</pre>
                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: A few newbie questions</h1>
                 <pre>
and

EyeCarePro.Net - Home
http://www.eyecarepro.net/

MediaLab :: SiteGrinder 3
http://www.medialab.com/

On Thu, Jan 3, 2013 at 9:52 PM, Ala'a Mohammad &lt;amalawi@gmail.com&gt wrote:
&gt It seems my subconsciousness is working retrieving old links :)
&gt
&gt ScoreCleaner
&gt
&gt http://scorecleaner.com/
&gt
&gt http://www.reddit.com/r/lisp/comments/njvla/scorecleaner_a_new_desktop_application_for_mac_os/
&gt
&gt On Thu, Jan 3, 2013 at 8:14 PM, Edi Weitz &lt;edi@agharta.de&gt wrote:
&gt&gt On Thu, Jan 3, 2013 at 4:36 PM, Ala'a Mohammad &lt;amalawi@gmail.com&gt wrote:
&gt&gt
&gt&gt&gt - Meetings and conferences: they will have demos of applications
&gt&gt&gt developed with Lisp/CL:
&gt&gt
&gt&gt While you're at it:
&gt&gt
&gt&gt   http://www.lispworks.com/success-stories/index.html
&gt&gt
&gt&gt Cheers,
&gt&gt Edi.

_______________________________________________
Lisp Hug - the mailing list for LispWorks users
lisp-hug@lispworks.com
http://www.lispworks.com/support/lisp-hug.html


</pre>
                </article>
               </section>
              </section>
             </div>
            </div>
            <footer class="d-flex justify-content-center">
             <div>
              Updated at: 2020-12-07 08:32 UTC
             </div>
            </footer>
           </body>
          </html>