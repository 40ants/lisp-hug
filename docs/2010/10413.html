<!DOCTYPE html>
<html lang=en>
           <head>
            <meta charset=UTF-8>
            <title>Time to sleep under different platforms</title>
            <meta name=viewport
                  content="width=device-width, initial-scale=1.0">
            <link rel=stylesheet
                  href=https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css
                  integrity=sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2
                  crossorigin=anonymous>
            <style>
section.tree {
    padding-left: 2em;
}
section.tree:first-child {
    padding-left: 0;
}
.article-link {
  margin-bottom: 1em;
}
</style>
<!-- Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-9X3G9MMWZP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-9X3G9MMWZP');
</script>

           </head>
           <body>
            <header class="d-flex justify-content-center">
             <nav
                  class="navbar navbar-light bg-light w-100 mx-5 mb-3">
              <a class=navbar-brand href="/">Lisp HUG Maillist Archive</a>
             </nav>
            </header>
            <div class="d-flex justify-content-center">
             <div class="w-100 mx-5 px-3">
              <section class=tree>
               <article class=email>
                <h1>Time to sleep under different platforms</h1><html><head></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; ">I tested the accuracy of the sleep function under different conditions (see the table below).&nbsp;<br><br>The table was generated using a very simple function, taking the elapsed time for comparing performance.<br>I could have done some sampling but these one run results are quite consistent over many repetitions.&nbsp;<br><br>The function I used is the following, called form the listener on a freshly launched LW:&nbsp;<br><br><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">(dolist (sec '(1 0.5 0.1 0.05 0.01 0.005 0.001)) (time (sleep sec)))</span></font><br><br>It is a known fact that Windows XP cannot give accurate time measurement under about 15 msec. This problem is apparently solved in Vista.<br><br>Notice that I also ran a test with a Vista virtual image on a MacPro with excellent accuracy (within 1msec).&nbsp;<br><br>Does anyone know of a Lisp solution to give Windows XP a better time resolution?<div><br>Thanks for your replies.&nbsp;<br><br>Bruno<div><br></div><div><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; "><span class="Apple-style-span" style="white-space: pre; "><span class="Apple-style-span" style="font-family: Helvetica; white-space: normal; font-size: medium; "><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">Machine<span class="Apple-style-span" style="white-space: pre; ">&nbsp;                     </span></span></font></span><span class="Apple-style-span" style="font-family: Helvetica; white-space: normal; font-size: medium; "><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">OS<span class="Apple-style-span" style="white-space: pre; ">&nbsp;            </span></span></font></span><span class="Apple-style-span" style="font-family: Helvetica; white-space: normal; font-size: medium; "><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">LW</span></font></span>                           </span>(Sleep x)</span></font><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; "><br><span class="Apple-style-span" style="white-space: pre; ">       &nbsp;                     </span>&nbsp;&nbsp;</span></font><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; "><span class="Apple-style-span" style="white-space: pre; ">&nbsp;            </span>&nbsp;&nbsp;</span></font><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; "><span class="Apple-style-span" style="white-space: pre; ">&nbsp;       </span></span></font><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">1.000<span class="Apple-style-span" style="white-space: pre; ">&nbsp;  </span></span></font><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">0.500<span class="Apple-style-span" style="white-space: pre; ">&nbsp;  </span></span></font><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">0.100<span class="Apple-style-span" style="white-space: pre; ">&nbsp;  </span></span></font><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">0.050<span class="Apple-style-span" style="white-space: pre; ">&nbsp;  </span></span></font><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">0.010<span class="Apple-style-span" style="white-space: pre; ">&nbsp;  </span></span></font><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">0.005<span class="Apple-style-span" style="white-space: pre; ">&nbsp;  </span></span></font><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">0.001<br>MacPro</span></font><span class="Apple-tab-span" style="white-space: pre; "><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">	               </span></font></span><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">MacOS X 10.4.6<span class="Apple-style-span" style="white-space: pre; ">&nbsp;    </span></span></font><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">6.0 64bit<span class="Apple-style-span" style="white-space: pre; ">&nbsp;  </span></span></font><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">1.001<span class="Apple-style-span" style="white-space: pre; ">&nbsp;  </span></span></font><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">0.500<span class="Apple-style-span" style="white-space: pre; ">&nbsp;  </span></span></font><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">0.100<span class="Apple-style-span" style="white-space: pre; ">&nbsp;  </span></span></font><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">0.050<span class="Apple-style-span" style="white-space: pre; ">&nbsp;  </span></span></font><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">0.010<span class="Apple-style-span" style="white-space: pre; ">&nbsp;  </span></span></font><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">0.005<span class="Apple-style-span" style="white-space: pre; ">&nbsp;  </span></span></font><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">0.002<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vista Business<span class="Apple-style-span" style="white-space: pre; ">&nbsp;    </span></span></font><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">6.0 32bit<span class="Apple-style-span" style="white-space: pre; ">&nbsp;  </span></span></font><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">1.001<span class="Apple-style-span" style="white-space: pre; ">&nbsp;  </span></span></font><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">0.501<span class="Apple-style-span" style="white-space: pre; ">&nbsp;  </span></span></font><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">0.101<span class="Apple-style-span" style="white-space: pre; ">&nbsp;  </span></span></font><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">0.051<span class="Apple-style-span" style="white-space: pre; ">&nbsp;  </span></span></font><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">0.010<span class="Apple-style-span" style="white-space: pre; ">&nbsp;  </span></span></font><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">0.006<span class="Apple-style-span" style="white-space: pre; ">&nbsp;  </span></span></font><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">0.002<br>DELL - Latitude|E6500<span class="Apple-style-span" style="white-space: pre; ">&nbsp;     </span></span></font><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">XP 32<span class="Apple-style-span" style="white-space: pre; ">&nbsp;         </span></span></font><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">5.1 32bit<span class="Apple-style-span" style="white-space: pre; ">&nbsp;  </span></span></font><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">1.016<span class="Apple-style-span" style="white-space: pre; ">&nbsp;  </span></span></font><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">0.516<span class="Apple-style-span" style="white-space: pre; ">&nbsp;  </span></span></font><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">0.109<span class="Apple-style-span" style="white-space: pre; ">&nbsp;  </span></span></font><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">0.063<span class="Apple-style-span" style="white-space: pre; ">&nbsp;  </span></span></font><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">0.015<span class="Apple-style-span" style="white-space: pre; ">&nbsp;  </span></span></font><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">0.016<span class="Apple-style-span" style="white-space: pre; ">&nbsp;  </span></span></font><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">0.016<br>DELL -&nbsp;Precision|M6400<span class="Apple-style-span" style="white-space: pre; ">&nbsp;    </span></span></font><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">XP 64<span class="Apple-style-span" style="white-space: pre; ">&nbsp;         </span></span></font><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">6.0 32bit<span class="Apple-style-span" style="white-space: pre; ">&nbsp;  </span></span></font><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">1.000<span class="Apple-style-span" style="white-space: pre; ">&nbsp;  </span></span></font><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">0.500<span class="Apple-style-span" style="white-space: pre; ">&nbsp;  </span></span></font><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">0.110<span class="Apple-style-span" style="white-space: pre; ">&nbsp;  </span></span></font><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">0.062<span class="Apple-style-span" style="white-space: pre; ">&nbsp;  </span></span></font><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">0.016<span class="Apple-style-span" style="white-space: pre; ">&nbsp;  </span></span></font><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">0.015<span class="Apple-style-span" style="white-space: pre; ">&nbsp;  </span></span></font><font class="Apple-style-span" face="Monaco" size="2"><span class="Apple-style-span" style="font-size: 10px; ">0.016</span></font></div></div></body></html>

               </article>
               <section class=tree>
                <article class=email>
                 <h1>Re: Time to sleep under different platforms</h1>
                 <pre>
It's strange that sleep is much more accurate than the functions of the mp
package 
With an intel mac :

Compute the number of ticks in one second :

(loop with end = (+ 1000 (get-internal-real-time))
      for time = (get-internal-real-time)
      while (&lt; time end)
      do (sleep 0.001)
      count time)

=&gt 500 (which confirm perfectly your observation : on mac the better
resolution - with sleep - is 2ms) and sleep gives a nive regularity as show
this other test&nbsp;:

Compute the min, max and average interval between ticks :

(loop with prev
      with end = (+ 1000 (get-internal-real-time))
      for time = (get-internal-real-time)
      for interval = (and prev (- time prev))
      for i from 0
      while (&lt; time end)
      do (sleep 0.001)
      when interval collect interval
      and maximize interval into max
      and minimize interval into min
      and sum interval into mean
      do (setf prev time)
      finally (return (list min max (float (/ mean i))))) =&gt (2 3 2.0040162)

The same with (mp:process-wait-with-timeout "" 0.001) in place of sleep :

Number of ticks =&gt around 110
Min and max interval =&gt (1 12 8.910714)

MP seems to be limited to a 10 ms precision (but less regular than sleep)

In the other side, using some low level procedure of the mac, I can obtain a
1 ms resolution and even better. So the OS is not all. Many programs which
need a high level of time precision  run very well on XP. Don't you think
that you can obtain a better resolution by using some specific OS
functionalities ? 

Best regards

Denis


Le 21/07/10 19:50, «&nbsp;[NOM]&nbsp;» &lt;[ADRESSE]&gt a écrit&nbsp;:

&gt I tested the accuracy of the sleep function under different conditions (see
&gt the table below).
&gt 
&gt The table was generated using a very simple function, taking the elapsed time
&gt for comparing performance.
&gt I could have done some sampling but these one run results are quite consistent
&gt over many repetitions.
&gt 
&gt The function I used is the following, called form the listener on a freshly
&gt launched LW: 
&gt 
&gt (dolist (sec '(1 0.5 0.1 0.05 0.01 0.005 0.001)) (time (sleep sec)))
&gt 
&gt It is a known fact that Windows XP cannot give accurate time measurement under
&gt about 15 msec. This problem is apparently solved in Vista.
&gt 
&gt Notice that I also ran a test with a Vista virtual image on a MacPro with
&gt excellent accuracy (within 1msec).
&gt 
&gt Does anyone know of a Lisp solution to give Windows XP a better time
&gt resolution?
&gt 
&gt Thanks for your replies.
&gt 
&gt Bruno
&gt 
&gt Machine                      OS             LW
&gt (Sleep x)
&gt                                                       1.000   0.500   0.100
&gt 0.050   0.010   0.005   0.001
&gt MacPro                MacOS X 10.4.6     6.0 64bit   1.001   0.500   0.100
&gt 0.050   0.010   0.005   0.002
&gt                        Vista Business     6.0 32bit   1.001   0.501   0.101
&gt 0.051   0.010   0.006   0.002
&gt DELL - Latitude|E6500      XP 32          5.1 32bit   1.016   0.516   0.109
&gt 0.063   0.015   0.016   0.016
&gt DELL - Precision|M6400     XP 64          6.0 32bit   1.000   0.500   0.110
&gt 0.062   0.016   0.015   0.016
&gt 


-------------------------------------------------------
Denis Pousseur
70 rue de Wansijn
1180 Bruxelles, Belgique

Tel : 32 (0)2 219 31 09
Mail :  denis.pousseur@gmail.com
-------------------------------------------------------



</pre>
                </article>
                <section class=tree>
                 <article class=email>
                  <h1>Re: Time to sleep under different platforms</h1>
                  <pre>
On Wed, 21 Jul 2010 20:46:43 +0100, Denis Pousseur  
&lt;denis.pousseur@gmail.com&gt wrote:


&gt (loop with end = (+ 1000 (get-internal-real-time))
&gt       for time = (get-internal-real-time)
&gt       while (&lt; time end)
&gt       do (sleep 0.001)
&gt       count time)

This yielded 998 in W7 64.

&gt (loop with prev
&gt       with end = (+ 1000 (get-internal-real-time))
&gt       for time = (get-internal-real-time)
&gt       for interval = (and prev (- time prev))
&gt       for i from 0
&gt       while (&lt; time end)
&gt       do (sleep 0.001)
&gt       when interval collect interval
&gt       and maximize interval into max
&gt       and minimize interval into min
&gt       and sum interval into mean
&gt       do (setf prev time)
&gt       finally (return (list min max (float (/ mean i)))))

That evaluated to (1 3 1.0070565).

&gt The same with (mp:process-wait-with-timeout "" 0.001) in place of sleep :

(1 3 1.0060423) with the max going into 5 at most.

BTW, interesting style of LOOPing.


</pre>
                 </article>
                </section>
                <section class=tree>
                 <article class=email>
                  <h1>Re: Time to sleep under different platforms</h1>
                  <pre>
Thanks Denis, 

very interesting loops! 
That alone was worth my posting. 

&gt (loop with end = (+ 1000 (get-internal-real-time))
&gt      for time = (get-internal-real-time)
&gt      while (&lt; time end)
&gt      do (sleep 0.001)
&gt      count time)
&gt =&gt 500 (which confirm perfectly your observation : on mac the better
&gt resolution - with sleep - is 2ms) and sleep gives a nive regularity as show
&gt this other test :

Gives me 964. As I said in my original message I only ran the function once. I was not making a claim that the precision on my MacPro (2 X 3 GHz Quad-Core Intel Xeon) was 2 msec. 
Yuri seems to have the fastest machine on W7 64 with 998. 
In my virtual Vista image the result is 512.

&gt (loop with prev
&gt      with end = (+ 1000 (get-internal-real-time))
&gt      for time = (get-internal-real-time)
&gt      for interval = (and prev (- time prev))
&gt      for i from 0
&gt      while (&lt; time end)
&gt      do (sleep 0.001)
&gt      when interval collect interval
&gt      and maximize interval into max
&gt      and minimize interval into min
&gt      and sum interval into mean
&gt      do (setf prev time)
&gt      finally (return (list min max (float (/ mean i))))) =&gt (2 3 2.0040162)

Result is (1 2 1.0560254) .
Less variability (did not get 3) than Yuri's machine but not as precise (1 3 1.0070565).
In my virtual Vista image the result is (1 3 1.9607073)

&gt The same with (mp:process-wait-with-timeout "" 0.001) in place of sleep :

Result is (0 2 1.0449791)
Same observations as before. The questionable value is the zero minimum. This would confirm the lack of precision of mp:process-wait-with-timeout because in at least in one instance, it did not wait for 1 msec.  
In my virtual Vista image the result is (1 9 1.9762377). Ouch, 9 as a maximum.

&gt 
&gt In the other side, using some low level procedure of the mac, I can obtain a
&gt 1 ms resolution and even better. So the OS is not all. Many programs which
&gt need a high level of time precision  run very well on XP. Don't you think
&gt that you can obtain a better resolution by using some specific OS
&gt functionalities ? 

Yes using some OS specific functionality (MacOS or Windows) is certainly the way to proceed to obtain the maximum precision. 


&gt 
&gt Le 21/07/10 19:50, « [NOM] » &lt;[ADRESSE]&gt a écrit :
&gt 
&gt&gt I tested the accuracy of the sleep function under different conditions (see
&gt&gt the table below).
&gt&gt 
&gt&gt The table was generated using a very simple function, taking the elapsed time
&gt&gt for comparing performance.
&gt&gt I could have done some sampling but these one run results are quite consistent
&gt&gt over many repetitions.
&gt&gt 
&gt&gt The function I used is the following, called form the listener on a freshly
&gt&gt launched LW: 
&gt&gt 
&gt&gt (dolist (sec '(1 0.5 0.1 0.05 0.01 0.005 0.001)) (time (sleep sec)))
&gt&gt 
&gt&gt It is a known fact that Windows XP cannot give accurate time measurement under
&gt&gt about 15 msec. This problem is apparently solved in Vista.
&gt&gt 
&gt&gt Notice that I also ran a test with a Vista virtual image on a MacPro with
&gt&gt excellent accuracy (within 1msec).
&gt&gt 
&gt&gt Does anyone know of a Lisp solution to give Windows XP a better time
&gt&gt resolution?
&gt&gt 
&gt&gt Thanks for your replies.
&gt&gt 
&gt&gt Bruno
&gt&gt 
&gt&gt Machine                      OS             LW
&gt&gt (Sleep x)
&gt&gt                                                      1.000   0.500   0.100
&gt&gt 0.050   0.010   0.005   0.001
&gt&gt MacPro                MacOS X 10.4.6     6.0 64bit   1.001   0.500   0.100
&gt&gt 0.050   0.010   0.005   0.002
&gt&gt                       Vista Business     6.0 32bit   1.001   0.501   0.101
&gt&gt 0.051   0.010   0.006   0.002
&gt&gt DELL - Latitude|E6500      XP 32          5.1 32bit   1.016   0.516   0.109
&gt&gt 0.063   0.015   0.016   0.016
&gt&gt DELL - Precision|M6400     XP 64          6.0 32bit   1.000   0.500   0.110
&gt&gt 0.062   0.016   0.015   0.016
&gt&gt 
&gt 
&gt 
&gt -------------------------------------------------------
&gt Denis Pousseur
&gt 70 rue de Wansijn
&gt 1180 Bruxelles, Belgique
&gt 
&gt Tel : 32 (0)2 219 31 09
&gt Mail :  denis.pousseur@gmail.com
&gt -------------------------------------------------------
&gt 
&gt 


</pre>
                 </article>
                </section>
                <section class=tree>
                 <article class=email>
                  <h1>Re: Time to sleep under different platforms</h1>
                  <pre>

On Jul 21, 2010, at 3:46 PM, Denis Pousseur wrote:

&gt Compute the number of ticks in one second :

Isn't this what cl::internal-time-units-per-second is for?

warmest regards,

Ralph


Raffael Cavallaro
raffaelcavallaro@me.com






</pre>
                 </article>
                 <section class=tree>
                  <article class=email>
                   <h1>Re: Time to sleep under different platforms</h1>
                   <pre>
On my system cl::internal-time-units-per-second return 1000 (and I suppose
on every systems running lw). The result of the test is 500, so it's not the
same thing. But you're right, it's certainly much precise to say : this test
compute the EFFECTIVE number of ticks per second.

Best regards

Denis

Le 22/07/10 1:56, «&nbsp;[NOM]&nbsp;» &lt;[ADRESSE]&gt a écrit&nbsp;:

&gt 
&gt 
&gt On Jul 21, 2010, at 3:46 PM, Denis Pousseur wrote:
&gt 
&gt&gt Compute the number of ticks in one second :
&gt 
&gt Isn't this what cl::internal-time-units-per-second is for?
&gt 
&gt warmest regards,
&gt 
&gt Ralph
&gt 
&gt 
&gt Raffael Cavallaro
&gt raffaelcavallaro@me.com
&gt 
&gt 
&gt 
&gt 
&gt 

-------------------------------------------------------
Denis Pousseur
70 rue de Wansijn
1180 Bruxelles, Belgique

Tel : 32 (0)2 219 31 09
Mail :  denis.pousseur@gmail.com
-------------------------------------------------------



</pre>
                  </article>
                  <section class=tree>
                   <article class=email>
                    <h1>Re: Time to sleep under different platforms</h1>
                    <pre>

On Jul 22, 2010, at 7:53 AM, Denis Pousseur wrote:

&gt On my system cl::internal-time-units-per-second return 1000 (and I suppose
&gt on every systems running lw). The result of the test is 500, so it's not the
&gt same thing. But you're right, it's certainly much precise to say : this test
&gt compute the EFFECTIVE number of ticks per second.


What you're measuring here is the overhead of doing all of these things every time though the loop
1. the loop counter increment
2. get-internal-real-time
3. the comparison with the start time
4. the call to sleep

these things do take some finite time to execute. The counter increment and some sort of comparison are unavoidable - we can't have a finite loop without them, and the calls to sleep are precisely what we want to time. However, if you want to see how far off internal-time-units-per second is wrt sleep, you shouldn't also be doing a call to get-internal-real-time every pass though the loop, and to be precise, we should back out the time for an empty loop of the same size. As it turns out, the empty loop time is negligible (&lt; 1 millisecond), so we can ignore it.

so:

(defun dotimes-ticktest (&amp;optional (times 1000))
  (declare (optimize (speed 3) (safety 0) (debug 0) (compilation-speed 0)
                     (space 0) (fixnum-safety 0) (float 0)))
  (let* ((sleeptime (float (/ internal-time-units-per-second) 0.0s0))
         (start (get-internal-real-time))
         (stop
          (mp:with-interrupts-blocked
            (dotimes (n times (get-internal-real-time))
              (declare (fixnum n))
              (sleep sleeptime)))))
    (declare (fixnum start stop) (single-float sleeptime))
    (float (/ (- stop start) times))))

on my machine this returns 1.11, or an 11% overhead for the calls to sleep. I get similar results with Clozure Common Lisp and sbcl btw - both show about 10-11% overhead for a large number of calls to sleep.

warmest regards,

Ralph




Raffael Cavallaro
raffaelcavallaro@me.com






</pre>
                   </article>
                   <section class=tree>
                    <article class=email>
                     <h1>Re: Time to sleep under different platforms</h1>
                     <pre>
You're perfectly right. My goal was not to develop a tool to measure the
sleep performances. Just to speak about the difference between sleep and the
mp package functions. I suppose that the difference observed with this loop
are not contradicted by your test (at least if we speak of practical
situations and not of pure theory).

Naturally a scheduler cannot be based on a loop like this one, as you said
the time for operations must be included. Moreover, it is why it's not
possible to have a ms scheduler on pure lisp, even with sleep, because to
have one wee need a smaller time definition than ms. The procedure I use on
mac is based on machine time at a resolution of 1.000.000 per second on an
intel mac (less on power pc). With this resolution it's possible to include
the time of the tasks in the computation and have, globally, an ms
resolution (the wait function is not based on an interval but on a point to
reach always relative to the start point).

This message was also to said that something similar is certainly possible
on XP, otherwise I really don't know how some software I used on XP
(especially for sound edition) could works at a 88khz definition...

Anyway, thanks for your very interesting demonstration !

Best regards

Denis



Le 22/07/10 16:43, «&nbsp;[NOM]&nbsp;» &lt;[ADRESSE]&gt a écrit&nbsp;:

&gt 
&gt 
&gt On Jul 22, 2010, at 7:53 AM, Denis Pousseur wrote:
&gt 
&gt&gt On my system cl::internal-time-units-per-second return 1000 (and I suppose
&gt&gt on every systems running lw). The result of the test is 500, so it's not the
&gt&gt same thing. But you're right, it's certainly much precise to say : this test
&gt&gt compute the EFFECTIVE number of ticks per second.
&gt 
&gt 
&gt What you're measuring here is the overhead of doing all of these things every
&gt time though the loop
&gt 1. the loop counter increment
&gt 2. get-internal-real-time
&gt 3. the comparison with the start time
&gt 4. the call to sleep
&gt 
&gt these things do take some finite time to execute. The counter increment and
&gt some sort of comparison are unavoidable - we can't have a finite loop without
&gt them, and the calls to sleep are precisely what we want to time. However, if
&gt you want to see how far off internal-time-units-per second is wrt sleep, you
&gt shouldn't also be doing a call to get-internal-real-time every pass though the
&gt loop, and to be precise, we should back out the time for an empty loop of the
&gt same size. As it turns out, the empty loop time is negligible (&lt; 1
&gt millisecond), so we can ignore it.
&gt 
&gt so:
&gt 
&gt (defun dotimes-ticktest (&amp;optional (times 1000))
&gt   (declare (optimize (speed 3) (safety 0) (debug 0) (compilation-speed 0)
&gt                      (space 0) (fixnum-safety 0) (float 0)))
&gt   (let* ((sleeptime (float (/ internal-time-units-per-second) 0.0s0))
&gt          (start (get-internal-real-time))
&gt          (stop
&gt           (mp:with-interrupts-blocked
&gt             (dotimes (n times (get-internal-real-time))
&gt               (declare (fixnum n))
&gt               (sleep sleeptime)))))
&gt     (declare (fixnum start stop) (single-float sleeptime))
&gt     (float (/ (- stop start) times))))
&gt 
&gt on my machine this returns 1.11, or an 11% overhead for the calls to sleep. I
&gt get similar results with Clozure Common Lisp and sbcl btw - both show about
&gt 10-11% overhead for a large number of calls to sleep.
&gt 
&gt warmest regards,
&gt 
&gt Ralph
&gt 
&gt 
&gt 
&gt 
&gt Raffael Cavallaro
&gt raffaelcavallaro@me.com
&gt 
&gt 
&gt 
&gt 
&gt 

-------------------------------------------------------
Denis Pousseur
70 rue de Wansijn
1180 Bruxelles, Belgique

Tel : 32 (0)2 219 31 09
Mail :  denis.pousseur@gmail.com
-------------------------------------------------------



</pre>
                    </article>
                    <section class=tree>
                     <article class=email>
                      <h1>Re: Time to sleep under different platforms</h1>
                      <pre>
On Thu, 22 Jul 2010 17:48:05 +0100, Denis Pousseur  
&lt;denis.pousseur@gmail.com&gt wrote:

&gt otherwise I really don't know how some software I used on XP
&gt (especially for sound edition) could works at a 88khz definition...

Well, for sound processing 50 frames per second is fairly acceptable, that  
amounts to 20 ms buffers, which is manageable even with interpreted code,  
as the examples have shown.


</pre>
                     </article>
                    </section>
                   </section>
                  </section>
                 </section>
                </section>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: Time to sleep under different platforms</h1>
                 <pre>
&gt It is a known fact that Windows XP cannot give accurate time measurement
&gt under about 15 msec. This problem is apparently solved in Vista.

How To Use QueryPerformanceCounter to Time Code

http://support.microsoft.com/kb/172338


</pre>
                </article>
               </section>
              </section>
             </div>
            </div>
            <footer class="d-flex justify-content-center">
             <div>
              Updated at: 2020-12-10 08:39 UTC
             </div>
            </footer>
           </body>
          </html>