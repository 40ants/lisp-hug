<!DOCTYPE html>
<html lang=en>
           <head>
            <meta charset=UTF-8>
            <title>Re: Symbol-macros?</title>
            <meta name=viewport
                  content="width=device-width, initial-scale=1.0">
            <link rel=stylesheet
                  href=https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css
                  integrity=sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2
                  crossorigin=anonymous>
            <style>
section.tree {
    padding-left: 2em;
}
section.tree:first-child {
    padding-left: 0;
}
.article-link {
  margin-bottom: 1em;
}
</style>
<!-- Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-9X3G9MMWZP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-9X3G9MMWZP');
</script>

           </head>
           <body>
            <header class="d-flex justify-content-center">
             <nav
                  class="navbar navbar-light bg-light w-100 mx-5 mb-3">
              <a class=navbar-brand href="/">Lisp HUG Maillist Archive</a>
             </nav>
            </header>
            <div class="d-flex justify-content-center">
             <div class="w-100 mx-5 px-3">
              <section class=tree>
               <article class=email>
                <h1>Re: Symbol-macros?</h1>
                <pre>
.... I suspect that the reasons are largely historical. To whit:

If a symbol were merely a name pointing to a reference cell which holds the value and the function binding, and the plist, then after entering a defun or lambda expression, if the compiler were to store a pointer to the reference cell, there would be no easy way to decompile the definition back to S-expr, showing the original symbol names.

That probably hearkens back to the old days when Lisp was largely interpreted.

A reference cell implementation would easily permit arbitrary naming of the same cell. But which name was used upon decompilation? And besides, that would necessitate additional storage in the compiled expression in order to reveal the originally used symbol name.

It looks like, in order to support this kind of thing, the nature of the symbol reader, and packages, would have to be expanded to permit the notion of "indirect symbols" - where an alias is indirected at runtime to the original symbol. That slows things down. 

.... but so does this:

(defmacro alias (sym fn)
 	`(defun ,sym (&amp;rest args)
		(apply #',fn ,args)))

.... and this loses the original lambda list for quick documentation purposes.

Dr. David McClain
Chief Technical Officer
Refined Audiometrics Laboratory
4391 N. Camino Ferreo
Tucson, AZ  85750

email: dbm@refined-audiometrics.com
phone: 1.520.390.3995
web: http://www.refined-audiometrics.com




</pre>
               </article>
              </section>
             </div>
            </div>
            <footer class="d-flex justify-content-center">
             <div>
              Updated at: 2020-12-10 08:39 UTC
             </div>
            </footer>
           </body>
          </html>