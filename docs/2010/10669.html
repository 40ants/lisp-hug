<!DOCTYPE html>
<html lang=en>
           <head>
            <meta charset=UTF-8>
            <title>compiled and interpreted functions</title>
            <link rel=stylesheet
                  href=https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css
                  integrity=sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2
                  crossorigin=anonymous>
            <style>
section.tree {
    padding-left: 2em;
}
section.tree:first-child {
    padding-left: 0;
}
.article-link {
  margin-bottom: 1em;
}
</style>
<!-- Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-9X3G9MMWZP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-9X3G9MMWZP');
</script>

           </head>
           <body>
            <header class="d-flex justify-content-center">
             <nav
                  class="navbar navbar-light bg-light w-100 mx-5 mb-3">
              <a class=navbar-brand href="/">Lisp HUG Maillist Archive</a>
             </nav>
            </header>
            <div class="d-flex justify-content-center">
             <div class="w-100 mx-5 px-3">
              <section class=tree>
               <article class=email>
                <h1>compiled and interpreted functions</h1>
                <pre>
Greeting Lispers!

I just need to sort some things out.


1. Let's say I have this function

(defun make-adder (num)
  (lambda (x)
    (+ num x)))

When make-adder is a compiled function, the closure it produces is compiled too. When make-adder isn't a compiled function, the closure also isn't compiled.

Question: is it possible for a compiled function to produce an uncompiled closure function?


2. When I inspect an interpreted function in the gui inspector, I can see the 'code' attribute. Is there a way to access that attribute and change the code of the function to a new code?


3. When I do (disassemble ..) to an interpreted function, I can see the machine code. As I got it, disassemble compiles any interpreted function before showing its output. Is it true?

Best,
 Art



p.s. Is there a difference between this

(defun make-adder (num)
  (lambda (x)
    (+ num x)))

and this

(defun make-adder (num)
  (function (lambda (x)
     (+ num x))))


</pre>
               </article>
               <section class=tree>
                <article class=email>
                 <h1>Re: compiled and interpreted functions</h1>
                 <p>
                  Unable to parse email body. Email id is 10671
                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: compiled and interpreted functions</h1>
                 <pre>
On Sat, 23 Oct 2010 08:28:23 +0100, Nick Levine &lt;ndl@ravenbrook.com&gt wrote:

&gt Not straightforwardly. And of course children what follows is just a
&gt thought experiment, as we all know that eval is evil.

It is not the first time I come across this statement (that eval in run  
time is evil), however there were never any arguments accompanying it and  
I could not think of my own.


</pre>
                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: compiled and interpreted functions</h1>
                 <pre>
On Sat, 23 Oct 2010 19:39:01 +0100, Tim Bradshaw &lt;tfb@cley.com&gt wrote:

&gt - by the same token, EVAL makes it pretty hard to ever prove that  
&gt something is not used, which makes tree-shaking hard;

This one looks like a valid enough reason, however I think Graham used  
this idiom in that form or the other in his early 90s books on Lisp.

The question arises, was the concept of tree-shaking used nowadays for  
stand-alone executive files delivery in wide-spread acknowledgement then?

P.S. I could be wrong about dating these notions altogether, actually.


</pre>
                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: compiled and interpreted functions</h1>
                 <pre>
"Yuri Davidovsky" &lt;yury.davidouski2@mail.dcu.ie&gt writes:

&gt On Sat, 23 Oct 2010 19:39:01 +0100, Tim Bradshaw &lt;tfb@cley.com&gt wrote:
&gt
&gt&gt - by the same token, EVAL makes it pretty hard to ever prove that
&gt&gt something is not used, which makes tree-shaking hard;
&gt
&gt This one looks like a valid enough reason, however I think Graham used
&gt this idiom in that form or the other in his early 90s books on Lisp.
&gt
&gt The question arises, was the concept of tree-shaking used nowadays for
&gt stand-alone executive files delivery in wide-spread acknowledgement
&gt then?
&gt
&gt P.S. I could be wrong about dating these notions altogether, actually.

It would depend on the application.  

If you're writing an emacs, you want to call EVAL on user provided forms
at run-time.

If you're writing a Notepad, you don't.

If you're writing an MS-Word, you would have to write a Basic-to-Lisp
translator before calling EVAL, or just write a Basic interpreter.


-- 
__Pascal Bourguignon__                     http://www.informatimago.com/


</pre>
                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: compiled and interpreted functions</h1>
                 <pre>
On Sat, 23 Oct 2010 20:11:42 +0100, Pascal J. Bourguignon  
&lt;pjb@informatimago.com&gt wrote:

&gt If you're writing an emacs, you want to call EVAL on user provided forms
&gt at run-time.
&gt If you're writing a Notepad, you don't.
&gt If you're writing an MS-Word, you would have to write a Basic-to-Lisp
&gt translator before calling EVAL, or just write a Basic interpreter.

It appears that if one writes anything with a certain level of scripting  
capability it would likely require EVAL of some form and amount.

User script would be converted into Lisp code by macros and then  
evaluated, that would be the easiest solution for custom script support.


</pre>
                </article>
               </section>
              </section>
             </div>
            </div>
            <footer class="d-flex justify-content-center">
             <div>
              Updated at: 2020-12-07 08:34 UTC
             </div>
            </footer>
           </body>
          </html>