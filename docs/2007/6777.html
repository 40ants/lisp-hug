<!DOCTYPE html>
<html lang=en>
           <head>
            <meta charset=UTF-8>
            <title>Re: CSV Files</title>
            <meta name=viewport
                  content="width=device-width, initial-scale=1.0">
            <link rel=stylesheet
                  href=https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css
                  integrity=sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2
                  crossorigin=anonymous>
            <style>
section.tree {
    padding-left: 2em;
}
section.tree:first-child {
    padding-left: 0;
}
.article-link {
  margin-bottom: 1em;
}
</style>
<!-- Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-9X3G9MMWZP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-9X3G9MMWZP');
</script>

           </head>
           <body>
            <header class="d-flex justify-content-center">
             <nav
                  class="navbar navbar-light bg-light w-100 mx-5 mb-3">
              <a class=navbar-brand href="/">Lisp HUG Maillist Archive</a>
             </nav>
            </header>
            <div class="d-flex justify-content-center">
             <div class="w-100 mx-5 px-3">
              <section class=tree>
               <article class=email>
                <h1>Re: CSV Files</h1><HTML><BODY style="word-wrap: break-word; -khtml-nbsp-mode: space; -khtml-line-break: after-white-space; ">BTW... for anyone interested, I have a very fast CSV File reader/parser in Lisp, that I will pass along. I rewrote an older version of same a few weeks ago, but this time, I made extensive use of caching, and perform as few computations as possible until demanded by the calling application. <DIV><BR class="khtml-block-placeholder"></DIV><DIV>The result is very very fast, uses little or no copying, except when necessary for safety sake (as when allowing a user specified function access to the embedded string in a line read from a file).</DIV><DIV><BR class="khtml-block-placeholder"></DIV><DIV>In all, about 250 lines of Lisp code. not much...</DIV><DIV><BR class="khtml-block-placeholder"></DIV><DIV>Aww heck....</DIV><DIV><BR class="khtml-block-placeholder"></DIV><DIV>------------------------------------</DIV><DIV>;; fast-csv.lisp -- Fast, Simple, CSV File Reading</DIV><DIV>;;</DIV><DIV>;; This version is very fast because it does the minimum possible work</DIV><DIV>;; in reading CSV files, and extracting information on demand.</DIV><DIV>;;</DIV><DIV>;; It is assumed that no fields are quoted fields that contain the primary delimiter.</DIV><DIV>;; Primary delimiters (comma for CSV, tab for TSV files) are heuristically determined</DIV><DIV>;; from examination of the first line of the file, which is assumed to be the headings</DIV><DIV>;; line. Subsequent lines are assumed to contain data. Empty lines are discarded.</DIV><DIV>;;</DIV><DIV>;; These conditions are satisfied by nearly 99%+ of all the CSV files ever seen.</DIV><DIV>;; If your CSV/TSV file violates any of these conditions, then use the more elaborate</DIV><DIV>;; and general-purpose routines in CSV.LISP.</DIV><DIV>;;</DIV><DIV>;; DM/RAL  06/07</DIV><DIV>;; ----------------------------------------------------------------------------</DIV><DIV><BR class="khtml-block-placeholder"></DIV><DIV>(defpackage fast-csv</DIV><DIV>  (:use common-lisp)</DIV><DIV>  (:nicknames fcsv)</DIV><DIV>  (:export</DIV><DIV>   read-file</DIV><DIV>   get-column</DIV><DIV>   get-numeric-column</DIV><DIV>   get-field</DIV><DIV>   get-numeric-field))</DIV><DIV><BR class="khtml-block-placeholder"></DIV><DIV>(in-package fast-csv)</DIV><DIV><BR class="khtml-block-placeholder"></DIV><DIV>(defun collect-delimiter-positions (s delim &amp;key count (start 0))</DIV><DIV>  (loop with  pos = start</DIV><DIV>        with  end = start</DIV><DIV>        while (and end</DIV><DIV>                   (or (null count)</DIV><DIV>                       (plusp count)))</DIV><DIV>        do    (setq end (position delim s :start pos))</DIV><DIV>        collect (or end (length s))</DIV><DIV>        when  end</DIV><DIV>        do    (setq pos (1+ end))</DIV><DIV>        when  count</DIV><DIV>        do    (decf count)</DIV><DIV>        ))</DIV><DIV><BR class="khtml-block-placeholder"></DIV><DIV>(defun collect-headers (s delim)</DIV><DIV>  (let ((pos (collect-delimiter-positions s delim)))</DIV><DIV>    (loop with start = 0</DIV><DIV>          for  p in pos</DIV><DIV>          collect (subseq s start p)</DIV><DIV>          do      (setq start (1+ p))</DIV><DIV>          )))</DIV><DIV><BR class="khtml-block-placeholder"></DIV><DIV>(defun read-lines (&amp;optional fname)</DIV><DIV>  ;;</DIV><DIV>  ;; Return a list of text lines from the file</DIV><DIV>  ;;</DIV><DIV>  (lw:when-let (fnm (or fname </DIV><DIV><SPAN class="Apple-tab-span" style="white-space:pre">	</SPAN>             (capi:prompt-for-file</DIV><DIV><SPAN class="Apple-tab-span" style="white-space:pre">	</SPAN>              "Select File to Read"</DIV><DIV><SPAN class="Apple-tab-span" style="white-space:pre">	</SPAN>              :filters '("CSV Files" "*.csv;*.tsv"</DIV><DIV>                                             "All Files" "*.*"))</DIV><DIV><SPAN class="Apple-tab-span" style="white-space:pre">	</SPAN>             ))</DIV><DIV>    (with-open-file (fp fnm)</DIV><DIV>      (loop for line = (read-line fp nil :eof)</DIV><DIV>            until (eq line :eof)</DIV><DIV>            while line</DIV><DIV>            when  (plusp (length line)) ;; elide empty lines</DIV><DIV>            collect line))</DIV><DIV>    ))</DIV><DIV><BR class="khtml-block-placeholder"></DIV><DIV>(defun decide-csv-or-tsv (line)</DIV><DIV>  ;;</DIV><DIV>  ;; count the number of commas and tabs in the list of lines.</DIV><DIV>  ;; If commas outnumber tabs then we probably have CSV. Else we</DIV><DIV>  ;; probably have TSV.</DIV><DIV>  ;;</DIV><DIV>  (let ((n-comma (count-if (um:curry #'char= #\,)   line))</DIV><DIV><SPAN class="Apple-tab-span" style="white-space:pre">	</SPAN>(n-tab   (count-if (um:curry #'char= #\Tab) line)))</DIV><DIV>    (if (&gt; n-comma n-tab)</DIV><DIV>        #\,</DIV><DIV>      #\Tab)</DIV><DIV>    ))</DIV><DIV><BR class="khtml-block-placeholder"></DIV><DIV>(defstruct csv-info</DIV><DIV>  hdrs</DIV><DIV>  delim</DIV><DIV>  row-infos</DIV><DIV>  nlines</DIV><DIV>  lines</DIV><DIV>  ends-cache)</DIV><DIV><BR class="khtml-block-placeholder"></DIV><DIV>(defun collect-additional-ends (info column row line)</DIV><DIV>  (with-accessors ((ends-cache  csv-info-ends-cache)</DIV><DIV>                   (row-infos   csv-info-row-infos )</DIV><DIV>                   (delim       csv-info-delim     )) info</DIV><DIV>    (let* ((ends     (aref row-infos row))</DIV><DIV>           (new-ends (if ends</DIV><DIV>                         ;; we have some partial information</DIV><DIV>                         (let* ((nends     (length ends))</DIV><DIV>                                (more-ends (collect-delimiter-positions</DIV><DIV>                                            line delim</DIV><DIV>                                            :count (1+ (- column nends))</DIV><DIV>                                            :start (1+ (aref ends (1- nends)))</DIV><DIV>                                            )))</DIV><DIV>                           (concatenate 'vector ends more-ends))</DIV><DIV>                       </DIV><DIV>                       ;; else we never had any information -- build from scratch</DIV><DIV>                       (coerce</DIV><DIV>                        (collect-delimiter-positions</DIV><DIV>                         line delim</DIV><DIV>                         :count (1+ column)</DIV><DIV>                         :start 0)</DIV><DIV>                        'vector)))</DIV><DIV>           </DIV><DIV>           (unique-ends (gethash new-ends ends-cache nil)))</DIV><DIV>      (unless unique-ends</DIV><DIV>        (setf (gethash new-ends ends-cache) new-ends))</DIV><DIV>      (setf (aref row-infos row) (or unique-ends new-ends))</DIV><DIV>      )))</DIV><DIV><BR class="khtml-block-placeholder"></DIV><DIV>(defun ensure-column-of-row-exists (info column row line)</DIV><DIV>  ;; at this point row-info cannot be nil, but its contents might be...</DIV><DIV>  (with-accessors ((row-infos  csv-info-row-infos)) info</DIV><DIV>    (let ((ends (aref row-infos row)))</DIV><DIV>      (unless (&lt; column (length ends))</DIV><DIV>        (collect-additional-ends info column row line))</DIV><DIV>      )))</DIV><DIV>          </DIV><DIV>(defun extract-data-of-column (info column reverse op)</DIV><DIV>  (with-accessors ((nlines    csv-info-nlines)</DIV><DIV>                   (lines     csv-info-lines)</DIV><DIV>                   (row-infos csv-info-row-infos)) info</DIV><DIV>    (let* ((nelm1 (1- nlines))</DIV><DIV>           (data  (make-array nlines)))</DIV><DIV>      (loop for line in lines</DIV><DIV>            for row from 0</DIV><DIV>            for revrow = (- nelm1 row)</DIV><DIV>            do</DIV><DIV>            (ensure-column-of-row-exists info column row line)</DIV><DIV>            ;; at this point ends is a vector of delimiter positions</DIV><DIV>            ;; that is at least as long as one greater than the column index</DIV><DIV>            (let* ((ends  (aref row-infos row))</DIV><DIV>                   (start (if (zerop column)</DIV><DIV>                              0</DIV><DIV>                            (1+ (aref ends (1- column)))</DIV><DIV>                            ))</DIV><DIV>                   (end   (aref ends column))</DIV><DIV>                   (datum (funcall op line start end)))</DIV><DIV>              (setf (aref data (if reverse revrow row)) datum)</DIV><DIV>              ))</DIV><DIV>      data</DIV><DIV>      )))</DIV><DIV><BR class="khtml-block-placeholder"></DIV><DIV>(defun get-column-of-hdr (hdr info)</DIV><DIV>  (position (um:mkstr hdr) (csv-info-hdrs info)</DIV><DIV>            :test #'string-equal))</DIV><DIV><BR class="khtml-block-placeholder"></DIV><DIV>(defun ensure-row-infos-exist (info column all)</DIV><DIV>  (with-accessors ((row-infos  csv-info-row-infos)</DIV><DIV>                   (nlines     csv-info-nlines   )</DIV><DIV>                   (lines      csv-info-lines    )) info</DIV><DIV>    (unless row-infos</DIV><DIV>      (setf row-infos (make-array nlines))</DIV><DIV>      (when all</DIV><DIV>        (loop for row from 0</DIV><DIV>              for line in lines</DIV><DIV>              do</DIV><DIV>              (collect-additional-ends info column row line)))</DIV><DIV>      )))</DIV><DIV><BR class="khtml-block-placeholder"></DIV><DIV>(defun get-string-field-op (op)</DIV><DIV>  (if op</DIV><DIV>      (um:compose op #'subseq)</DIV><DIV>    #'subseq))</DIV><DIV><BR class="khtml-block-placeholder"></DIV><DIV>(defun get-numeric-field-op (scrubber op)</DIV><DIV>  (let ((pre-op</DIV><DIV>         (if scrubber</DIV><DIV>             ;; we need to extract a subseq for the user's function</DIV><DIV>             (lambda (line start end)</DIV><DIV>               (read-from-string</DIV><DIV>                (funcall scrubber (subseq line start end))</DIV><DIV>                nil 0))</DIV><DIV>           </DIV><DIV>           ;; else we can avoid creating a subseq</DIV><DIV>           (lambda (line start end)</DIV><DIV>             (read-from-string line nil 0</DIV><DIV>                               :start start :end end)))</DIV><DIV>         ))</DIV><DIV>    (if op</DIV><DIV>        (um:compose op pre-op)</DIV><DIV>      pre-op)</DIV><DIV>    ))</DIV><DIV><BR class="khtml-block-placeholder"></DIV><DIV>;; --------------------------------------------------------------</DIV><DIV>;; user accessible routines...</DIV><DIV>;;</DIV><DIV>(defun read-file (fname &amp;key (ndrop 0))</DIV><DIV>  (let* ((lines      (nthcdr ndrop (read-lines fname)))</DIV><DIV>         (delim      (decide-csv-or-tsv (first lines)))</DIV><DIV>         (hdrs       (collect-headers (first lines) delim))</DIV><DIV>         (data-lines (rest lines)))</DIV><DIV>    (make-csv-info</DIV><DIV>     :hdrs       hdrs</DIV><DIV>     :delim      delim</DIV><DIV>     :row-infos  nil ;; a vector of vectors of delimiter positions</DIV><DIV>     :nlines     (length data-lines)</DIV><DIV>     :lines      data-lines</DIV><DIV>     :ends-cache (make-hash-table :test #'equalp)</DIV><DIV>     )))</DIV><DIV>         </DIV><DIV>(defun get-column (hdr info &amp;key reverse op num-op)</DIV><DIV>  ;; user should utilize keys :reverse and :op</DIV><DIV>  ;; the :num-op key is for our private use</DIV><DIV>  (let* ((column (get-column-of-hdr hdr info)))</DIV><DIV>    (when column</DIV><DIV>      (ensure-row-infos-exist info column :all)</DIV><DIV>      (extract-data-of-column info column reverse</DIV><DIV>                              (or num-op</DIV><DIV>                                  (get-string-field-op op)))</DIV><DIV>      )))</DIV><DIV><BR class="khtml-block-placeholder"></DIV><DIV>(defun get-numeric-column (hdr info &amp;key scrubber reverse op)</DIV><DIV>  (get-column hdr info</DIV><DIV>              :reverse reverse</DIV><DIV>              :num-op  (get-numeric-field-op scrubber op)))</DIV><DIV><BR class="khtml-block-placeholder"></DIV><DIV><BR class="khtml-block-placeholder"></DIV><DIV>(defun get-field (hdr row info &amp;key op num-op reverse)</DIV><DIV>  ;; user should utilize keys :reverse and :op</DIV><DIV>  ;; the :num-op key is for our private use</DIV><DIV>  (with-accessors ((lines     csv-info-lines    )</DIV><DIV>                   (row-infos csv-info-row-infos)</DIV><DIV>                   (nlines    csv-info-nlines   )) info</DIV><DIV>    (let ((column (get-column-of-hdr hdr info)))</DIV><DIV>      (when column</DIV><DIV>        (ensure-row-infos-exist info column nil)</DIV><DIV>        (let* ((actual-row (cond ((numberp row) (if reverse</DIV><DIV>                                                    (- nlines row 1)</DIV><DIV>                                                  row))</DIV><DIV>                                 </DIV><DIV>                                 ((eq row :last) (if reverse</DIV><DIV>                                                     0</DIV><DIV>                                                   (1- nlines)))</DIV><DIV>                                 </DIV><DIV>                                 ((eq row :first) (if reverse</DIV><DIV>                                                      (1- nlines)</DIV><DIV>                                                    0))</DIV><DIV>                                 ))</DIV><DIV>               (line (nth actual-row lines)))</DIV><DIV>          (ensure-column-of-row-exists info column actual-row line)</DIV><DIV>          (let* ((ends  (aref row-infos actual-row))</DIV><DIV>                 (start (if (zerop column)</DIV><DIV>                            0</DIV><DIV>                          (1+ (aref ends (1- column)))</DIV><DIV>                          ))</DIV><DIV>                 (end   (aref ends column)))</DIV><DIV>            (funcall (or num-op</DIV><DIV>                         (get-string-field-op op))</DIV><DIV>                     line start end)</DIV><DIV>            ))</DIV><DIV>        ))</DIV><DIV>    ))</DIV><DIV><BR class="khtml-block-placeholder"></DIV><DIV>(defun get-numeric-field (hdr row info &amp;key scrubber op reverse)</DIV><DIV>  (get-field hdr row info</DIV><DIV>             :num-op (get-numeric-field-op scrubber op)</DIV><DIV>             :reverse reverse))</DIV><DIV><BR class="khtml-block-placeholder"></DIV><DIV>-----------------------------------------<DIV><BR><DIV> <SPAN class="Apple-style-span" style="border-collapse: separate; border-spacing: 0px 0px; color: rgb(0, 0, 0); font-family: Helvetica; font-size: 12px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-align: auto; -khtml-text-decorations-in-effect: none; text-indent: 0px; -apple-text-size-adjust: auto; text-transform: none; orphans: 2; white-space: normal; widows: 2; word-spacing: 0px; "><SPAN class="Apple-style-span" style="border-collapse: separate; border-spacing: 0px 0px; color: rgb(0, 0, 0); font-family: Helvetica; font-size: 12px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-align: auto; -khtml-text-decorations-in-effect: none; text-indent: 0px; -apple-text-size-adjust: auto; text-transform: none; orphans: 2; white-space: normal; widows: 2; word-spacing: 0px; "><SPAN class="Apple-style-span" style="border-collapse: separate; border-spacing: 0px 0px; color: rgb(0, 0, 0); font-family: Helvetica; font-size: 12px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-align: auto; -khtml-text-decorations-in-effect: none; text-indent: 0px; -apple-text-size-adjust: auto; text-transform: none; orphans: 2; white-space: normal; widows: 2; word-spacing: 0px; "><SPAN class="Apple-style-span" style="border-collapse: separate; border-spacing: 0px 0px; color: rgb(0, 0, 0); font-family: Helvetica; font-size: 12px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-align: auto; -khtml-text-decorations-in-effect: none; text-indent: 0px; -apple-text-size-adjust: auto; text-transform: none; orphans: 2; white-space: normal; widows: 2; word-spacing: 0px; "><DIV style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">David McClain</DIV><DIV style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">Chief Technical Officer</DIV><DIV style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">Refined Audiometrics Laboratory</DIV><DIV style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">4391 N. Camino Ferreo</DIV><DIV style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">Tucson, AZ  85750</DIV><DIV style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font: normal normal normal 12px/normal Helvetica; min-height: 14px; "><BR></DIV><DIV style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">email: <A href="mailto:dbm@refined-audiometrics.com">dbm@refined-audiometrics.com</A></DIV><DIV style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">phone: 1.520.390.3995</DIV><DIV style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">web: <A href="http://www.refined-audiometrics.com">http://www.refined-audiometrics.com</A></DIV><DIV style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">Skype: dbmcclain</DIV><BR class="Apple-interchange-newline"></SPAN><SPAN></SPAN></SPAN></SPAN></SPAN> </DIV><BR></DIV></DIV></BODY></HTML>

               </article>
              </section>
             </div>
            </div>
            <footer class="d-flex justify-content-center">
             <div>
              Updated at: 2020-12-10 08:45 UTC
             </div>
            </footer>
           </body>
          </html>