<!DOCTYPE html>
<html lang=en>
           <head>
            <meta charset=UTF-8>
            <title>Extended Format Numeric Input</title>
            <meta name=viewport
                  content="width=device-width, initial-scale=1.0">
            <link rel=stylesheet
                  href=https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css
                  integrity=sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2
                  crossorigin=anonymous>
            <style>
section.tree {
    padding-left: 2em;
}
section.tree:first-child {
    padding-left: 0;
}
.article-link {
  margin-bottom: 1em;
}
</style>
<!-- Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-9X3G9MMWZP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-9X3G9MMWZP');
</script>

           </head>
           <body>
            <header class="d-flex justify-content-center">
             <nav
                  class="navbar navbar-light bg-light w-100 mx-5 mb-3">
              <a class=navbar-brand href="/">Lisp HUG Maillist Archive</a>
             </nav>
            </header>
            <div class="d-flex justify-content-center">
             <div class="w-100 mx-5 px-3">
              <section class=tree>
               <article class=email>
                <h1>Extended Format Numeric Input</h1><html><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space; ">
<div>Howdy!</div><div><br></div>... One of the things I miss most about my ancient Forth systems was its ability to directly enter sexagisimal numbers for angles and time: e.g., -110:32:56.47 and 23:59:56<div><br></div><div>So, Doug Hoyte's new book "Let Over Lambda" inspired me to do something about this lacking in Lisp... Mucho gracias to Doug for the inspiration, and Edi Weitz for PPCRE!!</div><div><br></div><div>Still not quite as convenient as in Forth, but not too bad. The colons require quoting, as in #n|23:59:56|, #n|-110:43|. </div><div><br></div><div>But I didn't stop there. I also added support for hyphenated number #n390-3995, underscore and comma separators in long numbers #n123_456_789, #n1.005_003, and #nX1234_5678 or #n|123,456.890|  (quotes needed for comma sepators), date entry as in #n2009/03/19 -- and for us Americans #n3/19/09, and complex number input as in #n1.3-2.7j and 3.5i. And a lot of other variations on these themes.</div><div><br></div><div>Perhaps you all will find this useful too... (or perhaps I'm the only one who didn't already have this stuff?)</div><div><br></div><div>The code that follows is all contained in an eval-when clause because so many of the defuns and macros are needed by the compiler along the way. There are a couple of non-Doug goodies in there too -- such as bang-A symbols to indicate anaphora that should become interned into the package that uses anaphoric macros, instead of requiring you to import those symbols when your compiler complains about unbound anaphoric symbols. Not needed here, per se, but I didn't feel like going through the code and removing references to defmacro/a!. </div><div><br></div><div>BTW: Doug's book is near mandatory reading for any serious Lisper, except for those old dogs who already knew all that stuff about macros!<br><br></div><div><font class="Apple-style-span" face="Courier">;; -----------------------------------------------------------</font></div><div><font class="Apple-style-span" face="Courier">;; tools needed to support Doug Hoyte's DEFMACRO!</font></div><div><font class="Apple-style-span" face="Courier"><br></font></div><div><div><font class="Apple-style-span" face="Courier">(eval-when (:compile-toplevel :load-toplevel :execute)</font></div><div><font class="Apple-style-span" face="Courier"><br></font></div><div><font class="Apple-style-span" face="Courier">  (defun collect-if (predicate proseq &amp;rest rest)</font></div><div><font class="Apple-style-span" face="Courier">    (apply 'remove-if-not predicate proseq rest))</font></div><div><font class="Apple-style-span" face="Courier">  </font></div><div><font class="Apple-style-span" face="Courier">  ;; --------------------------------------------</font></div><div><font class="Apple-style-span" face="Courier">  ;; Bang-symbols</font></div><div><font class="Apple-style-span" face="Courier">  (defun bang-symbol-p (prefix s)</font></div><div><font class="Apple-style-span" face="Courier">    (and (symbolp s)</font></div><div><font class="Apple-style-span" face="Courier">         (> (length (symbol-name s)) 2)</font></div><div><font class="Apple-style-span" face="Courier">         (string= (symbol-name s) prefix</font></div><div><font class="Apple-style-span" face="Courier">                  :start1 0</font></div><div><font class="Apple-style-span" face="Courier">                  :end1   2)))</font></div><div><font class="Apple-style-span" face="Courier"><br></font></div><div><font class="Apple-style-span" face="Courier">  (defun get-bang-symbols (prefix body)</font></div><div><font class="Apple-style-span" face="Courier">    (remove-duplicates</font></div><div><font class="Apple-style-span" face="Courier">     (collect-if (curry #'bang-symbol-p prefix) (flatten body))))</font></div><div><font class="Apple-style-span" face="Courier">      </font></div><div><font class="Apple-style-span" face="Courier">  (defun bang-symbol-name (s)</font></div><div><font class="Apple-style-span" face="Courier">    (subseq (symbol-name s) 2))</font></div><div><font class="Apple-style-span" face="Courier">  </font></div><div><font class="Apple-style-span" face="Courier">  ;; --------------------------------------------</font></div><div><font class="Apple-style-span" face="Courier"><br></font></div><div><font class="Apple-style-span" face="Courier">  (defun raw-mkstr (&amp;rest args)</font></div><div><font class="Apple-style-span" face="Courier">    (with-output-to-string (s)</font></div><div><font class="Apple-style-span" face="Courier">      (dolist (a args) </font></div><div><font class="Apple-style-span" face="Courier">        (princ a s))</font></div><div><font class="Apple-style-span" face="Courier">      ))</font></div><div><font class="Apple-style-span" face="Courier">  </font></div><div><font class="Apple-style-span" face="Courier">  (defun mkstr (&amp;rest args)</font></div><div><font class="Apple-style-span" face="Courier">    (with-standard-io-syntax</font></div><div><font class="Apple-style-span" face="Courier">      (apply #'raw-mkstr args)))</font></div><div><font class="Apple-style-span" face="Courier">  </font></div><div><font class="Apple-style-span" face="Courier">  (defun correct-for-symbol-character-case (str)</font></div><div><font class="Apple-style-span" face="Courier">    ;; a portable way to make symbol strings</font></div><div><font class="Apple-style-span" face="Courier">    ;; Modern Mode vs ANSI</font></div><div><font class="Apple-style-span" face="Courier">    (if (eql #\a (char (string :a) 0))</font></div><div><font class="Apple-style-span" face="Courier">        (string-downcase (string str))</font></div><div><font class="Apple-style-span" face="Courier">      (string-upcase (string str))))</font></div><div><font class="Apple-style-span" face="Courier"><br></font></div><div><font class="Apple-style-span" face="Courier">  (defun intern-symbol (str &amp;rest package)</font></div><div><font class="Apple-style-span" face="Courier">    (apply #'intern (correct-for-symbol-character-case str) package))</font></div><div><font class="Apple-style-span" face="Courier">  </font></div><div><font class="Apple-style-span" face="Courier">  (defun symb (&amp;rest args)</font></div><div><font class="Apple-style-span" face="Courier">    (values (intern-symbol (apply #'mkstr args))))</font></div><div><font class="Apple-style-span" face="Courier">  </font></div><div><font class="Apple-style-span" face="Courier">  ;; --------------------------------------------</font></div><div><font class="Apple-style-span" face="Courier"><br></font></div><div><font class="Apple-style-span" face="Courier">  (defun |reader-for-#`| (stream sub-char numarg)</font></div><div><font class="Apple-style-span" face="Courier">    (declare (ignore sub-char))</font></div><div><font class="Apple-style-span" face="Courier">    (unless numarg (setq numarg 1))</font></div><div><font class="Apple-style-span" face="Courier">    `(lambda ,(loop for i from 1 to numarg</font></div><div><font class="Apple-style-span" face="Courier">                    collect (symb 'a i))</font></div><div><font class="Apple-style-span" face="Courier">       ,(funcall</font></div><div><font class="Apple-style-span" face="Courier">         (get-macro-character #\`) stream nil)))</font></div><div><font class="Apple-style-span" face="Courier">  </font></div><div><font class="Apple-style-span" face="Courier">  (set-dispatch-macro-character</font></div><div><font class="Apple-style-span" face="Courier">   #\# #\` #'|reader-for-#`|)</font></div><div><font class="Apple-style-span" face="Courier"><br></font></div><div><font class="Apple-style-span" face="Courier"><br></font></div><div><span class="Apple-style-span" style="font-family: Courier; ">  ;; --------------------------------------------</span></div><div><font class="Apple-style-span" face="Courier">  ;; A-Bang symbols -- create anaphoric symbol names</font></div><div><font class="Apple-style-span" face="Courier">  ;; in package of macro expansion</font></div><div><font class="Apple-style-span" face="Courier"><br></font></div><div><font class="Apple-style-span" face="Courier">  (defmacro defmacro/a! (name args &amp;body body)</font></div><div><font class="Apple-style-span" face="Courier">    (let ((syms (get-bang-symbols #.(symbol-name :A!) body)))</font></div><div><font class="Apple-style-span" face="Courier">      `(defmacro ,name ,args</font></div><div><font class="Apple-style-span" face="Courier">         (let ,(mapcar #`(,a1 (intern ,(bang-symbol-name a1))) syms)</font></div><div><font class="Apple-style-span" face="Courier">           ,@body))))</font></div><div><font class="Apple-style-span" face="Courier"><br></font></div><div><font class="Apple-style-span" face="Courier">  ;; --------------------------------------------</font></div><div><font class="Apple-style-span" face="Courier">  ;; G-Bang symbols -- auto generated gensyms</font></div><div><font class="Apple-style-span" face="Courier"><br></font></div><div><font class="Apple-style-span" face="Courier">  (defmacro defmacro/g! (name args &amp;body body)</font></div><div><font class="Apple-style-span" face="Courier">    (let ((syms (get-bang-symbols #.(symbol-name :G!) body)))</font></div><div><font class="Apple-style-span" face="Courier">      `(defmacro/a! ,name ,args</font></div><div><font class="Apple-style-span" face="Courier">         (let ,(mapcar #`(,a1 (gensym ,(bang-symbol-name a1))) syms)</font></div><div><font class="Apple-style-span" face="Courier">           ,@body))))</font></div><div><font class="Apple-style-span" face="Courier"><br></font></div><div><font class="Apple-style-span" face="Courier">  </font></div><div><font class="Apple-style-span" face="Courier">  ;; --------------------------------------------</font></div><div><font class="Apple-style-span" face="Courier">  ;; O-Bang symbols -- once-only eval gensyms</font></div><div><font class="Apple-style-span" face="Courier"><br></font></div><div><font class="Apple-style-span" face="Courier">  (defun o!-symbol-to-g!-symbol (s)</font></div><div><font class="Apple-style-span" face="Courier">    (symb #.(symbol-name :G!)</font></div><div><font class="Apple-style-span" face="Courier">          (bang-symbol-name s)))</font></div><div><font class="Apple-style-span" face="Courier">    </font></div><div><font class="Apple-style-span" face="Courier">  (defmacro defmacro! (name args &amp;body body)</font></div><div><font class="Apple-style-span" face="Courier">    (let* ((os (get-bang-symbols #.(symbol-name :O!) args))</font></div><div><font class="Apple-style-span" face="Courier">           (gs (mapcar #'o!-symbol-to-g!-symbol os)))</font></div><div><font class="Apple-style-span" face="Courier">      `(defmacro/g! ,name ,args</font></div><div><font class="Apple-style-span" face="Courier">         `(let ,(mapcar #'list (list ,@gs) (list ,@os))</font></div><div><font class="Apple-style-span" face="Courier">            ,(progn</font></div><div><font class="Apple-style-span" face="Courier">               ,@body)))</font></div><div><font class="Apple-style-span" face="Courier">      ))</font></div><div><font class="Apple-style-span" face="Courier"><br></font></div><div><font class="Apple-style-span" face="Courier">  ;; ---------------------------------------</font></div><div><font class="Apple-style-span" face="Courier">  ;; This part from Doug Hoyte using Edi's ppcre</font></div><div><font class="Apple-style-span" face="Courier"><br></font></div><div><font class="Apple-style-span" face="Courier">  #+cl-ppcre</font></div><div><font class="Apple-style-span" face="Courier">  (defmacro! match-mode-ppcre-lambda-form (o!args)</font></div><div><font class="Apple-style-span" face="Courier">    ``(lambda (,',g!str)</font></div><div><font class="Apple-style-span" face="Courier">        (cl-ppcre:scan</font></div><div><font class="Apple-style-span" face="Courier">         ,(car ,g!args)</font></div><div><font class="Apple-style-span" face="Courier">         ,',g!str)))</font></div><div><font class="Apple-style-span" face="Courier"><br></font></div><div><font class="Apple-style-span" face="Courier">  #+cl-ppcre</font></div><div><font class="Apple-style-span" face="Courier">  (defmacro! subst-mode-ppcre-lambda-form (o!args)</font></div><div><font class="Apple-style-span" face="Courier">    ``(lambda (,',g!str)</font></div><div><font class="Apple-style-span" face="Courier">        (cl-ppcre:regex-replace-all</font></div><div><font class="Apple-style-span" face="Courier">         ,(car ,g!args)</font></div><div><font class="Apple-style-span" face="Courier">         ,',g!str</font></div><div><font class="Apple-style-span" face="Courier">         ,(cadr ,g!args))))</font></div><div><font class="Apple-style-span" face="Courier"><br></font></div><div><font class="Apple-style-span" face="Courier">  #+cl-ppcre</font></div><div><font class="Apple-style-span" face="Courier">  (defun |reader-for-#~| (stream sub-char numarg)</font></div><div><font class="Apple-style-span" face="Courier">    (declare (ignore sub-char numarg))</font></div><div><font class="Apple-style-span" face="Courier">    (let ((mode-char (read-char stream)))</font></div><div><font class="Apple-style-span" face="Courier">      (cond</font></div><div><font class="Apple-style-span" face="Courier">       ((char= mode-char #\m)</font></div><div><font class="Apple-style-span" face="Courier">        (match-mode-ppcre-lambda-form</font></div><div><font class="Apple-style-span" face="Courier">         (segment-reader stream</font></div><div><font class="Apple-style-span" face="Courier">                         (read-char stream)</font></div><div><font class="Apple-style-span" face="Courier">                         1)))</font></div><div><font class="Apple-style-span" face="Courier">       ((char= mode-char #\s)</font></div><div><font class="Apple-style-span" face="Courier">        (subst-mode-ppcre-lambda-form</font></div><div><font class="Apple-style-span" face="Courier">         (segment-reader stream</font></div><div><font class="Apple-style-span" face="Courier">                         (read-char stream)</font></div><div><font class="Apple-style-span" face="Courier">                         2)))</font></div><div><font class="Apple-style-span" face="Courier">       (t (error "Unknown #~~ mode character")))))</font></div><div><font class="Apple-style-span" face="Courier"><br></font></div><div><font class="Apple-style-span" face="Courier">  #+cl-ppcre</font></div><div><font class="Apple-style-span" face="Courier">  (set-dispatch-macro-character #\# #\~ #'|reader-for-#~|)</font></div><div><font class="Apple-style-span" face="Courier"><br></font></div><div><font class="Apple-style-span" face="Courier">;; --------------------------------------------------------------</font></div></div><div><div><font class="Apple-style-span" face="Courier">;; Allow extended number syntax:</font></div><div><font class="Apple-style-span" face="Courier">;;   - embedded underscore separators 123_445.789_443</font></div><div><font class="Apple-style-span" face="Courier">;;   - allow 1+2j or 1-2j or just 2j, where j in [jJiI]</font></div><div><font class="Apple-style-span" face="Courier">;;   - allow dates in yyyy/mm/dd format</font></div><div><font class="Apple-style-span" face="Courier">;;   - allow sexigisimal time in |hh:mm:ss.ss| format (bars needed because of #\:)</font></div><div><font class="Apple-style-span" face="Courier">;;   - allow hyphenated numbers as in telephone numbers, SSN's, and UUID's</font></div><div><font class="Apple-style-span" face="Courier"><br></font></div><div><span class="Apple-style-span" style="font-family: Courier; ">  (defun remove-separators (s)</span></div><div><font class="Apple-style-span" face="Courier">    (delete #\, (delete #\_ s)))</font></div><div><font class="Apple-style-span" face="Courier">  </font></div><div><font class="Apple-style-span" face="Courier">  (defun match-number (s)</font></div><div><font class="Apple-style-span" face="Courier">    (multiple-value-bind (start end)</font></div><div><font class="Apple-style-span" face="Courier">        (#~m/^[+-]?[0-9][0-9_,]*(\.[0-9_,]*([eEdD][+-]?[0-9]+)?)?/ s)</font></div><div><font class="Apple-style-span" face="Courier">      (when start</font></div><div><font class="Apple-style-span" face="Courier">        (values (read-from-string (remove-separators (subseq s start end)))</font></div><div><font class="Apple-style-span" face="Courier">                (subseq s end))</font></div><div><font class="Apple-style-span" face="Courier">        )))</font></div><div><font class="Apple-style-span" face="Courier"><br></font></div><div><font class="Apple-style-span" face="Courier">  (defun match-complex-ij (s)</font></div><div><font class="Apple-style-span" face="Courier">    (#~m/^[iIjJ]$/ s))</font></div><div><font class="Apple-style-span" face="Courier"><br></font></div><div><font class="Apple-style-span" face="Courier">  (defun convert-real-or-complex (s)</font></div><div><font class="Apple-style-span" face="Courier">    (multiple-value-bind (val srest)</font></div><div><font class="Apple-style-span" face="Courier">        (match-number s)</font></div><div><font class="Apple-style-span" face="Courier">      (when val</font></div><div><font class="Apple-style-span" face="Courier">        (cond ((= 0 (length srest)) val)</font></div><div><font class="Apple-style-span" face="Courier">              ((match-complex-ij srest) (complex 0 val))</font></div><div><font class="Apple-style-span" face="Courier">              ((multiple-value-bind (ival sresti)</font></div><div><font class="Apple-style-span" face="Courier">                   (match-number srest)</font></div><div><font class="Apple-style-span" face="Courier">                 (and ival</font></div><div><font class="Apple-style-span" face="Courier">                      (match-complex-ij sresti)</font></div><div><font class="Apple-style-span" face="Courier">                      (complex val ival))))</font></div><div><font class="Apple-style-span" face="Courier">              (t nil)))</font></div><div><font class="Apple-style-span" face="Courier">      ))</font></div><div><font class="Apple-style-span" face="Courier"><br></font></div><div><font class="Apple-style-span" face="Courier">  (defun convert-sexigisimal (s)</font></div><div><font class="Apple-style-span" face="Courier">    ;; hh:mm:ss.ss, or hh:mm</font></div><div><font class="Apple-style-span" face="Courier">    (multiple-value-bind (start end gstart gend)</font></div><div><font class="Apple-style-span" face="Courier">        (#~m/^([+-])?([0-9]+):([0-9][0-9]?)(:[0-9][0-9]?(\.[0-9_,]*)?)?$/ s)</font></div><div><font class="Apple-style-span" face="Courier">      (declare (ignore end))</font></div><div><font class="Apple-style-span" face="Courier">      (when start</font></div><div><font class="Apple-style-span" face="Courier">        (symbol-macrolet</font></div><div><font class="Apple-style-span" face="Courier">            ((sign   (aref gstart 0))</font></div><div><font class="Apple-style-span" face="Courier">             (hstart (aref gstart 1))</font></div><div><font class="Apple-style-span" face="Courier">             (hend   (aref gend   1))</font></div><div><font class="Apple-style-span" face="Courier">             (mstart (aref gstart 2))</font></div><div><font class="Apple-style-span" face="Courier">             (mend   (aref gend   2))</font></div><div><font class="Apple-style-span" face="Courier">             (sstart (aref gstart 3))</font></div><div><font class="Apple-style-span" face="Courier">             (send   (aref gend   3))</font></div><div><font class="Apple-style-span" face="Courier">             (sfrac  (aref gstart 4)))</font></div><div><font class="Apple-style-span" face="Courier">          (ignore-errors</font></div><div><font class="Apple-style-span" face="Courier">            (let* ((hh (read-from-string (subseq s hstart hend)))</font></div><div><font class="Apple-style-span" face="Courier">                   (mm (read-from-string (subseq s mstart mend)))</font></div><div><font class="Apple-style-span" face="Courier">                   (ss (if sstart</font></div><div><font class="Apple-style-span" face="Courier">                           (read-from-string (remove-separators</font></div><div><font class="Apple-style-span" face="Courier">                                              (subseq s (1+ sstart) send)))</font></div><div><font class="Apple-style-span" face="Courier">                         0))</font></div><div><font class="Apple-style-span" face="Courier">                   (val  (+ (* 60 (+ (* 60 hh) mm))</font></div><div><font class="Apple-style-span" face="Courier">                            (if sfrac</font></div><div><font class="Apple-style-span" face="Courier">                                (float ss 1d0)</font></div><div><font class="Apple-style-span" face="Courier">                              ss))))</font></div><div><font class="Apple-style-span" face="Courier">              (if (and sign</font></div><div><font class="Apple-style-span" face="Courier">                       (char= (char s sign) #\-))</font></div><div><font class="Apple-style-span" face="Courier">                  (- val)</font></div><div><font class="Apple-style-span" face="Courier">                val)</font></div><div><font class="Apple-style-span" face="Courier">              ))))))</font></div><div><font class="Apple-style-span" face="Courier">  </font></div><div><font class="Apple-style-span" face="Courier">  (defun convert-date (s)</font></div><div><font class="Apple-style-span" face="Courier">    ;; yyyy/mm/dd</font></div><div><font class="Apple-style-span" face="Courier">    (multiple-value-bind (start end gstart gend)</font></div><div><font class="Apple-style-span" face="Courier">        (#~m%^([0-9][0-9][0-9][0-9])/([0-9][0-9]?)/([0-9][0-9]?)$% s)</font></div><div><font class="Apple-style-span" face="Courier">      (declare (ignore end))</font></div><div><font class="Apple-style-span" face="Courier">      (when start</font></div><div><font class="Apple-style-span" face="Courier">        (symbol-macrolet</font></div><div><font class="Apple-style-span" face="Courier">            ((ystart (aref gstart 0))</font></div><div><font class="Apple-style-span" face="Courier">             (yend   (aref gend   0))</font></div><div><font class="Apple-style-span" face="Courier">             (mstart (aref gstart 1))</font></div><div><font class="Apple-style-span" face="Courier">             (mend   (aref gend   1))</font></div><div><font class="Apple-style-span" face="Courier">             (dstart (aref gstart 2))</font></div><div><font class="Apple-style-span" face="Courier">             (dend   (aref gend   2)))</font></div><div><font class="Apple-style-span" face="Courier">          (ignore-errors</font></div><div><font class="Apple-style-span" face="Courier">            (let* ((yyyy (read-from-string (subseq s ystart yend)))</font></div><div><font class="Apple-style-span" face="Courier">                   (mm   (read-from-string (subseq s mstart mend)))</font></div><div><font class="Apple-style-span" face="Courier">                   (dd   (read-from-string (subseq s dstart dend))))</font></div><div><font class="Apple-style-span" face="Courier">              (encode-universal-time 0 0 0 dd mm yyyy)</font></div><div><font class="Apple-style-span" face="Courier">              ))))))</font></div><div><font class="Apple-style-span" face="Courier">  </font></div><div><font class="Apple-style-span" face="Courier">  (defun convert-american-short-date (s)</font></div><div><font class="Apple-style-span" face="Courier">    ;; mm/dd/yy </font></div><div><font class="Apple-style-span" face="Courier">    (multiple-value-bind (start end gstart gend)</font></div><div><font class="Apple-style-span" face="Courier">        (#~m%^([0-9][0-9]?)/([0-9][0-9]?)/([0-9][0-9]?)$% s)</font></div><div><font class="Apple-style-span" face="Courier">      (declare (ignore end))</font></div><div><font class="Apple-style-span" face="Courier">      (when start</font></div><div><font class="Apple-style-span" face="Courier">        (symbol-macrolet</font></div><div><font class="Apple-style-span" face="Courier">            ((ystart (aref gstart 2))</font></div><div><font class="Apple-style-span" face="Courier">             (yend   (aref gend   2))</font></div><div><font class="Apple-style-span" face="Courier">             (mstart (aref gstart 0))</font></div><div><font class="Apple-style-span" face="Courier">             (mend   (aref gend   0))</font></div><div><font class="Apple-style-span" face="Courier">             (dstart (aref gstart 1))</font></div><div><font class="Apple-style-span" face="Courier">             (dend   (aref gend   1)))</font></div><div><font class="Apple-style-span" face="Courier">          (ignore-errors</font></div><div><font class="Apple-style-span" face="Courier">            (let* ((yyyy (read-from-string (subseq s ystart yend)))</font></div><div><font class="Apple-style-span" face="Courier">                   (mm   (read-from-string (subseq s mstart mend)))</font></div><div><font class="Apple-style-span" face="Courier">                   (dd   (read-from-string (subseq s dstart dend))))</font></div><div><font class="Apple-style-span" face="Courier">              (encode-universal-time 0 0 0 dd mm yyyy)</font></div><div><font class="Apple-style-span" face="Courier">              ))))))</font></div><div><font class="Apple-style-span" face="Courier"><br></font></div><div><font class="Apple-style-span" face="Courier">  (defun convert-hyphenated-number (s)</font></div><div><font class="Apple-style-span" face="Courier">    ;; xxxx-xx-xxxx  as in telephone numbers, SSN's, and UUID's</font></div><div><font class="Apple-style-span" face="Courier">    (if (#~m/^[0-9]+(\-[0-9]+)*$/ s)</font></div><div><font class="Apple-style-span" face="Courier">        (read-from-string (delete #\- s))))</font></div><div><font class="Apple-style-span" face="Courier">    </font></div><div><font class="Apple-style-span" face="Courier">  (defun convert-other-base-number (s)</font></div><div><font class="Apple-style-span" face="Courier">    ;; #xNNNN_NNNN_NNN</font></div><div><font class="Apple-style-span" face="Courier">    (when (or (#~m/^[xXoObB]/ s)</font></div><div><font class="Apple-style-span" face="Courier">              (#~m/^[0-9]+[rR]/ s))</font></div><div><font class="Apple-style-span" face="Courier">      (ignore-errors</font></div><div><font class="Apple-style-span" face="Courier">        (read-from-string (format nil "#~A" (remove-separators s))))))</font></div><div><font class="Apple-style-span" face="Courier">    </font></div><div><font class="Apple-style-span" face="Courier">  (defun |reader-for-#n| (stream sub-char numarg)</font></div><div><font class="Apple-style-span" face="Courier">    (declare (ignore sub-char numarg))</font></div><div><font class="Apple-style-span" face="Courier">    (let ((v (read stream t nil t)))</font></div><div><font class="Apple-style-span" face="Courier">      (if (symbolp v)</font></div><div><font class="Apple-style-span" face="Courier">          (let ((s (symbol-name v)))</font></div><div><font class="Apple-style-span" face="Courier">            (cond ((convert-real-or-complex s))</font></div><div><font class="Apple-style-span" face="Courier">                  ((convert-sexigisimal s))</font></div><div><font class="Apple-style-span" face="Courier">                  ((convert-date s))</font></div><div><font class="Apple-style-span" face="Courier">                  ((convert-american-short-date s))</font></div><div><font class="Apple-style-span" face="Courier">                  ((convert-hyphenated-number s))</font></div><div><font class="Apple-style-span" face="Courier">                  ((convert-other-base-number s))</font></div><div><font class="Apple-style-span" face="Courier">                  (t v)))</font></div><div><font class="Apple-style-span" face="Courier">        ;; else -- not a symbol (!?)</font></div><div><font class="Apple-style-span" face="Courier">        v)))</font></div><div><font class="Apple-style-span" face="Courier"><br></font></div><div><font class="Apple-style-span" face="Courier">  (set-dispatch-macro-character</font></div><div><font class="Apple-style-span" face="Courier">   #\# #\n #'|reader-for-#n|) ) ;; end of eval-when</font></div><div><font class="Apple-style-span" face="Courier"><br></font></div><div><font class="Apple-style-span" face="Courier">;; --------------------------------------</font></div><div><br></div><div> <span class="Apple-style-span" style="border-collapse: separate; color: rgb(0, 0, 0); font-family: Helvetica; font-size: 12px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-align: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-border-horizontal-spacing: 0px; -webkit-border-vertical-spacing: 0px; -webkit-text-decorations-in-effect: none; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0; "><span class="Apple-style-span" style="border-collapse: separate; -webkit-border-horizontal-spacing: 0px; -webkit-border-vertical-spacing: 0px; color: rgb(0, 0, 0); font-family: Helvetica; font-size: 12px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; -webkit-text-decorations-in-effect: none; text-indent: 0px; -webkit-text-size-adjust: auto; text-transform: none; orphans: 2; white-space: normal; widows: 2; word-spacing: 0px; "><span class="Apple-style-span" style="border-collapse: separate; -webkit-border-horizontal-spacing: 0px; -webkit-border-vertical-spacing: 0px; color: rgb(0, 0, 0); font-family: Helvetica; font-size: 12px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; -webkit-text-decorations-in-effect: none; text-indent: 0px; -webkit-text-size-adjust: auto; text-transform: none; orphans: 2; white-space: normal; widows: 2; word-spacing: 0px; "><span class="Apple-style-span" style="border-collapse: separate; -webkit-border-horizontal-spacing: 0px; -webkit-border-vertical-spacing: 0px; color: rgb(0, 0, 0); font-family: Helvetica; font-size: 12px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; -webkit-text-decorations-in-effect: none; text-indent: 0px; -webkit-text-size-adjust: auto; text-transform: none; orphans: 2; white-space: normal; widows: 2; word-spacing: 0px; "><span class="Apple-style-span" style="border-collapse: separate; -webkit-border-horizontal-spacing: 0px; -webkit-border-vertical-spacing: 0px; color: rgb(0, 0, 0); font-family: Helvetica; font-size: 12px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; -webkit-text-decorations-in-effect: none; text-indent: 0px; -webkit-text-size-adjust: auto; text-transform: none; orphans: 2; white-space: normal; widows: 2; word-spacing: 0px; "><span class="Apple-style-span" style="border-collapse: separate; -webkit-border-horizontal-spacing: 0px; -webkit-border-vertical-spacing: 0px; color: rgb(0, 0, 0); font-family: Helvetica; font-size: 12px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; -webkit-text-decorations-in-effect: none; text-indent: 0px; -webkit-text-size-adjust: auto; text-transform: none; orphans: 2; white-space: normal; widows: 2; word-spacing: 0px; "><div style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">Dr. David McClain</div><div style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">Chief Technical Officer</div><div style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">Refined Audiometrics Laboratory</div><div style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">4391 N. Camino Ferreo</div><div style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">Tucson, AZ  85750</div><div style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font: normal normal normal 12px/normal Helvetica; min-height: 14px; "><br></div><div style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">email: <a href="mailto:dbm@refined-audiometrics.com">dbm@refined-audiometrics.com</a></div><div style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">phone: 1.520.390.3995</div><div style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; ">web: <a href="http://www.refined-audiometrics.com">http://www.refined-audiometrics.com</a></div><br class="Apple-interchange-newline"></span><span></span></span></span></span></span></span><br class="Apple-interchange-newline"> </div><br></div></body></html>

               </article>
               <section class=tree>
                <article class=email>
                 <h1>Re: Extended Format Numeric Input</h1>
                 <pre>

On Mar 19, 2009, at 3:07 PM, David McClain wrote:

&gt The code that follows is all contained in an eval-when clause  
&gt because so many of the defuns and macros are needed by the compiler  
&gt along the way.

even with the eval when, both LWM 5.1.2 and openmcl/ccl choke when  
reading (mapcar #`...
this bit can be fixed by having the eval-when scope end after:

(set-dispatch-macro-character
    #\# #\` #'|reader-for-#`|)

However, once this if fixed, you call a curry function which isn't  
defined in the source you posted (there may be others, I haven't read  
over everything and this was the first error after fixing the eval- 
when scope)

regards,

Ralph



Raffael Cavallaro, Ph.D.
raffaelcavallaro@mac.com


</pre>
                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: Extended Format Numeric Input</h1>
                 <pre>
Hello David,

| ... One of the things I miss most about my ancient Forth systems was
| its ability to directly enter sexagisimal numbers for angles and time:
| e.g., -110:32:56.47 and 23:59:56
|
| So, Doug Hoyte's new book "Let Over Lambda" inspired me to do something
| about this lacking in Lisp... Mucho gracias to Doug for the
| inspiration, and Edi Weitz for PPCRE!!

Another "old dogs'" solution is:

"Pragmatic Parsing in Common Lisp" of Henry G. Baker.
 http://citeseer.ist.psu.edu/baker91pragmatic.html or inside http://portal.acm.org/

For adapted code, see meta-parse.lisp and meta-parse-number.lisp in the
Ystok-Library distribution at   http://lisp.ystok.ru/projects.html#ylib

The Ystok-Local-Time library also exploit this approach for parsing ISO8601
and local format of date/time and intervals. The code is not publicly
available yet but if somebody were interested...
--
Sincerely,
Dmitriy Ivanov
lisp.ystok.ru


</pre>
                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: Extended Format Numeric Input</h1>
                 <pre>

On Mar 20, 2009, at 4:27 PM, David McClain wrote:

&gt The very first Forth systems I used and learned from back in the  
&gt '70s had a mean time between re-boots of around 10 minutes... Ha ha  
&gt ha!

Ah, good times, good times...
;^)

Raffael Cavallaro, Ph.D.
raffaelcavallaro@mac.com


</pre>
                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: Extended Format Numeric Input</h1>
                 <pre>
"Dmitriy Ivanov" &lt;divanov@aha.ru&gt writes:
&gt | ... One of the things I miss most about my ancient Forth systems was
&gt | its ability to directly enter sexagisimal numbers for angles and time:
&gt | e.g., -110:32:56.47 and 23:59:56
&gt |
&gt | So, Doug Hoyte's new book "Let Over Lambda" inspired me to do something
&gt | about this lacking in Lisp... Mucho gracias to Doug for the
&gt | inspiration, and Edi Weitz for PPCRE!!
&gt
&gt Another "old dogs'" solution is:
&gt
&gt "Pragmatic Parsing in Common Lisp" of Henry G. Baker.
&gt  http://citeseer.ist.psu.edu/baker91pragmatic.html or inside
&gt  http://portal.acm.org/

That's a good vintage read, and makes the hype around parser
combinators sound like rather old hat.

FWIW I seem to have redone some of the ideas in cl-irregsexp, guess I
should try to rethink them to learn from this library.

(And for the shameless self-promotion --
http://common-lisp.net/project/cl-irregsexp/)

---
http://cl-www.msi.co.jp/projects/


</pre>
                </article>
               </section>
              </section>
             </div>
            </div>
            <footer class="d-flex justify-content-center">
             <div>
              Updated at: 2020-12-10 08:41 UTC
             </div>
            </footer>
           </body>
          </html>