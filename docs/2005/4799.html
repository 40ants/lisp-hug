<!DOCTYPE html>
<html lang=en>
           <head>
            <meta charset=UTF-8>
            <title>(apply #'concatenate 'string</title>
            <meta name=viewport
                  content="width=device-width, initial-scale=1.0">
            <link rel=stylesheet
                  href=https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css
                  integrity=sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2
                  crossorigin=anonymous>
            <style>
section.tree {
    padding-left: 2em;
}
section.tree:first-child {
    padding-left: 0;
}
.article-link {
  margin-bottom: 1em;
}
</style>
<!-- Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-9X3G9MMWZP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-9X3G9MMWZP');
</script>

           </head>
           <body>
            <header class="d-flex justify-content-center">
             <nav
                  class="navbar navbar-light bg-light w-100 mx-5 mb-3">
              <a class=navbar-brand href="/">Lisp HUG Maillist Archive</a>
             </nav>
            </header>
            <div class="d-flex justify-content-center">
             <div class="w-100 mx-5 px-3">
              <section class=tree>
               <article class=email>
                <h1>(apply #'concatenate 'string</h1><HTML><BODY style="word-wrap: break-word; -khtml-nbsp-mode: space; -khtml-line-break: after-white-space; "><DIV style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><FONT class="Apple-style-span" face="Monaco" size="1"><SPAN class="Apple-style-span" style="font-size: 9px;">What is the maximum length of a list of strings (s) that Lispworks</SPAN></FONT></DIV><DIV style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><FONT class="Apple-style-span" face="Monaco" size="1"><SPAN class="Apple-style-span" style="font-size: 9px;">(Windows) can</SPAN></FONT><FONT class="Apple-style-span" face="Monaco" size="1"><SPAN class="Apple-style-span" style="font-size: 9px;"> </SPAN></FONT></DIV><DIV style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><FONT class="Apple-style-span" face="Monaco" size="1"><SPAN class="Apple-style-span" style="font-size: 9px;">(apply #'concatenate 'string s) ?</SPAN></FONT></DIV><DIV style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font: normal normal normal 9px/normal Monaco; min-height: 12px; "><BR></DIV><DIV style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><FONT class="Apple-style-span" face="Monaco" size="1"><SPAN class="Apple-style-span" style="font-size: 9px;">I ask so that I can avoid a "stack overflow" or "out of memory" errors</SPAN></FONT></DIV><DIV style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><FONT class="Apple-style-span" face="Monaco" size="1"><SPAN class="Apple-style-span" style="font-size: 9px;">with concatenation of long lists of strings, from</SPAN></FONT><FONT class="Apple-style-span" face="Monaco" size="1"><SPAN class="Apple-style-span" style="font-size: 9px;"> </SPAN></FONT></DIV><DIV style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><FONT class="Apple-style-span" face="Monaco" size="1"><SPAN class="Apple-style-span" style="font-size: 9px;">(mapcar #'string [list of chars])</SPAN></FONT></DIV><DIV style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><FONT class="Apple-style-span" face="Monaco" size="1"><SPAN class="Apple-style-span" style="font-size: 9px;">obtained when reading text files.</SPAN></FONT></DIV><DIV style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font: normal normal normal 9px/normal Monaco; min-height: 12px; "><BR></DIV><DIV style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><FONT class="Apple-style-span" face="Monaco" size="1"><SPAN class="Apple-style-span" style="font-size: 9px;">In other words how can I write an efficient</SPAN></FONT></DIV><DIV style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font: normal normal normal 9px/normal Monaco; min-height: 12px; "><BR></DIV><DIV style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><FONT class="Apple-style-span" face="Monaco" size="1"><SPAN class="Apple-style-span" style="font-size: 9px;">(defun apply-concatenate-to-long-string (s)</SPAN></FONT></DIV><DIV style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><FONT class="Apple-style-span" face="Monaco" size="1"><SPAN class="Apple-style-span" style="font-size: 9px;">  </SPAN></FONT><FONT class="Apple-style-span" face="Monaco" size="1"><SPAN class="Apple-style-span" style="font-size: 9px;">(let ((maxlength #+MCL ? #+Lispworks ?))</SPAN></FONT></DIV><DIV style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><FONT class="Apple-style-span" face="Monaco" size="1"><SPAN class="Apple-style-span" style="font-size: 9px;">    </SPAN></FONT><FONT class="Apple-style-span" face="Monaco" size="1"><SPAN class="Apple-style-span" style="font-size: 9px;">(if (&lt; (length s) maxlength)</SPAN></FONT></DIV><DIV style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><FONT class="Apple-style-span" face="Monaco" size="1"><SPAN class="Apple-style-span" style="font-size: 9px;">      </SPAN></FONT><FONT class="Apple-style-span" face="Monaco" size="1"><SPAN class="Apple-style-span" style="font-size: 9px;">(apply #'concatenate 'string s)</SPAN></FONT></DIV><DIV style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><FONT class="Apple-style-span" face="Monaco" size="1"><SPAN class="Apple-style-span" style="font-size: 9px;">      </SPAN></FONT><FONT class="Apple-style-span" face="Monaco" size="1"><SPAN class="Apple-style-span" style="font-size: 9px;">(do ((s s (rest s))</SPAN></FONT></DIV><DIV style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><FONT class="Apple-style-span" face="Monaco" size="1"><SPAN class="Apple-style-span" style="font-size: 9px;">           </SPAN></FONT><FONT class="Apple-style-span" face="Monaco" size="1"><SPAN class="Apple-style-span" style="font-size: 9px;">(r ""))</SPAN></FONT></DIV><DIV style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><FONT class="Apple-style-span" face="Monaco" size="1"><SPAN class="Apple-style-span" style="font-size: 9px;">          </SPAN></FONT><FONT class="Apple-style-span" face="Monaco" size="1"><SPAN class="Apple-style-span" style="font-size: 9px;">((endp s) r)</SPAN></FONT></DIV><DIV style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><FONT class="Apple-style-span" face="Monaco" size="1"><SPAN class="Apple-style-span" style="font-size: 9px;">        </SPAN></FONT><FONT class="Apple-style-span" face="Monaco" size="1"><SPAN class="Apple-style-span" style="font-size: 9px;">(setf r (concatenate 'string r (first s))))</SPAN></FONT></DIV><DIV style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><FONT class="Apple-style-span" face="Monaco" size="1"><SPAN class="Apple-style-span" style="font-size: 9px;">      </SPAN></FONT><FONT class="Apple-style-span" face="Monaco" size="1"><SPAN class="Apple-style-span" style="font-size: 9px;">)))</SPAN></FONT></DIV><DIV style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font: normal normal normal 9px/normal Monaco; min-height: 12px; "><BR></DIV><DIV style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><FONT class="Apple-style-span" face="Monaco" size="1"><SPAN class="Apple-style-span" style="font-size: 9px;">?</SPAN></FONT></DIV><DIV style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; font: normal normal normal 9px/normal Monaco; min-height: 12px; "><BR></DIV><DIV style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><FONT class="Apple-style-span" face="Monaco" size="1"><SPAN class="Apple-style-span" style="font-size: 9px;">Thanks,</SPAN></FONT></DIV><DIV style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; "><FONT class="Apple-style-span" face="Monaco" size="1"><SPAN class="Apple-style-span" style="font-size: 9px;">Sheldon</SPAN></FONT></DIV></BODY></HTML>

               </article>
               <section class=tree>
                <article class=email>
                 <h1>Re: (apply #'concatenate 'string</h1>
                 <pre>On 9291 day of my life Sheldon Ball wrote:
&gt What is the maximum length of a list of strings (s) that Lispworks
&gt (Windows) can
&gt (apply #'concatenate 'string s) ?

There is constant CALL-ARGUMENTS-LIMIT

-- 
Ivan Boldyrev

                                      Life!  Don't talk to me about life.


</pre>
                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: (apply #'concatenate 'string</h1>
                 <pre>On Sat, 12 Nov 2005 05:31:50 +0100, Sheldon Ball &lt;s.ball@anvita.info&gt  
wrote:

&gt What is the maximum length of a list of strings (s) that Lispworks
&gt (Windows) can
&gt (apply #'concatenate 'string s) ?
&gt
&gt I ask so that I can avoid a "stack overflow" or "out of memory" errors
&gt with concatenation of long lists of strings, from
&gt (mapcar #'string [list of chars])
&gt obtained when reading text files.
&gt
&gt In other words how can I write an efficient
&gt
&gt (defun apply-concatenate-to-long-string (s)
&gt    (let ((maxlength #+MCL ? #+Lispworks ?))
&gt      (if (&lt; (length s) maxlength)
&gt        (apply #'concatenate 'string s)
&gt        (do ((s s (rest s))
&gt             (r ""))
&gt            ((endp s) r)
&gt          (setf r (concatenate 'string r (first s))))
&gt        )))
&gt
&gt ?
&gt
&gt Thanks,
&gt Sheldon

There is a maximum of I think 255 arguments to a function.
If you exceed this limit the problem is probaly that you
are using Lisp wrong.
Seems your means of reading text files is the real cuprit here.
Why do you read a file character by character and then convert it
to a list of characters and then concatenate?
This is EXTREMLY inefficient.
If you want to read it character by character.. fine
I suppose you have a reason.
But there are much better ways of converting it to a string.
How about something along the following lines:

(defun read-a-file-char-by-char (pathname)
   (check-type pathname pathname)
   (let ((char-array (make-array 100 :element-type 'character :adustable t  
:fill-pointer 0)))
     (with-open-file (stream pathname)
       (do ((char (read-line stream) (read-line stream nil 'eof)))
           ((not (characterp char)))
         (vector-push-extend char char-array)))
     (coerce char-array 'string)))

-- 
Using Opera's revolutionary e-mail client: http://www.opera.com/mail/


</pre>
                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: (apply #'concatenate 'string</h1>
                 <pre>On Sat, 12 Nov 2005 10:33:22 +0100, "John Thingstad" &lt;john.thingstad@chello.no&gt wrote:

&gt There is a maximum of I think 255 arguments to a function.

There's no reason to guess, this is governed by the standard:

  &lt;http://www.lispworks.com/documentation/HyperSpec/Body/v_call_a.htm&gt

And note that this could as well change in upcoming releases so you
better don't hardcode something like 255 in your apps.


</pre>
                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: (apply #'concatenate 'string</h1>
                 <pre>On Fri, 11 Nov 2005 20:31:50 -0800, Sheldon Ball &lt;s.ball@anvita.info&gt wrote:

&gt In other words how can I write an efficient
&gt
&gt (defun apply-concatenate-to-long-string (s)

Here are two other ways of doing it (untested):

  (format nil "~{~A~}" string-list)

  (defun string-list-to-string (string-list)
    (let ((total-size 0))
      (dolist (string string-list)
        (incf total-size (length string)))
      (let ((result-string (make-sequence 'simple-string total-size))
            (curr-pos 0))
        (dolist (string string-list)
          (replace result-string string :start1 curr-pos)
          (incf curr-pos (length string)))
        result-string)))

See also WITH-OUTPUT-TO-STRING in the CLHS.

Cheers,
Edi.


</pre>
                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: (apply #'concatenate 'string</h1>
                 <pre>On Sat, 12 Nov 2005 12:07:33 +0100, "Arthur Lemmens" &lt;alemmens@xs4all.nl&gt wrote:

&gt Instead of:
&gt
&gt&gt     (let ((total-size 0))
&gt&gt       (dolist (string string-list)
&gt&gt         (incf total-size (length string)))
&gt
&gt I used:
&gt
&gt     (let ((total-size (reduce #'+ string-list :key #'length)))

Yep, that's better because it's more terse.

&gt and instead of:
&gt
&gt&gt       (let ((result-string (make-sequence 'simple-string total-size))
&gt
&gt I used:
&gt
&gt     (let ((result-string (make-string total-size)))

Yeah, I copied my example (slightly modified) from a function JP
Massar submitted for CL-PPCRE - the SIMPLE-STRING part is an artefact
of that and it shouldn't be there.

Cheers,
Edi.


</pre>
                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: (apply #'concatenate 'string</h1>
                 <pre>On 9291 day of my life Sheldon Ball wrote:
&gt I ask so that I can avoid a "stack overflow" or "out of memory" errors
&gt with concatenation of long lists of strings, from
&gt (mapcar #'string [list of chars])
&gt obtained when reading text files.

If you want to get string from list of chars, just use COERCE:

(coerce (list #\a #\b #\c) 'string)
 =&gt "abc"

If you want to concatenate lot of string of list, you may use FORMAT

(format nil "~{~A~}"   (list "1" "23" "456"))
 =&gt "123456"

But its effectiveness is implementation-dependent.

-- 
Ivan Boldyrev

                                                  Is 'morning' a gerund?


</pre>
                </article>
               </section>
              </section>
             </div>
            </div>
            <footer class="d-flex justify-content-center">
             <div>
              Updated at: 2020-12-10 08:50 UTC
             </div>
            </footer>
           </body>
          </html>