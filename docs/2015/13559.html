<!DOCTYPE html>
<html lang=en>
           <head>
            <meta charset=UTF-8>
            <title>Secret Sharing</title>
            <link rel=stylesheet
                  href=https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css
                  integrity=sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2
                  crossorigin=anonymous>
            <style>
section.tree {
    padding-left: 2em;
}
section.tree:first-child {
    padding-left: 0;
}
.article-link {
  margin-bottom: 1em;
}
</style>
<!-- Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-9X3G9MMWZP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-9X3G9MMWZP');
</script>

           </head>
           <body>
            <header class="d-flex justify-content-center">
             <nav
                  class="navbar navbar-light bg-light w-100 mx-5 mb-3">
              <a class=navbar-brand href="/">Lisp HUG Maillist Archive</a>
             </nav>
            </header>
            <div class="d-flex justify-content-center">
             <div class="w-100 mx-5 px-3">
              <section class=tree>
               <article class=email>
                <h1>Secret Sharing</h1><html><head><meta http-equiv="Content-Type" content="text/html charset=utf-8"></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">Here’s another snippet of code that I use from time to time. The idea is (N,M)-way Secret Sharing, where there are N fragments of a secret key, and it takes (M &lt;= N) of them to come together before it can be reconstructed. I do this by computing an (M-1)’th order random polynomial over the field used by the underlying crypto, which goes through my secret Y value at the origin X = 0, and pass out N randomly chosen points along that polynomial curve to friendly parties.<div class=""><br class=""></div><div class="">Nothing can be obtained about the secret, nominally the ordinate value at the origin of coordinates, until at least M of these ordinates come together. Lagrange interpolation over the field is used to recompute the ordinal value at the chosen secret key location (nominally defaults to the origin, but you can choose anywhere for yourself).<div class=""><br class=""></div><div class=""><div class=""><font face="Courier" class="">(defun ecc-make-lagrange-interpolator (shares)</font></div><div class=""><font face="Courier" class="">&nbsp; (labels ((lprod (x xs)</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(reduce (lambda (prod x2)</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(mult-mod *ecc-r* prod (sub-mod *ecc-r* x2 x)))</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xs</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:initial-value 1)))</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; (lambda (x0)</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; (labels ((term (sum share)</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(um:bind* ((:struct-accessors crypto-share (x y) share)</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (xs (mapcar 'crypto-share-x (remove share shares))))</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(ecc-add sum</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (ecc-mul y (div-mod *ecc-r*</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lprod x0 xs)</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lprod x xs)) )) )))</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; (reduce #'term shares</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; :initial-value (ecc-infinity) )))))</font></div><div class=""><font face="Courier" class=""><br class=""></font></div><div class=""><font face="Courier" class="">(defun ecc-solve-lagrange (shares &amp;optional (x 0))</font></div><div class=""><font face="Courier" class="">&nbsp; (let ((fn (ecc-make-lagrange-interpolator shares)))</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; (funcall fn x)))</font></div><div class=""><br class=""></div></div><div class="">It is so easy and clean to do in Lisp. The underlying arithmetic, shown here as Elliptic Curve arithmetic. But you can easily recode this to work over a Galois field, as shown here:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Courier" class="">(defstruct crypto-share</font></div><div class=""><font face="Courier" class="">&nbsp; x y)</font></div><div class=""><font face="Courier" class=""><br class=""></font></div><div class=""><font face="Courier" class="">(defun make-gf-lagrange-interpolator (shares)</font></div><div class=""><font face="Courier" class="">&nbsp; (labels ((lprod (x xs)</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(reduce (lambda (prod x2)</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(gf* prod (gf+ x2 x)))</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xs</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:initial-value 1)))</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; (lambda (x0)</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; (labels ((term (sum share)</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(with-accessors ((x crypto-share-x)</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (y crypto-share-y)) share</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(let ((xs (mapcar #'crypto-share-x (remove share shares))))</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(gf+ sum</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (gf* y (gf/ (lprod x0 xs)</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lprod x xs)) )) ))) )</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; (reduce #'term shares</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; :initial-value 0))) ))</font></div><div class=""><font face="Courier" class=""><br class=""></font></div><div class=""><font face="Courier" class="">(defun solve-gf-lagrange (x0 &amp;rest shares)</font></div><div class=""><font face="Courier" class="">&nbsp; (let ((fn (make-gf-lagrange-interpolator shares)))</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; (funcall fn x0)))</font></div><div class=""><br class=""></div></div><div class=""><br class=""></div><div class="">In general, whatever field you choose to work over, you can take the same basic Lagrange interpolation skeletal structure shown here to compute a secret-sharing. You see the strong similarity between the Galois field version and the Elliptic Curve version. For Elliptic Curves, you need either a curve point (x,y) (different field than the interpolation polynomial), or else just use the X or the Y value of the ECC point, or an encoding of the point like an Elligator-2 value. Doesn’t really matter how you do it.</div><div class=""><br class=""></div><div class="">To be clear, a share is an (X, Y) pair on a 2-D manifold over some finite field. Knowing M of these points specifies exactly the (M-1)’th order polynomial that interpolates through those points. And your secret is the ordinate value at some special abscissa value along that interpolating polynomial.</div></div><div class=""><br class=""></div><div class="">No my idea at all. This goes back to Rivest as well. Very bright guy! Lisp makes it so easy to do.</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div></body></html>

               </article>
               <section class=tree>
                <article class=email>
                 <h1>Re: Secret Sharing</h1><html><head><meta http-equiv="Content-Type" content="text/html charset=utf-8"></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">er… sorry, not Rivest, this one comes from Adi Shamir!<div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div><div class=""><br class=""><div><blockquote type="cite" class=""><div class="">On Aug 8, 2015, at 11:40 AM, David McClain &lt;<a href="mailto:DBM@REFINED-AUDIOMETRICS.COM" class="">DBM@REFINED-AUDIOMETRICS.COM</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">Here’s another snippet of code that I use from time to time. The idea is (N,M)-way Secret Sharing, where there are N fragments of a secret key, and it takes (M &lt;= N) of them to come together before it can be reconstructed. I do this by computing an (M-1)’th order random polynomial over the field used by the underlying crypto, which goes through my secret Y value at the origin X = 0, and pass out N randomly chosen points along that polynomial curve to friendly parties.<div class=""><br class=""></div><div class="">Nothing can be obtained about the secret, nominally the ordinate value at the origin of coordinates, until at least M of these ordinates come together. Lagrange interpolation over the field is used to recompute the ordinal value at the chosen secret key location (nominally defaults to the origin, but you can choose anywhere for yourself).<div class=""><br class=""></div><div class=""><div class=""><font face="Courier" class="">(defun ecc-make-lagrange-interpolator (shares)</font></div><div class=""><font face="Courier" class="">&nbsp; (labels ((lprod (x xs)</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(reduce (lambda (prod x2)</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(mult-mod *ecc-r* prod (sub-mod *ecc-r* x2 x)))</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xs</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:initial-value 1)))</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; (lambda (x0)</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; (labels ((term (sum share)</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(um:bind* ((:struct-accessors crypto-share (x y) share)</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (xs (mapcar 'crypto-share-x (remove share shares))))</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(ecc-add sum</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (ecc-mul y (div-mod *ecc-r*</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lprod x0 xs)</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lprod x xs)) )) )))</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; (reduce #'term shares</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; :initial-value (ecc-infinity) )))))</font></div><div class=""><font face="Courier" class=""><br class=""></font></div><div class=""><font face="Courier" class="">(defun ecc-solve-lagrange (shares &amp;optional (x 0))</font></div><div class=""><font face="Courier" class="">&nbsp; (let ((fn (ecc-make-lagrange-interpolator shares)))</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; (funcall fn x)))</font></div><div class=""><br class=""></div></div><div class="">It is so easy and clean to do in Lisp. The underlying arithmetic, shown here as Elliptic Curve arithmetic. But you can easily recode this to work over a Galois field, as shown here:</div><div class=""><br class=""></div><div class=""><div class=""><font face="Courier" class="">(defstruct crypto-share</font></div><div class=""><font face="Courier" class="">&nbsp; x y)</font></div><div class=""><font face="Courier" class=""><br class=""></font></div><div class=""><font face="Courier" class="">(defun make-gf-lagrange-interpolator (shares)</font></div><div class=""><font face="Courier" class="">&nbsp; (labels ((lprod (x xs)</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(reduce (lambda (prod x2)</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(gf* prod (gf+ x2 x)))</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xs</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;:initial-value 1)))</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; (lambda (x0)</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; (labels ((term (sum share)</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(with-accessors ((x crypto-share-x)</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (y crypto-share-y)) share</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(let ((xs (mapcar #'crypto-share-x (remove share shares))))</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(gf+ sum</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (gf* y (gf/ (lprod x0 xs)</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lprod x xs)) )) ))) )</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; (reduce #'term shares</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; :initial-value 0))) ))</font></div><div class=""><font face="Courier" class=""><br class=""></font></div><div class=""><font face="Courier" class="">(defun solve-gf-lagrange (x0 &amp;rest shares)</font></div><div class=""><font face="Courier" class="">&nbsp; (let ((fn (make-gf-lagrange-interpolator shares)))</font></div><div class=""><font face="Courier" class="">&nbsp; &nbsp; (funcall fn x0)))</font></div><div class=""><br class=""></div></div><div class=""><br class=""></div><div class="">In general, whatever field you choose to work over, you can take the same basic Lagrange interpolation skeletal structure shown here to compute a secret-sharing. You see the strong similarity between the Galois field version and the Elliptic Curve version. For Elliptic Curves, you need either a curve point (x,y) (different field than the interpolation polynomial), or else just use the X or the Y value of the ECC point, or an encoding of the point like an Elligator-2 value. Doesn’t really matter how you do it.</div><div class=""><br class=""></div><div class="">To be clear, a share is an (X, Y) pair on a 2-D manifold over some finite field. Knowing M of these points specifies exactly the (M-1)’th order polynomial that interpolates through those points. And your secret is the ordinate value at some special abscissa value along that interpolating polynomial.</div></div><div class=""><br class=""></div><div class="">No my idea at all. This goes back to Rivest as well. Very bright guy! Lisp makes it so easy to do.</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><br class=""></div></div></div></blockquote></div><br class=""></div></body></html>

                </article>
               </section>
              </section>
             </div>
            </div>
            <footer class="d-flex justify-content-center">
             <div>
              Updated at: 2020-12-07 08:28 UTC
             </div>
            </footer>
           </body>
          </html>