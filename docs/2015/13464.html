<!DOCTYPE html>
<html lang=en>
           <head>
            <meta charset=UTF-8>
            <title>Bignums?</title>
            <link rel=stylesheet
                  href=https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css
                  integrity=sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2
                  crossorigin=anonymous>
            <style>
section.tree {
    padding-left: 2em;
}
section.tree:first-child {
    padding-left: 0;
}
.article-link {
  margin-bottom: 1em;
}
</style>
<!-- Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-9X3G9MMWZP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-9X3G9MMWZP');
</script>

           </head>
           <body>
            <header class="d-flex justify-content-center">
             <nav
                  class="navbar navbar-light bg-light w-100 mx-5 mb-3">
              <a class=navbar-brand href="/">Lisp HUG Maillist Archive</a>
             </nav>
            </header>
            <div class="d-flex justify-content-center">
             <div class="w-100 mx-5 px-3">
              <section class=tree>
               <article class=email>
                <h1>Bignums?</h1>
                <pre>
I am seriously impressed with the speed of the LW Bignum operations. 

I have a bunch of prime number field operators defined on some very big Bignums. For comparison, I coded two versions of a left-to-right modular exponentiation function with squaring and multiplying modulo the prime; one version using NAF (non-adjacent-form) and the other just scanning every bit of the exponent. 

What I found is that my NAF version, which should have 30% fewer multiply operations, on average, is actually marginally slower than just scanning every bit of the exponent and doing modular multiplies and squaring. There is some overhead to produce a NAF encoding. But the speedup from fewer multiplies is outweighed by this overhead. 

In other words, Lisp is doing a better job on its own that with my attempts to help it along.

It would be really interesting to learn more about the quality and capabilities of the Bignum package. Is it, for instance, using Montgomery trees? Is it already using NAF internally for multiplication? There really isnâ€™t much documentation in the ways of Bignum, other than that it just works as expected.

- DM

_______________________________________________
Lisp Hug - the mailing list for LispWorks users
lisp-hug@lispworks.com
http://www.lispworks.com/support/lisp-hug.html


</pre>
               </article>
              </section>
             </div>
            </div>
            <footer class="d-flex justify-content-center">
             <div>
              Updated at: 2020-12-07 08:29 UTC
             </div>
            </footer>
           </body>
          </html>