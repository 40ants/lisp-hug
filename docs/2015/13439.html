<!DOCTYPE html>
<html lang=en>
           <head>
            <meta charset=UTF-8>
            <title>Plea for Unsigned Binary operators and a few more...</title>
            <link rel=stylesheet
                  href=https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css
                  integrity=sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2
                  crossorigin=anonymous>
            <style>
section.tree {
    padding-left: 2em;
}
section.tree:first-child {
    padding-left: 0;
}
.article-link {
  margin-bottom: 1em;
}
</style>
<!-- Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-9X3G9MMWZP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-9X3G9MMWZP');
</script>

           </head>
           <body>
            <header class="d-flex justify-content-center">
             <nav
                  class="navbar navbar-light bg-light w-100 mx-5 mb-3">
              <a class=navbar-brand href="/">Lisp HUG Maillist Archive</a>
             </nav>
            </header>
            <div class="d-flex justify-content-center">
             <div class="w-100 mx-5 px-3">
              <section class=tree>
               <article class=email>
                <h1>Plea for Unsigned Binary operators and a few more...</h1><html><head><meta http-equiv="Content-Type" content="text/html charset=utf-8"></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">In doing some crypto programming in Lisp I ran into a need for bit rotate operators. And just as surely, stumbled into the demand that INT32 and INT64 represent SIGNED-BYTE quantities… uh oh…<div class=""><br class=""></div><div class="">Signed arithmetic is asymmetric in left / right shift operators. In left shift a zero bit is shifted into the LSB of the register, while in right shifts the sign bit is propagated rightward. Hence, whenever a bit pattern (usually unsigned in crypto work) has its sign bit set, you can simply OR together left shifted and right shifted components to achieve a bit pattern rotate.</div><div class=""><br class=""></div><div class="">I came up with a “fast” (?) solution that dispenses with any test and branch by inventing a CNOT (conditional one’s complement) function:</div><div class=""><br class=""></div><div class=""><font face="Courier" class=""><span class="Apple-tab-span" style="white-space:pre">	</span>(defun cnot (x)</font></div><div class=""><font face="Courier" class=""><span class="Apple-tab-span" style="white-space:pre">		</span>(int64-logxor x</font></div><div class=""><font face="Courier" class=""><span class="Apple-tab-span" style="white-space:pre">			</span>(int64&gt;&gt; x 63)))</font></div><div class=""><br class=""></div><div class="">so that the propagating sign bit effects are removed when defining rotate operators:</div><div class=""><br class=""></div><div class=""><font face="Courier" class=""><span class="Apple-tab-span" style="white-space:pre">	</span>(defun rotl (x n)</font></div><div class=""><font face="Courier" class=""><span class="Apple-tab-span" style="white-space:pre">		</span>(int64-logxor</font></div><div class=""><font face="Courier" class=""><span class="Apple-tab-span" style="white-space:pre">			</span>(int64&gt;&gt; x (- 64 n))</font></div><div class=""><font face="Courier" class=""><span class="Apple-tab-span" style="white-space:pre">			</span>(int64&lt;&lt; (cnot x) n)))</font></div><div class=""><font face="Courier" class=""><br class=""></font></div><div class=""><font face="Courier" class=""><span class="Apple-tab-span" style="white-space: pre;">	</span>(defun rotr (x n)</font></div><div class=""><font face="Courier" class=""><span class="Apple-tab-span" style="white-space: pre;">		</span>(int64-logxor</font></div><div class=""><font face="Courier" class=""><span class="Apple-tab-span" style="white-space: pre;">			</span>(int64&gt;&gt; x n)</font></div><div class=""><font face="Courier" class=""><span class="Apple-tab-span" style="white-space: pre;">			</span>(int64&lt;&lt; (cnot x) (- 64 n))))</font></div><div class=""><br class=""></div><div class="">But it sure would be nice to have some ROT operators (ROTL, ROTR).</div><div class=""><br class=""></div><div class="">In addition, I can think of no instance where defaulting to unsigned behavior would be any different in arithmetic than signed, except in the right shift operation. So for this one case, there is the Symmetric case of Unsigned right-shift, and the Asymmetric case of Signed right-shift. Why not just default to unsigned operands always, and implement two different kinds of right-shift?</div><div class=""><br class=""></div><div class="">Am I missing any cases?</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><span class="Apple-tab-span" style="white-space:pre">			</span></div></body></html>

               </article>
               <section class=tree>
                <article class=email>
                 <h1>Re: Plea for Unsigned Binary operators and a few more...</h1><html><head><meta http-equiv="Content-Type" content="text/html charset=utf-8"></head><body style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">err… damn autocorrect… should have read:<div class=""><br class=""></div><div class="">“ in rotate you *cannot* simply OR together left shifted and … “</div><div class=""><br class=""></div><div class=""><br class=""></div><div class=""><div><blockquote type="cite" class=""><div class="">On Jun 27, 2015, at 4:22 PM, David McClain &lt;<a href="mailto:DBM@REFINED-AUDIOMETRICS.COM" class="">DBM@REFINED-AUDIOMETRICS.COM</a>&gt; wrote:</div><br class="Apple-interchange-newline"><div class=""><meta http-equiv="Content-Type" content="text/html charset=utf-8" class=""><div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;" class="">In doing some crypto programming in Lisp I ran into a need for bit rotate operators. And just as surely, stumbled into the demand that INT32 and INT64 represent SIGNED-BYTE quantities… uh oh…<div class=""><br class=""></div><div class="">Signed arithmetic is asymmetric in left / right shift operators. In left shift a zero bit is shifted into the LSB of the register, while in right shifts the sign bit is propagated rightward. Hence, whenever a bit pattern (usually unsigned in crypto work) has its sign bit set, you can simply OR together left shifted and right shifted components to achieve a bit pattern rotate.</div><div class=""><br class=""></div><div class="">I came up with a “fast” (?) solution that dispenses with any test and branch by inventing a CNOT (conditional one’s complement) function:</div><div class=""><br class=""></div><div class=""><font face="Courier" class=""><span class="Apple-tab-span" style="white-space:pre">	</span>(defun cnot (x)</font></div><div class=""><font face="Courier" class=""><span class="Apple-tab-span" style="white-space:pre">		</span>(int64-logxor x</font></div><div class=""><font face="Courier" class=""><span class="Apple-tab-span" style="white-space:pre">			</span>(int64&gt;&gt; x 63)))</font></div><div class=""><br class=""></div><div class="">so that the propagating sign bit effects are removed when defining rotate operators:</div><div class=""><br class=""></div><div class=""><font face="Courier" class=""><span class="Apple-tab-span" style="white-space:pre">	</span>(defun rotl (x n)</font></div><div class=""><font face="Courier" class=""><span class="Apple-tab-span" style="white-space:pre">		</span>(int64-logxor</font></div><div class=""><font face="Courier" class=""><span class="Apple-tab-span" style="white-space:pre">			</span>(int64&gt;&gt; x (- 64 n))</font></div><div class=""><font face="Courier" class=""><span class="Apple-tab-span" style="white-space:pre">			</span>(int64&lt;&lt; (cnot x) n)))</font></div><div class=""><font face="Courier" class=""><br class=""></font></div><div class=""><font face="Courier" class=""><span class="Apple-tab-span" style="white-space: pre;">	</span>(defun rotr (x n)</font></div><div class=""><font face="Courier" class=""><span class="Apple-tab-span" style="white-space: pre;">		</span>(int64-logxor</font></div><div class=""><font face="Courier" class=""><span class="Apple-tab-span" style="white-space: pre;">			</span>(int64&gt;&gt; x n)</font></div><div class=""><font face="Courier" class=""><span class="Apple-tab-span" style="white-space: pre;">			</span>(int64&lt;&lt; (cnot x) (- 64 n))))</font></div><div class=""><br class=""></div><div class="">But it sure would be nice to have some ROT operators (ROTL, ROTR).</div><div class=""><br class=""></div><div class="">In addition, I can think of no instance where defaulting to unsigned behavior would be any different in arithmetic than signed, except in the right shift operation. So for this one case, there is the Symmetric case of Unsigned right-shift, and the Asymmetric case of Signed right-shift. Why not just default to unsigned operands always, and implement two different kinds of right-shift?</div><div class=""><br class=""></div><div class="">Am I missing any cases?</div><div class=""><br class=""></div><div class="">- DM</div><div class=""><span class="Apple-tab-span" style="white-space:pre">			</span></div></div></div></blockquote></div><br class=""></div></body></html>

                </article>
               </section>
               <section class=tree>
                <article class=email>
                 <h1>Re: Plea for Unsigned Binary operators and a few more...</h1><div dir="ltr">I made a request for efficient 32/64-bit unsigned arithmetic some time ago as well. I likewise came up on this for crypto-like applications. Most recently, I ran across it in my implementation of Murmurhash 3..<div><br></div><div><a href="https://bitbucket.org/tarballs_are_good/murmurhash3">https://bitbucket.org/tarballs_are_good/murmurhash3</a><br></div><div><br></div><div>You can see the bit arithmetic code here</div><div><br></div><div><a href="https://bitbucket.org/tarballs_are_good/murmurhash3/raw/22430ee1a8daf81f3165bf0592ef30a4f29c4583/utilities.lisp">https://bitbucket.org/tarballs_are_good/murmurhash3/raw/22430ee1a8daf81f3165bf0592ef30a4f29c4583/utilities.lisp</a><br></div><div><br></div><div>SBCL has SB-ROTATE-BYTE:ROTATE-BYTE which, similar to DPB, allows rotation of arbitrary sub-bytes of an unsigned-byte.</div><div><br></div><div>Cheers,</div><div><br></div><div>Robert</div></div><div class="gmail_extra"><br><div class="gmail_quote">On Sat, Jun 27, 2015 at 4:36 PM, David McClain <span dir="ltr">&lt;<a href="mailto:dbm@refined-audiometrics.com" target="_blank">dbm@refined-audiometrics.com</a>&gt;</span> wrote:<br><blockquote class="gmail_quote" style="margin:0 0 0 .8ex;border-left:1px #ccc solid;padding-left:1ex"><div style="word-wrap:break-word">… along those lines, the demand for SIGNED-BYTE quantities also causes a stumbling block on conversion to / from INT32 and INT64. Any INTEGERs larger than #x7fff…. in whichever width causes heartburn to the conversion routine which barfs and says the bit pattern is too large, even though it explicitly fits within the stated bit-width of 32 or 64 bits. <div><br></div><div>Hence, the SIGNED-BYTE viewpoint requires a precautionary use of ENSURE-64BITS ahead of handing off any unsigned quantities, where</div><div><br></div><div><font face="Courier"><span style="white-space:pre-wrap">	</span>(define ensure-64bits (x)</font></div><div><font face="Courier"><span style="white-space:pre-wrap">		</span>(if (&gt;= x #.(ash 1 63))</font></div><div><font face="Courier"><span style="white-space:pre-wrap">			</span>(- x #.(ash 1 64))</font></div><div><font face="Courier"><span style="white-space:pre-wrap">		</span>    x))</font></div><div><br></div><div>There is really no difference in the resulting bit pattern, but this kind of nonsense is required to get past the bounds checking police…</div><span class="HOEnZb"><font color="#888888"><div><br></div><div>- DM</div></font></span><div><div class="h5"><div><br></div><div><br><div><blockquote type="cite"><div>On Jun 27, 2015, at 4:25 PM, David McClain &lt;<a href="mailto:DBM@REFINED-AUDIOMETRICS.COM" target="_blank">DBM@REFINED-AUDIOMETRICS.COM</a>&gt; wrote:</div><br><div><div style="word-wrap:break-word">err… damn autocorrect… should have read:<div><br></div><div>“ in rotate you *cannot* simply OR together left shifted and … “</div><div><br></div><div><br></div><div><div><blockquote type="cite"><div>On Jun 27, 2015, at 4:22 PM, David McClain &lt;<a href="mailto:DBM@REFINED-AUDIOMETRICS.COM" target="_blank">DBM@REFINED-AUDIOMETRICS.COM</a>&gt; wrote:</div><br><div><div style="word-wrap:break-word">In doing some crypto programming in Lisp I ran into a need for bit rotate operators. And just as surely, stumbled into the demand that INT32 and INT64 represent SIGNED-BYTE quantities… uh oh…<div><br></div><div>Signed arithmetic is asymmetric in left / right shift operators. In left shift a zero bit is shifted into the LSB of the register, while in right shifts the sign bit is propagated rightward. Hence, whenever a bit pattern (usually unsigned in crypto work) has its sign bit set, you can simply OR together left shifted and right shifted components to achieve a bit pattern rotate.</div><div><br></div><div>I came up with a “fast” (?) solution that dispenses with any test and branch by inventing a CNOT (conditional one’s complement) function:</div><div><br></div><div><font face="Courier"><span style="white-space:pre-wrap">	</span>(defun cnot (x)</font></div><div><font face="Courier"><span style="white-space:pre-wrap">		</span>(int64-logxor x</font></div><div><font face="Courier"><span style="white-space:pre-wrap">			</span>(int64&gt;&gt; x 63)))</font></div><div><br></div><div>so that the propagating sign bit effects are removed when defining rotate operators:</div><div><br></div><div><font face="Courier"><span style="white-space:pre-wrap">	</span>(defun rotl (x n)</font></div><div><font face="Courier"><span style="white-space:pre-wrap">		</span>(int64-logxor</font></div><div><font face="Courier"><span style="white-space:pre-wrap">			</span>(int64&gt;&gt; x (- 64 n))</font></div><div><font face="Courier"><span style="white-space:pre-wrap">			</span>(int64&lt;&lt; (cnot x) n)))</font></div><div><font face="Courier"><br></font></div><div><font face="Courier"><span style="white-space:pre-wrap">	</span>(defun rotr (x n)</font></div><div><font face="Courier"><span style="white-space:pre-wrap">		</span>(int64-logxor</font></div><div><font face="Courier"><span style="white-space:pre-wrap">			</span>(int64&gt;&gt; x n)</font></div><div><font face="Courier"><span style="white-space:pre-wrap">			</span>(int64&lt;&lt; (cnot x) (- 64 n))))</font></div><div><br></div><div>But it sure would be nice to have some ROT operators (ROTL, ROTR).</div><div><br></div><div>In addition, I can think of no instance where defaulting to unsigned behavior would be any different in arithmetic than signed, except in the right shift operation. So for this one case, there is the Symmetric case of Unsigned right-shift, and the Asymmetric case of Signed right-shift. Why not just default to unsigned operands always, and implement two different kinds of right-shift?</div><div><br></div><div>Am I missing any cases?</div><div><br></div><div>- DM</div><div><span style="white-space:pre-wrap">			</span></div></div></div></blockquote></div><br></div></div></div></blockquote></div><br></div></div></div></div></blockquote></div><br></div>


                </article>
               </section>
              </section>
             </div>
            </div>
            <footer class="d-flex justify-content-center">
             <div>
              Updated at: 2020-12-07 08:29 UTC
             </div>
            </footer>
           </body>
          </html>